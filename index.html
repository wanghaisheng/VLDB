<html>
          <head>
              <meta charset="utf-8"/>
              <style>
                  body, h1, ul, li, h2, h3, ol, label, input { margin: 0; padding: 0; }
                  body { font-size: 20px; margin: 0 auto; width: 1000px; }
                  a { text-decoration: none; color: #3B8DBD; }
                  a:hover { text-decoration: underline; }
                  label { cursor: pointer; }
                  ul > li { display: none; margin-top: 3em; }
                  h1 { font-size: 2em; padding-top: 2em; }
                  h1 > a { color: black; }
                  input[type=radio]#all:checked ~ div ul > li { display: block; }
                  input[type=radio]#big-data:checked ~ div ul > li[data-tags~="big-data"] { display: block; }
                  h2 { font-size: 1.5em; margin-top: 1em; }
                  h3 { font-size: 1.3em; }
                  h3 > a { color: #3B8DBD; }
                  ol { margin-top: 0.3em; list-style-type: none; }
                  ol ol > li { float: left; margin: 0 1.3em; }
                  ol ol > li > a { color: black; }
                  li > label { clear: both; display: block; margin-top: 2.5em; color: #82B964; }
                  input[type=checkbox] ~ div { text-align: justify; }
                  input[type=checkbox], input[type=checkbox]:not(:checked) ~ div { display: none; }
                  input[type=checkbox]:not(:checked) ~ label:before { content: "Show\0A"; }
                  input[type=checkbox]:not(:checked) ~ label:after { content: "\0A\02295"; }
                  input[type=checkbox]:checked ~ label:before { content: "Hide\0A"; }
                  input[type=checkbox]:checked ~ label:after { content: "\0A\02297"; }
                  input[type=checkbox]:checked ~ label { color: #D24D33; }
              </style>
          </head>
          <body>
            <form>
              <p>Filter by tags:</p>
              <input type="radio" name="foo" id="all" checked="checked"/> <label for="all">show all&thinsp;</label><br/>
              <input type="radio" name="foo" id="big-data"/> <label for="big-data">&thinsp;(&hearts;&ensp;&hearts;&ensp;&hearts;)&thinsp;: Big Data</label><br/>
              <input type="radio" name="foo" id="relevant-1"/> <label for="relevant-1">&ensp;&hearts;&thinsp;(&hearts;&ensp;&hearts;)&thinsp;: may read</label><br/>
              <input type="radio" name="foo" id="relevant-2"/> <label for="relevant-2">&ensp;&hearts;&ensp;&hearts;&thinsp;(&hearts;)&thinsp;: should read</label><br/>
              <input type="radio" name="foo" id="relevant-3"/> <label for="relevant-3">&ensp;&hearts;&ensp;&hearts;&ensp;&hearts;&ensp;: must read</label>
              <div>
          <h1>Volume 22 (February 2013 - August 2013)</h1>
          <ol><li>
          <h2>Issue 4 (August 2013)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0297-3">Modeling the execution semantics of stream processing engines with SECRET</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0297-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nihal+Dindar%22">Nihal Dindar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nesime+Tatbul%22">Nesime Tatbul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ren%C3%A9e+J.+Miller%22">Renée J. Miller</a></li><li><a href="http://link.springer.com/search?facet-author=%22Laura+M.+Haas%22">Laura M. Haas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Irina+Botan%22">Irina Botan</a></li></ol>
          <input type="checkbox" id="4671"/>
          <label for="4671">Abstract</label>
          <div>There are many academic and commercial stream processing engines (SPEs) today, each of them with its own execution semantics. This variation may lead to seemingly inexplicable differences in query results. In this paper, we present SECRET, a model of the behavior of SPEs. SECRET is a descriptive model that allows users to analyze the behavior of systems and understand the results of window-based queries (with time- and tuple-based windows) for a broad range of heterogeneous SPEs. The model is the result of extensive analysis and experimentation with several commercial and academic engines. In the paper, we describe the types of heterogeneity found in existing engines and show with experiments on real systems that our model can explain the key differences in windowing behavior.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0298-2">Recommending XML physical designs for XML databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0298-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Iman+Elghandour%22">Iman Elghandour</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ashraf+Aboulnaga%22">Ashraf Aboulnaga</a></li><li><a href="http://link.springer.com/search?facet-author=%22Daniel+C.+Zilio%22">Daniel C. Zilio</a></li><li><a href="http://link.springer.com/search?facet-author=%22Calisto+Zuzarte%22">Calisto Zuzarte</a></li></ol>
          <input type="checkbox" id="68010"/>
          <label for="68010">Abstract</label>
          <div>Database systems employ physical structures such as indexes and materialized views to improve query performance, potentially by orders of magnitude. It is therefore important for a database administrator to choose the appropriate configuration of these physical structures for a given database. XML database systems are increasingly being used to manage semi-structured data, and XML support has been added to commercial database systems. In this paper, we address the problem of automatic physical design for XML databases, which is the process of automatically selecting the best set of physical structures for a database and a query workload. We focus on recommending two types of physical structures: XML indexes and relational materialized views of XML data. We present a design advisor for recommending XML indexes, one for recommending materialized views, and an integrated design advisor that recommends both indexes and materialized views. A key characteristic of our advisors is that they are tightly coupled with the query optimizer of the database system, and they rely on the optimizer for enumerating and evaluating physical designs. We have implemented our advisors in a prototype version of IBM DB2 V9, and we experimentally demonstrate the effectiveness of their recommendations using this implementation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0299-1">Extending the power of datalog recursion</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0299-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mirjana+Mazuran%22">Mirjana Mazuran</a></li><li><a href="http://link.springer.com/search?facet-author=%22Edoardo+Serra%22">Edoardo Serra</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carlo+Zaniolo%22">Carlo Zaniolo</a></li></ol>
          <input type="checkbox" id="96093"/>
          <label for="96093">Abstract</label>
          <div>Supporting aggregates in recursive logic rules represents a very important problem for Datalog. To solve this problem, we propose a simple extension, called Datalog $^{FS}\,$ (Datalog extended with frequency support goals), that supports queries and reasoning about the number of distinct variable assignments satisfying given goals, or conjunctions of goals, in rules. This monotonic extension greatly enhances the power of Datalog, while preserving (i) its declarative semantics and  (ii) its amenability to efficient implementation via differential fixpoint and other optimization techniques presented in the paper. Thus, Datalog $^{FS}\,$ enables the efficient formulation of queries that could not be expressed efficiently or could not be expressed at all in Datalog with stratified negation and aggregates. In fact, using a generalized notion of multiplicity called frequency, we show that diffusion models and page rank computations can be easily expressed and efficiently implemented using Datalog $^{FS}\,$ .</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0300-z">QoS-aware optimization of sensor network queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0300-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ixent+Galpin%22">Ixent Galpin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alvaro+A.+A.+Fernandes%22">Alvaro A. A. Fernandes</a></li><li><a href="http://link.springer.com/search?facet-author=%22Norman+W.+Paton%22">Norman W. Paton</a></li></ol>
          <input type="checkbox" id="97776"/>
          <label for="97776">Abstract</label>
          <div>The resource-constrained nature of mote-level wireless sensor networks (WSNs) poses challenges for the design of a general-purpose sensor network query processors (SNQPs). Existing SNQPs tend to generate query execution plans (QEPs) that are selected on the basis of a fixed, implicit expectation, for example, that energy consumption should be kept as small as possible. However, in WSN applications, the same query may be subject to several, possibly conflicting, quality-of-service (QoS) expectations concomitantly (for example maximizing data acquisition rates subject to keeping energy consumption low). It is also not uncommon for the QoS expectations to change over the lifetime of a deployment (for example from low to high data acquisition rates). This paper describes optimization algorithms that respond to stated QoS expectations (about acquisition rate, delivery time, energy consumption and lifetime) when making routing, placement, and timing decisions for in-WSN query processing. The paper shows experimentally that QoS-awareness offers significant benefits in responding to, and reconciling, diverse QoS expectations, thereby enabling QoS-aware SNQPs to generate efficient QEPs for a broader range WSN applications than has hitherto been possible.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0303-9">Top-k queries over web applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0303-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniel+Deutch%22">Daniel Deutch</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tova+Milo%22">Tova Milo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Neoklis+Polyzotis%22">Neoklis Polyzotis</a></li></ol>
          <input type="checkbox" id="7588"/>
          <label for="7588">Abstract</label>
          <div>The core logic of web applications that suggest some particular service, such as online shopping, e-commerce etc., is typically captured by Business Processes (BPs). Among all the (maybe infinitely many) possible execution flows of a BP, analysts are often interested in identifying flows that are “most important”, according to some weight metric. The goal of the present paper is to provide efficient algorithms for top-k query evaluation over the possible executions of Business Processes, under some given weight function. Unique difficulties in top-k analysis in this settings stem from (1) the fact that the number of possible execution flows of a given BP is typically very large, or even infinite in presence of recursion and (2) that the weights (e.g., likelihood, monetary cost, etc.) induced by actions performed during the execution (e.g., product purchase) may be inter-dependent (due to probabilistic dependencies, combined discount deals etc.). We exemplify these difficulties, and overcome them to provide efficient algorithms for query evaluation where possible. We also describe in details an application prototype that we have developed for recommending optimal navigation in an online shopping web site that is based on our model and algorithms.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0304-8">Outsourcing shortest distance computing with privacy protection</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0304-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jun+Gao%22">Jun Gao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ruoming+Jin%22">Ruoming Jin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiashuai+Zhou%22">Jiashuai Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tengjiao+Wang%22">Tengjiao Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dongqing+Yang%22">Dongqing Yang</a></li></ol>
          <input type="checkbox" id="1421"/>
          <label for="1421">Abstract</label>
          <div>With the advent of cloud computing, it becomes desirable to outsource graphs into cloud servers to efficiently perform complex operations without compromising their sensitive information. In this paper, we take the shortest distance computation as a case to investigate the technique issues in outsourcing graph operations. We first propose a parameter-free, edge-based 2-HOP delegation security model (shorten as 2-HOP delegation model), which can greatly reduce the chances of the structural pattern attack and the graph reconstruction attack. We then transform the original graph into a link graph $G_l$ kept locally and a set of outsourced graphs $\mathcal G _o$ . Our objectives include (i) ensuring each outsourced graph meeting the requirement of 2-HOP delegation model, (ii) making shortest distance queries be answered using $G_l$ and $\mathcal G _o$ , (iii) minimizing the space cost of $G_l$ . We devise a greedy method to produce $G_l$ and $\mathcal G _o$ , which can exactly answer shortest distance queries. We also develop an efficient transformation method to support approximate shortest distance answering under a given average additive error bound. The experimental results illustrate the effectiveness and efficiency of our method.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0305-7">Super-EGO: fast multi-dimensional similarity join</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0305-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dmitri+V.+Kalashnikov%22">Dmitri V. Kalashnikov</a></li></ol>
          <input type="checkbox" id="35683"/>
          <label for="35683">Abstract</label>
          <div>Efficient processing of high-dimensional similarity joins plays an important role for a wide variety of data-driven applications. In this paper, we consider $\varepsilon $ -join variant of the problem. Given two $d$ -dimensional datasets and parameter $\varepsilon $ , the task is to find all pairs of points, one from each dataset that are within $\varepsilon $ distance from each other. We propose a new $\varepsilon $ -join algorithm, called Super-EGO, which belongs the EGO family of join algorithms. The new algorithm gains its advantage by using novel data-driven dimensionality re-ordering technique, developing a new EGO-strategy that more aggressively avoids unnecessary computation, as well as by developing a parallel version of the algorithm. We study the newly proposed Super-EGO algorithm on large real and synthetic datasets. The empirical study demonstrates significant advantage of the proposed solution over the existing state of the art techniques.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (June 2013)</h2>
          <ul><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0288-4">Computing weight constraint reachability in large networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0288-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Miao+Qiao%22">Miao Qiao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hong+Cheng%22">Hong Cheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lu+Qin%22">Lu Qin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lijun+Chang%22">Lijun Chang</a></li></ol>
          <input type="checkbox" id="40078"/>
          <label for="40078">Abstract</label>
          <div>Reachability is a fundamental problem on large-scale networks emerging nowadays in various application domains, such as social networks, communication networks, biological networks, road networks, etc. It has been studied extensively. However, little existing work has studied reachability with realistic constraints imposed on graphs with real-valued edge or node weights. In fact, such weights are very common in many real-world networks, for example, the bandwidth of a link in communication networks, the reliability of an interaction between two proteins in PPI networks, and the handling capacity of a warehouse/storage point in a distribution network. In this paper, we formalize a new yet important reachability query in weighted undirected graphs, called weight constraint reachability (WCR) query that asks: is there a path between nodes $a$ and $b$ , on which each real-valued edge (or node) weight satisfies a range constraint. We discover an interesting property of WCR, based on which, we design a novel edge-based index structure to answer the WCR query in $O(1)$ time. Furthermore, we consider the case when the index cannot entirely fit in the memory, which can be very common for emerging massive networks. An I/O-efficient index is proposed, which provides constant I/O (precisely four I/Os) query time with $O(|V|\log |V|)$ disk-based index size. Extensive experimental studies on both real and synthetic datasets demonstrate the efficiency and scalability of our solutions in answering the WCR query.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0289-3">Pattern discovery in data streams under the time warping distance</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0289-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Machiko+Toyoda%22">Machiko Toyoda</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yasushi+Sakurai%22">Yasushi Sakurai</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yoshiharu+Ishikawa%22">Yoshiharu Ishikawa</a></li></ol>
          <input type="checkbox" id="85441"/>
          <label for="85441">Abstract</label>
          <div>Subsequence matching is a basic problem in the field of data stream mining. In recent years, there has been significant research effort spent on efficiently finding subsequences similar to a query sequence. Another challenging issue in relation to subsequence matching is how we identify common local patterns when both sequences are evolving. This problem arises in trend detection, clustering, and outlier detection. Dynamic time warping (DTW) is often used for subsequence matching and is a powerful similarity measure. However, the straightforward method using DTW incurs a high computation cost for this problem. In this paper, we propose a one-pass algorithm, CrossMatch, that achieves the above goal. CrossMatch addresses two important challenges: (1) how can we identify common local patterns efficiently without any omission? (2) how can we find common local patterns in data stream processing? To tackle these challenges, CrossMatch incorporates three ideas: (1) a scoring function, which computes the DTW distance indirectly to reduce the computation cost, (2) a position matrix, which stores starting positions to keep track of common local patterns in a streaming fashion, and (3) a streaming algorithm, which identifies common local patterns efficiently and outputs them on the fly. We provide a theoretical analysis and prove that our algorithm does not sacrifice accuracy. Our experimental evaluation and case studies show that CrossMatch can incrementally discover common local patterns in data streams within constant time (per update) and space.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0290-x">UV-diagram: a voronoi diagram for uncertain spatial databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0290-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xike+Xie%22">Xike Xie</a></li><li><a href="http://link.springer.com/search?facet-author=%22Reynold+Cheng%22">Reynold Cheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Man+Lung+Yiu%22">Man Lung Yiu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Liwen+Sun%22">Liwen Sun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jinchuan+Chen%22">Jinchuan Chen</a></li></ol>
          <input type="checkbox" id="7952"/>
          <label for="7952">Abstract</label>
          <div>The Voronoi diagram is an important technique for answering nearest-neighbor queries for spatial databases. We study how the Voronoi diagram can be used for uncertain spatial data, which are inherent in scientific and business applications. Specifically, we propose the Uncertain-Voronoi diagram (or UV-diagram), which divides the data space into disjoint “UV-partitions”. Each UV-partition $P$ is associated with a set $S$ of objects, such that any point $q$ located in $P$ has the set $S$ as its nearest neighbor with nonzero probabilities. The UV-diagram enables queries that return objects with nonzero chances of being the nearest neighbor (NN) of a given point $q$ . It supports “continuous nearest-neighbor search”, which refreshes the set of NN objects of $q$ , as the position of $q$ changes. It also allows the analysis of nearest-neighbor information, for example, to find out the number of objects that are the nearest neighbors of any point in a given area. A UV-diagram requires exponential construction and storage costs. To tackle these problems, we devise an alternative representation of a UV-diagram, by using a set of UV-cells. A UV-cell of an object $o$ is the extent $e$ for which $o$ can be the nearest neighbor of any point $q \in e$ . We study how to speed up the derivation of UV-cells by considering its nearby objects. We also use the UV-cells to design the UV-index, which supports different queries, and can be constructed in polynomial time. We have performed extensive experiments on both real and synthetic data to validate the efficiency of our approaches.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0292-8">High efficiency and quality: large graphs matching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0292-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yuanyuan+Zhu%22">Yuanyuan Zhu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lu+Qin%22">Lu Qin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yiping+Ke%22">Yiping Ke</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li></ol>
          <input type="checkbox" id="3392"/>
          <label for="3392">Abstract</label>
          <div>Graph matching plays an essential role in many real applications. In this paper, we study how to match two large graphs by maximizing the number of matched edges, which is known as maximum common subgraph matching and is NP-hard. To find exact matching, it cannot a graph with more than 30 nodes. To find an approximate matching, the quality can be very poor. We propose a novel two-step approach that can efficiently match two large graphs over thousands of nodes with high matching quality. In the first step, we propose an anchor-selection/expansion approach to compute a good initial matching. In the second step, we propose a new approach to refine the initial matching. We give the optimality of our refinement and discuss how to randomly refine the matching with different combinations. We further show how to extend our solution to handle labeled graphs. We conducted extensive testing using real and synthetic datasets and report our findings in this paper.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0295-5">Optimal and efficient generalized twig pattern processing: a combination of preorder and postorder filterings</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0295-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Radim+Ba%C4%8Da%22">Radim Bača</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michal+Kr%C3%A1tk%C3%BD%22">Michal Krátký</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tok+Wang+Ling%22">Tok Wang Ling</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiaheng+Lu%22">Jiaheng Lu</a></li></ol>
          <input type="checkbox" id="53420"/>
          <label for="53420">Abstract</label>
          <div>Searching for occurrences of a twig pattern query (TPQ) in an XML document is a core task of all XML database query languages. The generalized twig pattern (GTP) extends the TPQ model to include semantics related to output nodes, optional nodes, and boolean expressions which are part of the XQuery language. Preorder filtering holistic algorithms such as TwigStack represent a significant class of TPQ processing approaches with a linear worst-case I/O complexity with respect to the sum of the input and output sizes for some query classes. Another important class of holistic approaches is represented by postorder filtering holistic algorithms such as $\text{ Twig}^2$ Stack which introduced a linear output enumeration time with respect to the result size. In this article, we introduce a holistic algorithm called GTPStack which is the first approach capable of processing a GTP with a linear worst-case I/O complexity with respect to the GTP result size. This is achieved by using a combination of the preorder and postorder filterings before storing nodes in an intermediate storage. Additionally, another contribution of this article is an introduction of a new perspective of holistic algorithm optimality. We show that the optimality depends not only on a query class but also on XML document characteristics. This new view on the optimality extends the general knowledge about the type of queries for which the holistic algorithms are optimal. Moreover, it allows us to determine that GTPStack is optimal for any GTP when a specific XML document is considered. We present a comprehensive experimental study of the state-of-the-art holistic algorithms showing under which conditions GTPStack outperforms the other holistic approaches.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0296-4">Similarity queries: their conceptual evaluation, transformations, and processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0296-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yasin+N.+Silva%22">Yasin N. Silva</a></li><li><a href="http://link.springer.com/search?facet-author=%22Walid+G.+Aref%22">Walid G. Aref</a></li><li><a href="http://link.springer.com/search?facet-author=%22Per-Ake+Larson%22">Per-Ake Larson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Spencer+S.+Pearson%22">Spencer S. Pearson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+H.+Ali%22">Mohamed H. Ali</a></li></ol>
          <input type="checkbox" id="55325"/>
          <label for="55325">Abstract</label>
          <div>Many application scenarios can significantly benefit from the identification and processing of similarities in the data. Even though some work has been done to extend the semantics of some operators, for example join and selection, to be aware of data similarities, there has not been much study on the role and implementation of similarity-aware operations as first-class database operators. Furthermore, very little work has addressed the problem of evaluating and optimizing queries that combine several similarity operations. The focus of this paper is the study of similarity queries that contain one or multiple first-class similarity database operators such as Similarity Selection, Similarity Join, and Similarity Group-by. Particularly, we analyze the implementation techniques of several similarity operators, introduce a consistent and comprehensive conceptual evaluation model for similarity queries, and present a rich set of transformation rules to extend cost-based query optimization to the case of similarity queries.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 2013)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0277-7">Mining frequent conjunctive queries using functional and inclusion dependencies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0277-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Cheikh+Tidiane+Dieng%22">Cheikh Tidiane Dieng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tao-Yuan+Jen%22">Tao-Yuan Jen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dominique+Laurent%22">Dominique Laurent</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nicolas+Spyratos%22">Nicolas Spyratos</a></li></ol>
          <input type="checkbox" id="62034"/>
          <label for="62034">Abstract</label>
          <div>We address the issue of mining frequent conjunctive queries in a relational database, a problem known to be intractable even for conjunctive queries over a single table. In this article, we show that mining frequent projection-selection-join queries becomes tractable if joins are performed along keys and foreign keys, in a database satisfying functional and inclusion dependencies, under certain restrictions. We note that these restrictions cover most practical cases, including databases operating over star schemas, snow-flake schemas and constellation schemas. In our approach, we define an equivalence relation over queries using a pre-ordering with respect to which the support is shown to be anti-monotonic. We propose a level-wise algorithm for computing all frequent queries by exploiting the fact that equivalent queries have the same support. We report on experiments showing that, in our context, mining frequent projection-selection-join queries is indeed tractable, even for large data sets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0278-6">Scalable and dynamically balanced shared-everything OLTP with physiological partitioning</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0278-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22P%C4%B1nar+T%C3%B6z%C3%BCn%22">Pınar Tözün</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ippokratis+Pandis%22">Ippokratis Pandis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ryan+Johnson%22">Ryan Johnson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anastasia+Ailamaki%22">Anastasia Ailamaki</a></li></ol>
          <input type="checkbox" id="38177"/>
          <label for="38177">Abstract</label>
          <div>Scaling the performance of shared-everything transaction processing systems to highly parallel multicore hardware remains a challenge for database system designers. Recent proposals alleviate locking and logging bottlenecks in the system, leaving page latching as the next potential problem. To tackle the page latching problem, we propose physiological partitioning (PLP). PLP applies logical-only partitioning, maintaining the desired properties of sharedeverything designs, and introduces a multi-rooted B+Tree index structure (MRBTree) that enables the partitioning of the accesses at the physical page level. Logical partitioning and MRBTrees together ensure that all accesses to a given index page come from a single thread and, hence, can be entirely latch free; an extended design makes heap page accesses thread private as well. Moreover, MRBTrees offer an infrastructure for easy repartitioning and allow us to have a lightweight dynamic load balancing mechanism (DLB) on top of PLP. Profiling a PLP prototype running on different multicore machines shows that it acquires 85 and 68%fewer contentious critical sections, respectively, than an optimized conventional design and one based on logical-only partitioning. PLP also improves performance up to almost 50 % over the existing systems, while DLB enhances the system with rapid and robust behavior in both detecting and handling load imbalances.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0281-y">A survey on XML streaming evaluation techniques</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0281-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xiaoying+Wu%22">Xiaoying Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitri+Theodoratos%22">Dimitri Theodoratos</a></li></ol>
          <input type="checkbox" id="50630"/>
          <label for="50630">Abstract</label>
          <div>XML is currently the most popular format for exchanging and representing data on the web. It is used in various applications and for different types of data including structured, semistructured, and unstructured heterogeneous data types. During the period, XML was establishing itself, data streaming applications have gained increased attention and importance. Because of these developments, the querying and efficient processing of XML streams has became a central issue. In this study, we survey the state of the art in XML streaming evaluation techniques. We focus on both the streaming evaluation of XPath expressions and of XQuery queries. We classify the XPath streaming evaluation approaches according to the main data structure used for the evaluation into three categories: automaton-based approach, array-based approach, and stack-based approach. We review, analyze, and compare the major techniques proposed for each approach. We also review multiple query streaming evaluation techniques. For the XQuery streaming evaluation problem, we identify and discuss four processing paradigms adopted by the existing XQuery stream query engines: the transducer-based paradigm, the algebra-based paradigm, the automata-algebra paradigm, and the pull-based paradigm. In addition, we review optimization techniques for XQuery streaming evaluation. We address the problem of optimizing XQuery streaming evaluation as a buffer optimization problem. For all techniques discussed, we describe the research issues and the proposed algorithms and we compare them with other relevant suggested techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0282-x">Auditing a database under retention policies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0282-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wentian+Lu%22">Wentian Lu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerome+Miklau%22">Gerome Miklau</a></li><li><a href="http://link.springer.com/search?facet-author=%22Neil+Immerman%22">Neil Immerman</a></li></ol>
          <input type="checkbox" id="52333"/>
          <label for="52333">Abstract</label>
          <div>Auditing the changes to a database is critical for identifying malicious behavior, maintaining data quality, and improving system performance. But an accurate audit log is an historical record of the past that can also pose a serious threat to privacy. Policies that limit data retention conflict with the goal of accurate auditing, and data owners have to carefully balance the need for policy compliance with the goal of accurate auditing. In this paper, we provide a framework for auditing the changes to a database system while respecting data retention policies. Our framework includes an historical data model that supports flexible audit queries, along with a language for retention policies that can hide individual attribute values or remove entire tuples from the history. Under retention policies, the audit history is partially incomplete. Thus, audit queries on the protected history can include imprecise results. We propose two different models (a tuple-independent model and a tuple-correlated model) for formalizing the meaning of audit queries. We implement policy application and query answering efficiently in a standard relational system and characterize the cases where accurate auditing can be achieved under retention restrictions.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0284-8">Lindex: a lattice-based index for graph databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0284-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dayu+Yuan%22">Dayu Yuan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Prasenjit+Mitra%22">Prasenjit Mitra</a></li></ol>
          <input type="checkbox" id="66364"/>
          <label for="66364">Abstract</label>
          <div>Subgraph querying has wide applications in various fields such as cheminformatics and bioinformatics. Given a query graph, q, a subgraph-querying algorithm retrieves all graphs, D(q), which have q as a subgraph, from a graph database, D. Subgraph querying is costly because it uses subgraph isomorphism tests, which are NP-complete. Graph indices are commonly used to improve the performance of subgraph querying in graph databases. Subgraph-querying algorithms first construct a candidate answer set by filtering out a set of false answers and then verify each candidate graph using subgraph isomorphism tests. To build graph indices, various kinds of substructure (subgraph, subtree, or path) features have been proposed with the goal of maximizing the filtering rate. Each of them works with a specifically designed index structure, for example, discriminative and frequent subgraph features work with gIndex, δ-TCFG features work with FG-index, etc. We propose Lindex, a graph index, which indexes subgraphs contained in database graphs. Nodes in Lindex represent key-value pairs where the key is a subgraph in a database and the value is a list of database graphs containing the key. We propose two heuristics that are used in the construction of Lindex that allows us to determine answers to subgraph queries conducting less subgraph isomorphism tests. Consequently, Lindex improves subgraph-querying efficiency. In addition, Lindex is compatible with any choice of features. Empirically, we demonstrate that Lindex used in conjunction with subgraph indexing features proposed in previous works outperforms other specifically designed index structures. As a novel index structure, Lindex (1) is effective in filtering false graphs (2) provides fast index lookups, (3) is fast with respect to index construction and maintenance, and (4) can be constructed using any set of substructure index features. These four properties result in a fast and scalable subgraph-querying infrastructure. We substantiate the benefits of Lindex and its disk-resident variation Lindex+ theoretically and empirically.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0285-7">Comparable dependencies over heterogeneous data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0285-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Shaoxu+Song%22">Shaoxu Song</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li></ol>
          <input type="checkbox" id="81352"/>
          <label for="81352">Abstract</label>
          <div>To study the data dependencies over heterogeneous data in dataspaces, we define a general dependency form, namely comparable dependencies (CDS), which specifies constraints on comparable attributes. It covers the semantics of a broad class of dependencies in databases, including functional dependencies (FDS), metric functional dependencies (MFDS), and matching dependencies (MDS). As we illustrated, comparable dependencies are useful in real practice of dataspaces, such as semantic query optimization. Due to heterogeneous data in dataspaces, the first question, known as the validation problem, is to tell whether a dependency (almost) holds in a data instance. Unfortunately, as we proved, the validation problem with certain error or confidence guarantee is generally hard. In fact, the confidence validation problem is also NP-hard to approximate to within any constant factor. Nevertheless, we develop several approaches for efficient approximation computation, such as greedy and randomized approaches with an approximation bound on the maximum number of violations that an object may introduce. Finally, through an extensive experimental evaluation on real data, we verify the superiority of our methods.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (February 2013)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0301-y">Special issue on best papers of VLDB 2011</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0301-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wolfgang+Lehner%22">Wolfgang Lehner</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sunita+Sarawagi%22">Sunita Sarawagi</a></li></ol>
          <input type="checkbox" id="44122"/>
          <label for="44122">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0293-7">Efficiently adapting graphical models for selectivity estimation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0293-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kostas+Tzoumas%22">Kostas Tzoumas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amol+Deshpande%22">Amol Deshpande</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li></ol>
          <input type="checkbox" id="31212"/>
          <label for="31212">Abstract</label>
          <div>Query optimizers rely on statistical models that succinctly describe the underlying data. Models are used to derive cardinality estimates for intermediate relations, which in turn guide the optimizer to choose the best query execution plan. The quality of the resulting plan is highly dependent on the accuracy of the statistical model that represents the data. It is well known that small errors in the model estimates propagate exponentially through joins, and may result in the choice of a highly sub-optimal query execution plan. Most commercial query optimizers make the attribute value independence assumption: all attributes are assumed to be statistically independent. This reduces the statistical model of the data to a collection of one-dimensional synopses (typically in the form of histograms), and it permits the optimizer to estimate the selectivity of a predicate conjunction as the product of the selectivities of the constituent predicates. However, this independence assumption is more often than not wrong, and is considered to be the most common cause of sub-optimal query execution plans chosen by modern query optimizers. We take a step towards a principled and practical approach to performing cardinality estimation without making the independence assumption. By carefully using concepts from the field of graphical models, we are able to factor the joint probability distribution over all the attributes in the database into small, usually two-dimensional distributions, without a significant loss in estimation accuracy. We show how to efficiently construct such a graphical model from the database using only two-way join queries, and we show how to perform selectivity estimation in a highly efficient manner. We integrate our algorithms into the PostgreSQL DBMS. Experimental results indicate that estimation errors can be greatly reduced, leading to orders of magnitude more efficient query execution plans in many cases. Optimization time is kept in the range of tens of milliseconds, making this a practical approach for industrial-strength query optimizers.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0294-6">RemusDB: transparent high availability for database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0294-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Umar+Farooq+Minhas%22">Umar Farooq Minhas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shriram+Rajagopalan%22">Shriram Rajagopalan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Brendan+Cully%22">Brendan Cully</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ashraf+Aboulnaga%22">Ashraf Aboulnaga</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kenneth+Salem%22">Kenneth Salem</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andrew+Warfield%22">Andrew Warfield</a></li></ol>
          <input type="checkbox" id="70138"/>
          <label for="70138">Abstract</label>
          <div>In this paper, we present a technique for building a high-availability (HA) database management system (DBMS). The proposed technique can be applied to any DBMS with little or no customization, and with reasonable performance overhead. Our approach is based on Remus, a commodity HA solution implemented in the virtualization layer, that uses asynchronous virtual machine state replication to provide transparent HA and failover capabilities. We show that while Remus and similar systems can protect a DBMS, database workloads incur a performance overhead of up to 32 % as compared to an unprotected DBMS. We identify the sources of this overhead and develop optimizations that mitigate the problems. We present an experimental evaluation using two popular database systems and industry standard benchmarks showing that for certain workloads, our optimized approach provides fast failover ( $\le $ 3 s of downtime) with low performance overhead when compared to an unprotected DBMS. Our approach provides a practical means for existing, deployed database systems to be made more reliable with a minimum of risk, cost, and effort. Furthermore, this paper invites new discussion about whether the complexity of HA is best implemented within the DBMS, or as a service by the infrastructure below it.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0286-6">OXPath: A language for scalable data extraction, automation, and crawling on the deep web</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0286-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Tim+Furche%22">Tim Furche</a></li><li><a href="http://link.springer.com/search?facet-author=%22Georg+Gottlob%22">Georg Gottlob</a></li><li><a href="http://link.springer.com/search?facet-author=%22Giovanni+Grasso%22">Giovanni Grasso</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+Schallhart%22">Christian Schallhart</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andrew+Sellers%22">Andrew Sellers</a></li></ol>
          <input type="checkbox" id="47481"/>
          <label for="47481">Abstract</label>
          <div>The evolution of the web has outpaced itself: A growing wealth of information and increasingly sophisticated interfaces necessitate automated processing, yet existing automation and data extraction technologies have been overwhelmed by this very growth. To address this trend, we identify four key requirements for web data extraction, automation, and (focused) web crawling: (1) interact with sophisticated web application interfaces, (2) precisely capture the relevant data to be extracted, (3) scale with the number of visited pages, and (4) readily embed into existing web technologies. We introduce OXPath as an extension of XPath for interacting with web applications and extracting data thus revealed—matching all the above requirements. OXPath’s page-at-a-time evaluation guarantees memory use independent of the number of visited pages, yet remains polynomial in time. We experimentally validate the theoretical complexity and demonstrate that OXPath’s resource consumption is dominated by page rendering in the underlying browser. With an extensive study of sublanguages and properties of OXPath, we pinpoint the effect of specific features on evaluation performance. Our experiments show that OXPath outperforms existing commercial and academic data extraction tools by a wide margin.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0302-x">Automating the database schema evolution process</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0302-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Carlo+Curino%22">Carlo Curino</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hyun+Jin+Moon%22">Hyun Jin Moon</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alin+Deutsch%22">Alin Deutsch</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carlo+Zaniolo%22">Carlo Zaniolo</a></li></ol>
          <input type="checkbox" id="38026"/>
          <label for="38026">Abstract</label>
          <div>Supporting database schema evolution represents a long-standing challenge of practical and theoretical importance for modern information systems. In this paper, we describe techniques and systems for automating the critical tasks of migrating the database and rewriting the legacy applications. In addition to labor saving, the benefits delivered by these advances are many and include reliable prediction of outcome, minimization of downtime, system-produced documentation, and support for archiving, historical queries, and provenance. The PRISM/PRISM++ system delivers these benefits, by solving the difficult problem of automating the migration of databases and the rewriting of queries and updates. In this paper, we present the PRISM/PRISM++ system and the novel technology that made it possible. In particular, we focus on the difficult and previously unsolved problem of supporting legacy queries and updates under schema and integrity constraints evolution. The PRISM/PRISM++ approach consists in providing the users with a set of SQL-based Schema Modification Operators (SMOs), which describe how the tables in the old schema are modified into those in the new schema. In order to support updates, SMOs are extended with integrity constraints modification operators. By using recent results on schema mapping, the paper (i) characterizes the impact on integrity constraints of structural schema changes, (ii) devises representations that enable the rewriting of updates, and (iii) develop a unified approach for query and update rewriting under constraints. We complement the system with two novel tools: the first automatically collects and provides statistics on schema evolution histories, whereas the second derives equivalent sequences of SMOs from the migration scripts that were used for schema upgrades. These tools were used to produce an extensive testbed containing 15 evolution histories of scientific databases and web information systems, providing over 100 years of aggregate evolution histories and almost 2,000 schema evolution steps.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0287-5">Keyword search on form results</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0287-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Aditya+Ramesh%22">Aditya Ramesh</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Sudarshan%22">S. Sudarshan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Purva+Joshi%22">Purva Joshi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Manisha+Naik+Gaonkar%22">Manisha Naik Gaonkar</a></li></ol>
          <input type="checkbox" id="53911"/>
          <label for="53911">Abstract</label>
          <div>In recent years there has been a good deal of research in the area of keyword search on structured and semistructured data. Most of this body of work has a significant limitation in the context of enterprise data, since it ignores the application code that has often been carefully designed to present data in a meaningful fashion to users. In this work, we consider how to perform keyword search on enterprise applications, which provide a number of forms that can take parameters; parameters may be explicit, or implicit such as the identifier of the user. In the context of such applications, the goal of keyword search is, given a set of keywords, to retrieve forms along with corresponding parameter values, such that result of each retrieved form executed on the corresponding retrieved parameter values will contain the specified keywords. Some earlier work in this area was based on creating keyword indices on form results, but there are problems in maintaining such indices in the face of updates. In contrast, we propose techniques based on creating inverted SQL queries from the SQL queries in the forms. Unlike earlier work, our techniques do not require any special purpose indices and instead make use of standard text indices supported by most database systems. We have implemented our techniques and show that keyword search can run at reasonable speeds even on large databases with a significant number of forms.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 21 (February 2012 - December 2012)</h1>
          <ol><li>
          <h2>Issue 6 (December 2012)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0268-8">Mining frequent subgraphs over uncertain graph databases under probabilistic semantics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0268-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jianzhong+Li%22">Jianzhong Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhaonian+Zou%22">Zhaonian Zou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hong+Gao%22">Hong Gao</a></li></ol>
          <input type="checkbox" id="29991"/>
          <label for="29991">Abstract</label>
          <div>Frequent subgraph mining has been extensively studied on certain graph data. However, uncertainty is intrinsic in graph data in practice, but there is very few work on mining uncertain graph data. This paper focuses on mining frequent subgraphs over uncertain graph data under the probabilistic semantics. Specifically, a measure called ${\varphi}$ -frequent probability is introduced to evaluate the degree of recurrence of subgraphs. Given a set of uncertain graphs and two real numbers ${0 < \varphi, \tau < 1}$ , the goal is to quickly find all subgraphs with ${\varphi}$ -frequent probability at least τ. Due to the NP-hardness of the problem and to the #P-hardness of computing the ${\varphi}$ -frequent probability of a subgraph, an approximate mining algorithm is proposed to produce an ${(\varepsilon, \delta)}$ -approximate set Π of “frequent subgraphs”, where ${0 < \varepsilon < \tau}$ is error tolerance, and 0 < δ < 1 is a confidence bound. The algorithm guarantees that (1) any frequent subgraph S is contained in Π with probability at least ((1 − δ) /2) s , where s is the number of edges in S; (2) any infrequent subgraph with ${\varphi}$ -frequent probability less than ${\tau - \varepsilon}$ is contained in Π with probability at most δ/2. The theoretical analysis shows that to obtain any frequent subgraph with probability at least 1 − Δ, the input parameter δ of the algorithm must be set to at most ${1 - 2 (1 - \Delta)^{1 / \ell_{\max}}}$ , where 0 < Δ < 1, and ℓ max is the maximum number of edges in frequent subgraphs. Extensive experiments on real uncertain graph data verify that the proposed algorithm is practically efficient and has very high approximation quality. Moreover, the difference between the probabilistic semantics and the expected semantics on mining frequent subgraphs over uncertain graph data has been discussed in this paper for the first time.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0270-1">Approximate regional sequence matching for genomic databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0270-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Thanasis+Vergoulis%22">Thanasis Vergoulis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Theodore+Dalamagas%22">Theodore Dalamagas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Sacharidis%22">Dimitris Sacharidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+Sellis%22">Timos Sellis</a></li></ol>
          <input type="checkbox" id="21473"/>
          <label for="21473">Abstract</label>
          <div>Recent advances in computational biology have raised sequence matching requirements that result in new types of sequence database problems. In this work, we introduce an important class of such problems, the approximate regional sequence matching (ARSM) problem. Given a data and a pattern sequence, an ARSM result is an approximate occurrence of a region of the pattern in the data sequence under two conditions. First, the region must contain a predetermined area of the pattern sequence, termed core. Second, the allowable deviation between the region of the pattern and its occurrence in the data sequence depends on the length of the region. We propose the PS-ARSM method that processes holistically the regions of a pattern, taking advantage of their overlaps to efficiently identify the ARSM results. Its performance is evaluated with respect to existing techniques adapted to the ARSM problem.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0271-0">A framework for efficient spatial web object retrieval</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0271-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dingming+Wu%22">Dingming Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gao+Cong%22">Gao Cong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li></ol>
          <input type="checkbox" id="53983"/>
          <label for="53983">Abstract</label>
          <div>The conventional Internet is acquiring a geospatial dimension. Web documents are being geo-tagged and geo-referenced objects such as points of interest are being associated with descriptive text documents. The resulting fusion of geo-location and documents enables new kinds of queries that take into account both location proximity and text relevancy. This paper proposes a new indexing framework for top-k spatial text retrieval. The framework leverages the inverted file for text retrieval and the R-tree for spatial proximity querying. Several indexing approaches are explored within this framework. The framework encompasses algorithms that utilize the proposed indexes for computing location-aware as well as region-aware top-k text retrieval queries, thus taking into account both text relevancy and spatial proximity to prune the search space. Results of empirical studies with an implementation of the framework demonstrate that the paper’s proposal is capable of excellent performance.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0272-z">Query language-based inverses of schema mappings: semantics, computation, and closure properties</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0272-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Marcelo+Arenas%22">Marcelo Arenas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jorge+P%C3%A9rez%22">Jorge Pérez</a></li><li><a href="http://link.springer.com/search?facet-author=%22Juan+Reutter%22">Juan Reutter</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cristian+Riveros%22">Cristian Riveros</a></li></ol>
          <input type="checkbox" id="42056"/>
          <label for="42056">Abstract</label>
          <div>The inversion of schema mappings has been identified as one of the fundamental operators for the development of a general framework for metadata management. During the last few years, three alternative notions of inversion for schema mappings have been proposed (Fagin-inverse (Fagin, TODS 32(4), 25:1–25:53, 2007), quasi-inverse (Fagin et al., TODS 33(2), 11:1–11:52, 2008), and maximum recovery (Arenas et al., TODS 34(4), 22:1–22:48, 2009)). However, these notions lack some fundamental properties that limit their practical applicability: most of them are expressed in languages including features that are difficult to use in practice, some of these inverses are not guaranteed to exist for mappings specified with source-to-target tuple-generating dependencies (st-tgds), and it has been futile to search for a meaningful mapping language that is closed under any of these notions of inverse. In this paper, we develop a framework for the inversion of schema mappings that fulfills all of the above requirements. It is based on the notion of ${\mathcal{C}}$ -maximum recovery, for a query language ${\mathcal{C}}$ , a notion designed to generate inverse mappings that recover back only the information that can be retrieved with queries in ${\mathcal{C}}$ . By focusing on the language of conjunctive queries (CQ), we are able to find a mapping language that contains the class of st-tgds, is closed under CQ-maximum recovery, and for which the chase procedure can be used to exchange data efficiently. Furthermore, we show that our choices of inverse notion and mapping language are optimal, in the sense that choosing a more expressive inverse operator or mapping language causes the loss of these properties.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0273-y">Consistency and repair for XML write-access control policies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0273-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Loreto+Bravo%22">Loreto Bravo</a></li><li><a href="http://link.springer.com/search?facet-author=%22James+Cheney%22">James Cheney</a></li><li><a href="http://link.springer.com/search?facet-author=%22Irini+Fundulaki%22">Irini Fundulaki</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ricardo+Segovia%22">Ricardo Segovia</a></li></ol>
          <input type="checkbox" id="41984"/>
          <label for="41984">Abstract</label>
          <div>XML access control policies involving updates may contain security flaws, here called inconsistencies, in which a forbidden operation may be simulated by performing a sequence of allowed operations. This article investigates the problem of deciding whether a policy is consistent, and if not, how its inconsistencies can be repaired. We consider total and partial policies expressed in terms of annotated schemas defining which operations are allowed or denied for the XML trees that are instances of the schema. We show that consistency is decidable in PTIME for such policies and that consistent partial policies can be extended to unique least-privilege consistent total policies. We also consider repair problems based on deleting privileges to restore consistency, show that finding minimal repairs is NP-complete, and give heuristics for finding repairs. Finally, we experimentally evaluate these algorithms in comparison with an exact approach based on answer-set programming.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0274-x">The exact distance to destination in undirected world</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0274-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Lijun+Chang%22">Lijun Chang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lu+Qin%22">Lu Qin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hong+Cheng%22">Hong Cheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Miao+Qiao%22">Miao Qiao</a></li></ol>
          <input type="checkbox" id="48484"/>
          <label for="48484">Abstract</label>
          <div>Shortest distance queries are essential not only in graph analysis and graph mining tasks but also in database applications, when a large graph needs to be dealt with. Such shortest distance queries are frequently issued by end-users or requested as a subroutine in real applications. For intensive queries on large graphs, it is impractical to compute shortest distances on-line from scratch, and impractical to materialize all-pairs shortest distances. In the literature, 2-hop distance labeling is proposed to index the all-pairs shortest distances. It assigns distance labels to vertices in a large graph in a pre-computing step off-line and then answers shortest distance queries on-line by making use of such distance labels, which avoids exhaustively traversing the large graph when answering queries. However, the existing algorithms to generate 2-hop distance labels are not scalable to large graphs. Finding an optimal 2-hop distance labeling is NP-hard, and heuristic algorithms may generate large size distance labels while still needing to pre-compute all-pairs shortest paths. In this paper, we propose a multi-hop distance labeling approach, which generates a subset of the 2-hop distance labels as index off-line. We can compute the multi-hop distance labels efficiently by avoiding pre-computing all-pairs shortest paths. In addition, our multi-hop distance labeling is small in size to be stored. To answer a shortest distance query between two vertices, we first generate the query-specific small set of 2-hop distance labels for the two vertices based on our multi-hop distance labels stored and compute the shortest distance between the two vertices based on the 2-hop distance labels generated on-line. We conducted extensive performance studies on large real graphs and confirmed the efficiency of our multi-hop distance labeling scheme.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0275-9">ANDES: efficient evaluation of NOT-twig queries in relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0275-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kheng+Hong+Soh%22">Kheng Hong Soh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ba+Quan+Truong%22">Ba Quan Truong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sourav+S.+Bhowmick%22">Sourav S. Bhowmick</a></li></ol>
          <input type="checkbox" id="85578"/>
          <label for="85578">Abstract</label>
          <div>Despite a large body of work on XPath query processing in relational environment, systematic study of queries containing not-predicates have received little attention in the literature. Particularly, several xml supports of industrial-strength commercial rdbms fail to efficiently evaluate such queries. In this paper, we present an efficient and novel strategy to evaluate not -twig queries in a tree-unaware relational environment. not -twig queries are XPath queries with ancestor–descendant and parent–child axis and contain one or more not-predicates. We propose a novel Dewey-based encoding scheme called Andes (ANcestor Dewey-based Encoding Scheme), which enables us to efficiently filter out elements satisfying a not-predicate by comparing their ancestor group identifiers. In this approach, a set of elements under the same common ancestor at a specific level in the xml tree is assigned same ancestor group identifier. Based on this scheme, we propose a novel sql translation algorithm for not-twig query evaluation. Experiments carried out confirm that our proposed approach built on top of an off-the-shelf commercial rdbms significantly outperforms state-of-the-art relational and native approaches. We also explore the query plans selected by a commercial relational optimizer to evaluate our translated queries in different input cardinality. Such exploration further validates the performance benefits of Andes.</div>
        </li></ul>
        </li><li>
          <h2>Issue 5 (October 2012)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0291-9">Special section on large-scale analytics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0291-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wolfgang+Lehner%22">Wolfgang Lehner</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Franklin%22">Michael J. Franklin</a></li></ol>
          <input type="checkbox" id="53068"/>
          <label for="53068">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0279-5">On the optimization of schedules for MapReduce workloads in the presence of shared scans</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0279-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Joel+Wolf%22">Joel Wolf</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andrey+Balmin%22">Andrey Balmin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Deepak+Rajan%22">Deepak Rajan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kirsten+Hildrum%22">Kirsten Hildrum</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rohit+Khandekar%22">Rohit Khandekar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sujay+Parekh%22">Sujay Parekh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kun-Lung+Wu%22">Kun-Lung Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rares+Vernica%22">Rares Vernica</a></li></ol>
          <input type="checkbox" id="43419"/>
          <label for="43419">Abstract</label>
          <div>We consider MapReduce clusters designed to support multiple concurrent jobs, concentrating on environments in which the number of distinct datasets is modest relative to the number of jobs. In such scenarios, many individual datasets are likely to be scanned concurrently by multiple Map phase jobs. As has been noticed previously, this scenario provides an opportunity for Map phase jobs to cooperate, sharing the scans of these datasets, and thus reducing the costs of such scans. Our paper has three main contributions over previous work. First, we present a novel and highly general method for sharing scans and thus amortizing their costs. This concept, which we call cyclic piggybacking, has a number of advantages over the more traditional batching scheme described in the literature. Second, we notice that the various subjobs generated in this manner can be assumed in an optimal schedule to respect a natural chain precedence ordering. Third, we describe a significant but natural generalization of the recently introduced FLEX scheduler for optimizing schedules within the context of this cyclic piggybacking paradigm, which can be tailored to a variety of cost metrics. Such cost metrics include average response time, average stretch, and any minimax-type metric—a total of 11 separate and standard metrics in all. Moreover, most of this carries over in the more general case of overlapping rather than identical datasets as well, employing what we will call semi-shared scans. In such scenarios, chain precedence is replaced by arbitrary precedence, but we can still handle 8 of the original 11 metrics. The overall approach, including both cyclic piggybacking and the FLEX scheduling generalization, is called CIRCUMFLEX. We describe some practical implementation strategies. And we evaluate the performance of CIRCUMFLEX via a variety of simulation and real benchmark experiments.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0280-z">SCOPE: parallel databases meet MapReduce</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0280-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jingren+Zhou%22">Jingren Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nicolas+Bruno%22">Nicolas Bruno</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ming-Chuan+Wu%22">Ming-Chuan Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Per-Ake+Larson%22">Per-Ake Larson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ronnie+Chaiken%22">Ronnie Chaiken</a></li><li><a href="http://link.springer.com/search?facet-author=%22Darren+Shakib%22">Darren Shakib</a></li></ol>
          <input type="checkbox" id="82945"/>
          <label for="82945">Abstract</label>
          <div>Companies providing cloud-scale data services have increasing needs to store and analyze massive data sets, such as search logs, click streams, and web graph data. For cost and performance reasons, processing is typically done on large clusters of tens of thousands of commodity machines. Such massive data analysis on large clusters presents new opportunities and challenges for developing a highly scalable and efficient distributed computation system that is easy to program and supports complex system optimization to maximize performance and reliability. In this paper, we describe a distributed computation system, Structured Computations Optimized for Parallel Execution (Scope), targeted for this type of massive data analysis. Scope combines benefits from both traditional parallel databases and MapReduce execution engines to allow easy programmability and deliver massive scalability and high performance through advanced optimization. Similar to parallel databases, the system has a SQL-like declarative scripting language with no explicit parallelism, while being amenable to efficient parallel execution on large clusters. An optimizer is responsible for converting scripts into efficient execution plans for the distributed computation engine. A physical execution plan consists of a directed acyclic graph of vertices. Execution of the plan is orchestrated by a job manager that schedules execution on available machines and provides fault tolerance and recovery, much like MapReduce systems. Scope is being used daily for a variety of data analysis and data mining applications over tens of thousands of machines at Microsoft, powering Bing, and other online services.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0283-9">gbase: an efficient analysis platform for large graphs</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0283-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22U+Kang%22">U Kang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hanghang+Tong%22">Hanghang Tong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jimeng+Sun%22">Jimeng Sun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ching-Yung+Lin%22">Ching-Yung Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christos+Faloutsos%22">Christos Faloutsos</a></li></ol>
          <input type="checkbox" id="54279"/>
          <label for="54279">Abstract</label>
          <div>Graphs appear in numerous applications including cyber security, the Internet, social networks, protein networks, recommendation systems, citation networks, and many more. Graphs with millions or even billions of nodes and edges are common-place. How to store such large graphs efficiently? What are the core operations/queries on those graph? How to answer the graph queries quickly? We propose Gbase, an efficient analysis platform for large graphs. The key novelties lie in (1) our storage and compression scheme for a parallel, distributed settings and (2) the carefully chosen graph operations and their efficient implementations. We designed and implemented an instance of Gbase using Mapreduce/Hadoop. Gbase provides a parallel indexing mechanism for graph operations that both saves storage space, as well as accelerates query responses. We run numerous experiments on real and synthetic graphs, spanning billions of nodes and edges, and we show that our proposed Gbase is indeed fast, scalable, and nimble, with significant savings in space and time.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0261-7">CLARO: modeling and processing uncertain data streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0261-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Thanh+T.+L.+Tran%22">Thanh T. L. Tran</a></li><li><a href="http://link.springer.com/search?facet-author=%22Liping+Peng%22">Liping Peng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yanlei+Diao%22">Yanlei Diao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andrew+McGregor%22">Andrew McGregor</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anna+Liu%22">Anna Liu</a></li></ol>
          <input type="checkbox" id="94307"/>
          <label for="94307">Abstract</label>
          <div>Uncertain data streams, where data are incomplete and imprecise, have been observed in many environments. Feeding such data streams to existing stream systems produces results of unknown quality, which is of paramount concern to monitoring applications. In this paper, we present the claro system that supports stream processing for uncertain data naturally captured using continuous random variables. claro employs a unique data model that is flexible and allows efficient computation. Built on this model, we develop evaluation techniques for relational operators by exploring statistical theory and approximation. We also consider query planning for complex queries given an accuracy requirement. Evaluation results show that our techniques can achieve high performance while satisfying accuracy requirements and outperform state-of-the-art sampling methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0263-0">Measuring structural similarity of semistructured data based on information-theoretic approaches</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0263-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sven+Helmer%22">Sven Helmer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nikolaus+Augsten%22">Nikolaus Augsten</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+B%C3%B6hlen%22">Michael Böhlen</a></li></ol>
          <input type="checkbox" id="18001"/>
          <label for="18001">Abstract</label>
          <div>We propose and experimentally evaluate different approaches for measuring the structural similarity of semistructured documents based on information-theoretic concepts. Common to all approaches is a two-step procedure: first, we extract and linearize the structural information from documents, and then, we use similarity measures that are based on, respectively, Kolmogorov complexity and Shannon entropy to determine the distance between the documents. Compared to other approaches, we are able to achieve a linear run-time complexity and demonstrate in an experimental evaluation that the results of our technique in terms of clustering quality are on a par with or even better than those of other, slower approaches.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0265-y">Efficiently processing snapshot and continuous reverse k nearest neighbors queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0265-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Muhammad+Aamir+Cheema%22">Muhammad Aamir Cheema</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wenjie+Zhang%22">Wenjie Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ying+Zhang%22">Ying Zhang</a></li></ol>
          <input type="checkbox" id="89924"/>
          <label for="89924">Abstract</label>
          <div>Given a set of objects and a query q, a point p is called the reverse k nearest neighbor (RkNN) of q if q is one of the k closest objects of p. In this paper, we introduce the concept of influence zone that is the area such that every point inside this area is the RkNN of q and every point outside this area is not the RkNN. The influence zone has several applications in location-based services, marketing and decision support systems. It can also be used to efficiently process RkNN queries. First, we present efficient algorithm to compute the influence zone. Then, based on the influence zone, we present efficient algorithms to process RkNN queries that significantly outperform existing best-known techniques for both the snapshot and continuous RkNN queries. We also present a detailed theoretical analysis to analyze the area of the influence zone and IO costs of our RkNN processing algorithms. Our experiments demonstrate the accuracy of our theoretical analysis. This paper is an extended version of our previous work (Cheema et al. in Proceedings of ICDE, pp. 577–588, 2011). We make the following new contributions in this extended version: (1) we conduct a rigorous complexity analysis and show that the complexity of one of our proposed algorithms in Cheema et al. (Proceedings of ICDE, pp. 577–588, 2011) can be reduced from O(m 2) to O( km) where m > k is the number of objects used to compute the influence zone, (2) we show that our techniques can be applied to dimensionality higher than two, and (3) we present efficient techniques to handle data updates.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0266-x">Spatial query processing for fuzzy objects</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0266-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kai+Zheng%22">Kai Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pui+Cheong+Fung%22">Pui Cheong Fung</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kexin+Xie%22">Kexin Xie</a></li></ol>
          <input type="checkbox" id="39963"/>
          <label for="39963">Abstract</label>
          <div>Range and nearest neighbor queries are the most common types of spatial queries, which have been investigated extensively in the last decades due to its broad range of applications. In this paper, we study this problem in the context of fuzzy objects that have indeterministic boundaries. Fuzzy objects play an important role in many areas, such as biomedical image databases and GIS communities. Existing research on fuzzy objects mainly focuses on modeling basic fuzzy object types and operations, leaving the processing of more advanced queries largely untouched. In this paper, we propose two new kinds of spatial queries for fuzzy objects, namely single threshold query and continuous threshold query, to determine the query results which qualify at a certain probability threshold and within a probability interval, respectively. For efficient single threshold query processing, we optimize the classical R-tree-based search algorithm by deriving more accurate approximations for the distance function between fuzzy objects and the query object. To enhance the performance of continuous threshold queries, effective pruning rules are developed to reduce the search space and speed up the candidate refinement process. The efficiency of our proposed algorithms as well as the optimization techniques is verified with an extensive set of experiments using both synthetic and real datasets.</div>
        </li></ul>
        </li><li>
          <h2>Issue 4 (August 2012)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0252-8">Trie-join: a trie-based method for efficient string similarity joins</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0252-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jianhua+Feng%22">Jianhua Feng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiannan+Wang%22">Jiannan Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Guoliang+Li%22">Guoliang Li</a></li></ol>
          <input type="checkbox" id="57492"/>
          <label for="57492">Abstract</label>
          <div>A string similarity join finds similar pairs between two collections of strings. Many applications, e.g., data integration and cleaning, can significantly benefit from an efficient string-similarity-join algorithm. In this paper, we study string similarity joins with edit-distance constraints. Existing methods usually employ a filter-and-refine framework and suffer from the following limitations: (1) They are inefficient for the data sets with short strings (the average string length is not larger than 30); (2) They involve large indexes; (3) They are expensive to support dynamic update of data sets. To address these problems, we propose a novel method called trie-join, which can generate results efficiently with small indexes. We use a trie structure to index the strings and utilize the trie structure to efficiently find similar string pairs based on subtrie pruning. We devise efficient trie-join algorithms and pruning techniques to achieve high performance. Our method can be easily extended to support dynamic update of data sets efficiently. We conducted extensive experiments on four real data sets. Experimental results show that our algorithms outperform state-of-the-art methods by an order of magnitude on the data sets with short strings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0254-6">Windowed pq-grams for approximate joins of data-centric XML</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0254-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nikolaus+Augsten%22">Nikolaus Augsten</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+B%C3%B6hlen%22">Michael Böhlen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Curtis+Dyreson%22">Curtis Dyreson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Johann+Gamper%22">Johann Gamper</a></li></ol>
          <input type="checkbox" id="62710"/>
          <label for="62710">Abstract</label>
          <div>In data integration applications, a join matches elements that are common to two data sources. Since elements are represented slightly different in each source, an approximate join must be used to do the matching. For XML data, most existing approximate join strategies are based on some ordered tree matching technique, such as the tree edit distance. In data-centric XML, however, the sibling order is irrelevant, and two elements should match even if their subelement order varies. Thus, approximate joins for data-centric XML must leverage unordered tree matching techniques. This is computationally hard since the algorithms cannot rely on a predefined sibling order. In this paper, we give a solution for approximate joins based on unordered tree matching. The core of our solution are windowed pq-grams which are small subtrees of a specific shape. We develop an efficient technique to generate windowed pq-grams in a three-step process: sort the tree, extend the sorted tree with dummy nodes, and decompose the extended tree into windowed pq-grams. The windowed pq-grams distance between two trees is the number of pq-grams that are in one tree decomposition only. We show that our distance is a pseudo-metric and empirically demonstrate that it effectively approximates the unordered tree edit distance. The approximate join using windowed pq-grams can be efficiently implemented as an equality join on strings, which avoids the costly computation of the distance between every pair of input trees. Experiments with synthetic and real world data confirm the analytic results and show the effectiveness and efficiency of our technique.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0255-5">Efficient subsequence matching over large video databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0255-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xiangmin+Zhou%22">Xiangmin Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Athman+Bouguettaya%22">Athman Bouguettaya</a></li></ol>
          <input type="checkbox" id="77993"/>
          <label for="77993">Abstract</label>
          <div>Video similarity matching has broad applications such as copyright detection, news tracking and commercial monitoring, etc. Among these applications, one typical task is to detect the local similarity between two videos without the knowledge on positions and lengths of each matched subclip pair. However, most studies so far on video detection investigate the global similarity between two short clips using a pre-defined distance function. Although there are a few works on video subsequence detection, all these proposals fail to provide an effective query processing mechanism. In this paper, we first generalize the problem of video similarity matching. Then, a novel solution called consistent keyframe matching (CKM) is proposed to solve the problem of subsequence matching based on video segmentation. CKM is designed with two goals: (1) good scalability in terms of the query sequence length and the size of video database and (2) fast video subsequence matching in terms of processing time. Good scalability is achieved by employing a batch query paradigm, where keyframes sharing the same query space are summarized and ordered. As such, the redundancy of data access is eliminated, leading to much faster video query processing. Fast subsequence matching is achieved by comparing the keyframes of different video sequences. Specifically, a keyframe matching graph is first constructed and then divided into matched candidate subgraphs. We have evaluated our proposed approach over a very large real video database. Extensive experiments demonstrate the effectiveness and efficiency of our approach.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0256-4">GRAIL: a scalable index for reachability queries in very large graphs</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0256-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hilmi+Y%C4%B1ld%C4%B1r%C4%B1m%22">Hilmi Yıldırım</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vineet+Chaoji%22">Vineet Chaoji</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohammed+J.+Zaki%22">Mohammed J. Zaki</a></li></ol>
          <input type="checkbox" id="62172"/>
          <label for="62172">Abstract</label>
          <div>Given a large directed graph, rapidly answering reachability queries between source and target nodes is an important problem. Existing methods for reachability tradeoff indexing time and space versus query time performance. However, the biggest limitation of existing methods is that they do not scale to very large real-world graphs. We present a simple yet scalable reachability index, called GRAIL, that is based on the idea of randomized interval labeling and that can effectively handle very large graphs. Based on an extensive set of experiments, we show that while more sophisticated methods work better on small graphs, GRAIL is the only index that can scale to millions of nodes and edges. GRAIL has linear indexing time and space, and the query time ranges from constant time to being linear in the graph order and size. Our reference C++ implementations are open source and available for download at http://www.code.google.com/p/grail/.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0258-2">Efficient and effective similarity search over probabilistic data based on Earth Mover’s Distance</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0258-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jia+Xu%22">Jia Xu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhenjie+Zhang%22">Zhenjie Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anthony+K.+H.+Tung%22">Anthony K. H. Tung</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ge+Yu%22">Ge Yu</a></li></ol>
          <input type="checkbox" id="47275"/>
          <label for="47275">Abstract</label>
          <div>Advances in geographical tracking, multimedia processing, information extraction, and sensor networks have created a deluge of probabilistic data. While similarity search is an important tool to support the manipulation of probabilistic data, it raises new challenges to traditional relational databases. The problem stems from the limited effectiveness of the distance metrics employed by existing database systems. On the other hand, several more complicated distance operators have proven their values for better distinguishing ability in specific probabilistic domains. In this paper, we discuss the similarity search problem with respect to Earth Mover’s Distance (EMD). EMD is the most successful distance metric for probability distribution comparison but is an expensive operator as it has cubic time complexity. We present a new database indexing approach to answer EMD-based similarity queries, including range queries and k-nearest neighbor queries on probabilistic data. Our solution utilizes primal-dual theory from linear programming and employs a group of B + trees for effective candidate pruning. We also apply our filtering technique to the processing of continuous similarity queries, especially with applications to frame copy detection in real-time videos. Extensive experiments show that our proposals dramatically improve the usefulness and scalability of probabilistic data management.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0259-1">A highly optimized algorithm for continuous intersection join queries over moving objects</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0259-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rui+Zhang%22">Rui Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianzhong+Qi%22">Jianzhong Qi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Lin%22">Dan Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wei+Wang%22">Wei Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raymond+Chi-Wing+Wong%22">Raymond Chi-Wing Wong</a></li></ol>
          <input type="checkbox" id="94698"/>
          <label for="94698">Abstract</label>
          <div>Given two sets of moving objects with nonzero extents, the continuous intersection join query reports every pair of intersecting objects, one from each of the two moving object sets, for every timestamp. This type of queries is important for a number of applications, e.g., in the multi-billion dollar computer game industry, massively multiplayer online games like World of Warcraft need to monitor the intersection among players’ attack ranges and render players’ interaction in real time. The computational cost of a straightforward algorithm or an algorithm adapted from another query type is prohibitive, and answering the query in real time poses a great challenge. Those algorithms compute the query answer for either too long or too short a time interval, which results in either a very large computation cost per answer update or too frequent answer updates, respectively. This observation motivates us to optimize the query processing in the time dimension. In this study, we achieve this optimization by introducing the new concept of time-constrained (TC) processing. Further, TC processing enables a set of effective improvement techniques on traditional intersection join algorithms. Finally, we provide a method to find the optimal value for an important parameter required in our technique, the maximum update interval. As a result, we achieve a highly optimized algorithm for processing continuous intersection join queries on moving objects. With a thorough experimental study, we show that our algorithm outperforms the best adapted existing solution by several orders of magnitude. We also validate the accuracy of our cost model and its effectiveness in optimizing the performance.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (June 2012)</h2>
          <ul><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0242-x">Real-time creation of bitmap indexes on streaming network data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0242-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Francesco+Fusco%22">Francesco Fusco</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michail+Vlachos%22">Michail Vlachos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marc+Ph.+Stoecklin%22">Marc Ph. Stoecklin</a></li></ol>
          <input type="checkbox" id="4808"/>
          <label for="4808">Abstract</label>
          <div>High-speed archival and indexing solutions of streaming traffic are growing in importance for applications such as monitoring, forensic analysis, and auditing. Many large institutions require fast solutions to support expedient analysis of historical network data, particularly in case of security breaches. However, “turning back the clock” is not a trivial task. The first major challenge is that such a technology needs to support data archiving under extremely high-speed insertion rates. Moreover, the archives created have to be stored in a compressed format that is still amenable to indexing and search. The above requirements make general-purpose databases unsuitable for this task and dedicated solutions are required. This work describes a solution for high-speed archival storage, indexing, and data querying on network flow information. We make the two following important contributions: (a) we propose a novel compressed bitmap index approach that significantly reduces both CPU load and disk consumption and, (b) we introduce an online stream reordering mechanism that further reduces space requirements and improves the time for data retrieval. The reordering methodology is based on the principles of locality-sensitive hashing (LSH) and also of interest for other bitmap creation techniques. Because of the synergy of these two components, our solution can sustain data insertion rates that reach 500,000–1 million records per second. To put these numbers into perspective, typical commercial network flow solutions can currently process 20,000–60,000 flows per second. In addition, our system offers interactive query response times that enable administrators to perform complex analysis tasks on the fly. Our technique is directly amenable to parallel execution, allowing its application in domains that are challenged by large volumes of historical measurement data, such as network auditing, traffic behavior analysis, and large-scale data visualization in service provider networks.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0243-9">Parsimonious temporal aggregation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0243-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Juozas+Gordevi%C4%8Dius%22">Juozas Gordevičius</a></li><li><a href="http://link.springer.com/search?facet-author=%22Johann+Gamper%22">Johann Gamper</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+B%C3%B6hlen%22">Michael Böhlen</a></li></ol>
          <input type="checkbox" id="95983"/>
          <label for="95983">Abstract</label>
          <div>Temporal aggregation is an important operation in temporal databases, and different variants thereof have been proposed. In this paper, we introduce a novel temporal aggregation operator, termed parsimonious temporal aggregation (PTA), that overcomes major limitations of existing approaches. PTA takes the result of instant temporal aggregation (ITA) of size n, which might be up to twice as large as the argument relation, and merges similar tuples until a given error ( ${\epsilon}$ ) or size (c) bound is reached. The new operator is data-adaptive and allows the user to control the trade-off between the result size and the error introduced by merging. For the precise evaluation of PTA queries, we propose two dynamic programming–based algorithms for size- and error-bounded queries, respectively, with a worst-case complexity that is quadratic in n. We present two optimizations that take advantage of temporal gaps and different aggregation groups and achieve a linear runtime in experiments with real-world data. For the quick computation of an approximate PTA answer, we propose an efficient greedy merging strategy with a precision that is upper bounded by O(log n). We present two algorithms that implement this strategy and begin to merge as ITA tuples are produced. They require O(n log (c + β)) time and O(c + β) space, where β is the size of a read-ahead buffer and is typically very small. An empirical evaluation on real-world and synthetic data shows that PTA considerably reduces the size of the aggregation result, yet introducing only small errors. The greedy algorithms are scalable for large data sets and introduce less error than other approximation techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0245-7">Secure multidimensional range queries over outsourced data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0245-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bijit+Hore%22">Bijit Hore</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sharad+Mehrotra%22">Sharad Mehrotra</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mustafa+Canim%22">Mustafa Canim</a></li><li><a href="http://link.springer.com/search?facet-author=%22Murat+Kantarcioglu%22">Murat Kantarcioglu</a></li></ol>
          <input type="checkbox" id="92560"/>
          <label for="92560">Abstract</label>
          <div>In this paper, we study the problem of supporting multidimensional range queries on encrypted data. The problem is motivated by secure data outsourcing applications where a client may store his/her data on a remote server in encrypted form and want to execute queries using server’s computational capabilities. The solution approach is to compute a secure indexing tag of the data by applying bucketization (a generic form of data partitioning) which prevents the server from learning exact values but still allows it to check if a record satisfies the query predicate. Queries are evaluated in an approximate manner where the returned set of records may contain some false positives. These records then need to be weeded out by the client which comprises the computational overhead of our scheme. We develop a bucketization procedure for answering multidimensional range queries on multidimensional data. For a given bucketization scheme, we derive cost and disclosure-risk metrics that estimate client’s computational overhead and disclosure risk respectively. Given a multidimensional dataset, its bucketization is posed as an optimization problem where the goal is to minimize the risk of disclosure while keeping query cost (client’s computational overhead) below a certain user-specified threshold value. We provide a tunable data bucketization algorithm that allows the data owner to control the trade-off between disclosure risk and cost. We also study the trade-off characteristics through an extensive set of experiments on real and synthetic data.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0246-6">A survey of skyline processing in highly distributed environments</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0246-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Katja+Hose%22">Katja Hose</a></li><li><a href="http://link.springer.com/search?facet-author=%22Akrivi+Vlachou%22">Akrivi Vlachou</a></li></ol>
          <input type="checkbox" id="36455"/>
          <label for="36455">Abstract</label>
          <div>During the last decades, data management and storage have become increasingly distributed. Advanced query operators, such as skyline queries, are necessary in order to help users to handle the huge amount of available data by identifying a set of interesting data objects. Skyline query processing in highly distributed environments poses inherent challenges and demands and requires non-traditional techniques due to the distribution of content and the lack of global knowledge. This paper surveys this interesting and still evolving research area, so that readers can easily obtain an overview of the state-of-the-art. We outline the objectives and the main principles that any distributed skyline approach has to fulfill, leading to useful guidelines for developing algorithms for distributed skyline processing. We review in detail existing approaches that are applicable for highly distributed environments, clarify the assumptions of each approach, and provide a comparative performance analysis. Moreover, we study the skyline variants each approach supports. Our analysis leads to a taxonomy of existing approaches. Finally, we present interesting research topics on distributed skyline computation that have not yet been explored.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0248-4">Efficient management of uncertainty in XML schema matching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0248-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jian+Gong%22">Jian Gong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Reynold+Cheng%22">Reynold Cheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+W.+Cheung%22">David W. Cheung</a></li></ol>
          <input type="checkbox" id="12609"/>
          <label for="12609">Abstract</label>
          <div>Despite advances in machine learning technologies a schema matching result between two database schemas (e.g., those derived from COMA++) is likely to be imprecise. In particular, numerous instances of “possible mappings” between the schemas may be derived from the matching result. In this paper, we study problems related to managing possible mappings between two heterogeneous XML schemas. First, we study how to efficiently generate possible mappings for a given schema matching task. While this problem can be solved by existing algorithms, we show how to improve the performance of the solution by using a divide-and-conquer approach. Second, storing and querying a large set of possible mappings can incur large storage and evaluation overhead. For XML schemas, we observe that their possible mappings often exhibit a high degree of overlap. We hence propose a novel data structure, called the block tree, to capture the commonalities among possible mappings. The block tree is useful for representing the possible mappings in a compact manner and can be efficiently generated. Moreover, it facilitates the evaluation of a probabilistic twig query (PTQ), which returns the non-zero probability that a fragment of an XML document matches a given query. For users who are interested only in answers with k-highest probabilities, we also propose the top-k PTQ and present an efficient solution for it. An extensive evaluation on real-world data sets shows that our approaches significantly improve the efficiency of generating, storing, and querying possible mappings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0251-9">Sort-sharing-aware query processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0251-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yu+Cao%22">Yu Cao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ramadhana+Bramandia%22">Ramadhana Bramandia</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chee-Yong+Chan%22">Chee-Yong Chan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li></ol>
          <input type="checkbox" id="94283"/>
          <label for="94283">Abstract</label>
          <div>Many database applications require sorting a table (or relation) over multiple sort orders. Some examples include creation of multiple indices on a relation, generation of multiple reports from a table, evaluation of a complex query that involves multiple instances of a relation, and batch processing of a set of queries. In this paper, we study how to optimize multiple sortings of a table. We investigate the correlation between sort orders and exploit sort-sharing techniques of reusing the (partial) work done to sort a table on a particular order for another order. Specifically, we introduce a novel and powerful evaluation technique, called cooperative sorting, that enables sort sharing between seemingly non-related sort orders. Subsequently, given a specific set of sort orders, we determine the best combination of various sort-sharing techniques so as to minimize the total processing cost. We also develop techniques to make a traditional query optimizer extensible so that it will not miss the truly cheapest execution plan with the sort-sharing (post-) optimization turned on. We demonstrate the efficiency of our ideas with a prototype implementation in PostgreSQL and evaluate the performance using both TPC-DS benchmark and synthetic data. Our experimental results show significant performance improvement over the traditional evaluation scheme.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 2012)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0267-9">Special issue: best papers of VLDB 2010</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0267-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Paolo+Atzeni%22">Paolo Atzeni</a></li><li><a href="http://link.springer.com/search?facet-author=%22Elisa+Bertino%22">Elisa Bertino</a></li><li><a href="http://link.springer.com/search?facet-author=%22Masaru+Kitsuregawa%22">Masaru Kitsuregawa</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li></ol>
          <input type="checkbox" id="59012"/>
          <label for="59012">Abstract</label>
          <div></div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0269-7">The HaLoop approach to large-scale iterative data analysis</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0269-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yingyi+Bu%22">Yingyi Bu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bill+Howe%22">Bill Howe</a></li><li><a href="http://link.springer.com/search?facet-author=%22Magdalena+Balazinska%22">Magdalena Balazinska</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+D.+Ernst%22">Michael D. Ernst</a></li></ol>
          <input type="checkbox" id="83195"/>
          <label for="83195">Abstract</label>
          <div>The growing demand for large-scale data mining and data analysis applications has led both industry and academia to design new types of highly scalable data-intensive computing platforms. MapReduce has enjoyed particular success. However, MapReduce lacks built-in support for iterative programs, which arise naturally in many applications including data mining, web ranking, graph analysis, and model fitting. This paper (This is an extended version of the VLDB 2010 paper “HaLoop: Efficient Iterative Data Processing on Large Clusters” PVLDB 3(1):285–296, 2010.) presents HaLoop, a modified version of the Hadoop MapReduce framework, that is designed to serve these applications. HaLoop allows iterative applications to be assembled from existing Hadoop programs without modification, and significantly improves their efficiency by providing inter-iteration caching mechanisms and a loop-aware scheduler to exploit these caches. HaLoop retains the fault-tolerance properties of MapReduce through automatic cache recovery and task re-execution. We evaluated HaLoop on a variety of real applications and real datasets. Compared with Hadoop, on average, HaLoop improved runtimes by a factor of 1.85 and shuffled only 4 % as much data between mappers and reducers in the applications that we tested.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-012-0264-z">MapMerge: correlating independent schema mappings</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-012-0264-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bogdan+Alexe%22">Bogdan Alexe</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mauricio+Hern%C3%A1ndez%22">Mauricio Hernández</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lucian+Popa%22">Lucian Popa</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wang-Chiew+Tan%22">Wang-Chiew Tan</a></li></ol>
          <input type="checkbox" id="3620"/>
          <label for="3620">Abstract</label>
          <div>One of the main steps toward integration or exchange of data is to design the mappings that describe the (often complex) relationships between the source schemas or formats and the desired target schema. In this paper, we introduce a new operator, called MapMerge, that can be used to correlate multiple, independently designed schema mappings of smaller scope into larger schema mappings. This allows a more modular construction of complex mappings from various types of smaller mappings such as schema correspondences produced by a schema matcher or pre-existing mappings that were designed by either a human user or via mapping tools. In particular, the new operator also enables a new “divide-and-merge” paradigm for mapping creation, where the design is divided (on purpose) into smaller components that are easier to create and understand and where MapMerge is used to automatically generate a meaningful overall mapping. We describe our MapMerge algorithm and demonstrate the feasibility of our implementation on several real and synthetic mapping scenarios. In our experiments, we make use of a novel similarity measure between two database instances with different schemas that quantifies the preservation of data associations. We show experimentally that MapMerge improves the quality of the schema mappings, by significantly increasing the similarity between the input source instance and the generated target instance. Finally, we provide a new algorithm that combines MapMerge with schema mapping composition to correlate flows of schema mappings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0253-7">Towards certain fixes with editing rules and master data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0253-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wenfei+Fan%22">Wenfei Fan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianzhong+Li%22">Jianzhong Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shuai+Ma%22">Shuai Ma</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nan+Tang%22">Nan Tang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wenyuan+Yu%22">Wenyuan Yu</a></li></ol>
          <input type="checkbox" id="80957"/>
          <label for="80957">Abstract</label>
          <div>A variety of integrity constraints have been studied for data cleaning. While these constraints can detect the presence of errors, they fall short of guiding us to correct the errors. Indeed, data repairing based on these constraints may not find certain fixes that are guaranteed correct, and worse still, may even introduce new errors when attempting to repair the data. We propose a method for finding certain fixes, based on master data, a notion of certain regions, and a class of editing rules. A certain region is a set of attributes that are assured correct by the users. Given a certain region and master data, editing rules tell us what attributes to fix and how to update them. We show how the method can be used in data monitoring and enrichment. We also develop techniques for reasoning about editing rules, to decide whether they lead to a unique fix and whether they are able to fix all the attributes in a tuple, relative to master data and a certain region. Furthermore, we present a framework and an algorithm to find certain fixes, by interacting with the users to ensure that one of the certain regions is correct. We experimentally verify the effectiveness and scalability of the algorithm.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0260-8">Scalability of write-ahead logging on multicore and multisocket hardware</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0260-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ryan+Johnson%22">Ryan Johnson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ippokratis+Pandis%22">Ippokratis Pandis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Radu+Stoica%22">Radu Stoica</a></li><li><a href="http://link.springer.com/search?facet-author=%22Manos+Athanassoulis%22">Manos Athanassoulis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anastasia+Ailamaki%22">Anastasia Ailamaki</a></li></ol>
          <input type="checkbox" id="73018"/>
          <label for="73018">Abstract</label>
          <div>The shift to multi-core and multi-socket hardware brings new challenges to database systems, as the software parallelism determines performance. Even though database systems traditionally accommodate simultaneous requests, a multitude of synchronization barriers serialize execution. Write-ahead logging is a fundamental, omnipresent component in ARIES-style concurrency and recovery, and one of the most important yet-to-be addressed potential bottlenecks, especially in OLTP workloads making frequent small changes to data. In this paper, we identify four logging-related impediments to database system scalability. Each issue challenges different level in the software architecture: (a) the high volume of small-sized I/O requests may saturate the disk, (b) transactions hold locks while waiting for the log flush, (c) extensive context switching overwhelms the OS scheduler with threads executing log I/Os, and (d) contention appears as transactions serialize accesses to in-memory log data structures. We demonstrate these problems and address them with techniques that, when combined, comprise a holistic, scalable approach to logging. Our solution achieves a 20–69% speedup over a modern database system when running log-intensive workloads, such as the TPC-B and TATP benchmarks, in a single-socket multiprocessor server. Moreover, it achieves log insert throughput over 2.2 GB/s for small log records on the single-socket server, roughly 20 times higher than the traditional way of accessing the log using a single mutex. Furthermore, we investigate techniques on scaling the performance of logging to multi-socket servers. We present a set of optimizations which partly ameliorate the latency penalty that comes with multi-socket hardware, and then we investigate the feasibility of applying a distributed log buffer design at the socket level.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0257-3">An adaptive updating protocol for reducing moving object database workload</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0257-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Su+Chen%22">Su Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhenjie+Zhang%22">Zhenjie Zhang</a></li></ol>
          <input type="checkbox" id="90864"/>
          <label for="90864">Abstract</label>
          <div>In the last decade, spatio-temporal database research focuses on the design of effective and efficient indexing structures in support of location-based queries such as predictive range queries and nearest neighbor queries. While a variety of indexing techniques have been proposed to accelerate the processing of updates and queries, not much attention has been paid to the updating protocol, which is another important factor affecting the system performance. In this paper, we propose a generic and adaptive updating protocol for moving object databases with less number of updates between objects and the database server, thereby reducing the overall workload of the system. In contrast to the approach adopted by most conventional moving object database systems where the exact locations and velocities last disclosed are used to predict their motions, we propose the concept of Spatio-temporal safe region to approximate possible future locations. Spatio-temporal safe regions provide larger space of tolerance for moving objects, freeing them from location and velocity updates as long as the errors remain predictable in the database. To answer predictive queries accurately, the server is allowed to probe the latest status of objects when their safe regions are inadequate in returning the exact query results. Spatio-temporal safe regions are calculated and optimized by the database server with two contradictory objectives: reducing update workload while guaranteeing query accuracy and efficiency. To achieve this, we propose a cost model that estimates the composition of active and passive updates based on historical motion records and query distribution. More system performance improvements can be obtained by cutting more updates from the clients, when the users of system are comfortable with incomplete but accuracy bounded query results. We have conducted extensive experiments to evaluate our proposal on a variety of popular indexing structures. The results confirm the viability, robustness, accuracy and efficiency of our proposed protocol.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (February 2012)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0232-z">Sorting networks on FPGAs</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0232-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rene+Mueller%22">Rene Mueller</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jens+Teubner%22">Jens Teubner</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gustavo+Alonso%22">Gustavo Alonso</a></li></ol>
          <input type="checkbox" id="82749"/>
          <label for="82749">Abstract</label>
          <div>Computer architectures are quickly changing toward heterogeneous many-core systems. Such a trend opens up interesting opportunities but also raises immense challenges since the efficient use of heterogeneous many-core systems is not a trivial problem. Software-configurable microprocessors and FPGAs add further diversity but also increase complexity. In this paper, we explore the use of sorting networks on field-programmable gate arrays (FPGAs). FPGAs are very versatile in terms of how they can be used and can also be added as additional processing units in standard CPU sockets. Our results indicate that efficient usage of FPGAs involves non-trivial aspects such as having the right computation model (a sorting network in this case); a careful implementation that balances all the design constraints in an FPGA; and the proper integration strategy to link the FPGA to the rest of the system. Once these issues are properly addressed, our experiments show that FPGAs exhibit performance figures competitive with those of modern general-purpose CPUs while offering significant advantages in terms of power consumption and parallel stream evaluation.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0233-y">Distributed similarity estimation using derived dimensions</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0233-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Konstantinos+Georgoulas%22">Konstantinos Georgoulas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Kotidis%22">Yannis Kotidis</a></li></ol>
          <input type="checkbox" id="88838"/>
          <label for="88838">Abstract</label>
          <div>Computing the similarity between data objects is a fundamental operation for many distributed applications such as those on the World Wide Web, in Peer-to-Peer networks, or even in Sensor Networks. In our work, we provide a framework based on Random Hyperplane Projection (RHP) that permits continuous computation of similarity estimates (using the cosine similarity or the correlation coefficient as the preferred similarity metric) between data descriptions that are streamed from remote sites. These estimates are computed at a monitoring node, without the need for transmitting the actual data values. The original RHP framework is data agnostic and works for arbitrary data sets. However, data in most applications is not uniform. In our work, we first describe the shortcomings of the RHP scheme, in particular, its inefficiency to exploit evident skew in the underlying data distribution and then propose a novel framework that automatically detects correlations and computes an RHP embedding in the Hamming cube tailored to the provided data set using the idea of derived dimensions we first introduce. We further discuss extensions of our framework in order to cope with changes in the data distribution. In such cases, our technique automatically reverts to the basic RHP model for data items that cannot be described accurately through the computed embedding. Our experimental evaluation using several real and synthetic data sets demonstrates that our proposed scheme outperforms the existing RHP algorithm and alternative techniques that have been proposed, providing significantly more accurate similarity computations using the same number of bits.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0234-x">Type inference and type checking for queries over execution traces</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0234-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniel+Deutch%22">Daniel Deutch</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tova+Milo%22">Tova Milo</a></li></ol>
          <input type="checkbox" id="32624"/>
          <label for="32624">Abstract</label>
          <div>We study here Type Inference and Type Checking for queries over the execution traces of Business Processes. We define formal models for such execution traces, allowing to capture various realistic scenarios of partial information about these traces. We then define corresponding notions of types, and the problems of type inference and type checking in this context. We further provide a comprehensive study of the decidability and complexity of these problems, in various cases, and suggest efficient algorithms where possible.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0235-9">Continuous reverse k nearest neighbors queries in Euclidean space and in spatial networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0235-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Muhammad+Aamir+Cheema%22">Muhammad Aamir Cheema</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wenjie+Zhang%22">Wenjie Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ying+Zhang%22">Ying Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuefei+Li%22">Xuefei Li</a></li></ol>
          <input type="checkbox" id="26758"/>
          <label for="26758">Abstract</label>
          <div>In this paper, we study the problem of continuous monitoring of reverse k nearest neighbors queries in Euclidean space as well as in spatial networks. Existing techniques are sensitive toward objects and queries movement. For example, the results of a query are to be recomputed whenever the query changes its location. We present a framework for continuous reverse k nearest neighbor (RkNN) queries by assigning each object and query with a safe region such that the expensive recomputation is not required as long as the query and objects remain in their respective safe regions. This significantly improves the computation cost. As a byproduct, our framework also reduces the communication cost in client–server architectures because an object does not report its location to the server unless it leaves its safe region or the server sends a location update request. We also conduct a rigid cost analysis for our Euclidean space RkNN algorithm. We show that our techniques can also be applied to answer bichromatic RkNN queries in Euclidean space as well as in spatial networks. Furthermore, we show that our techniques can be extended for the spatial networks that are represented by directed graphs. The extensive experiments demonstrate that our techniques outperform the existing techniques by an order of magnitude in terms of computation cost and communication cost.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0238-6">Answering pattern match queries in large graph databases via graph embedding</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0238-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Lei+Zou%22">Lei Zou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dongyan+Zhao%22">Dongyan Zhao</a></li></ol>
          <input type="checkbox" id="82139"/>
          <label for="82139">Abstract</label>
          <div>The growing popularity of graph databases has generated interesting data management problems, such as subgraph search, shortest path query, reachability verification, and pattern matching. Among these, a pattern match query is more flexible compared with a subgraph search and more informative compared with a shortest path or a reachability query. In this paper, we address distance-based pattern match queries over a large data graph G. Due to the huge search space, we adopt a filter-and-refine framework to answer a pattern match query over a large graph. We first find a set of candidate matches by a graph embedding technique and then evaluate these to find the exact matches. Extensive experiments confirm the superiority of our method.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0239-5">Design by example for SQL table definitions with functional dependencies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0239-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sven+Hartmann%22">Sven Hartmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Markus+Kirchberg%22">Markus Kirchberg</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sebastian+Link%22">Sebastian Link</a></li></ol>
          <input type="checkbox" id="99295"/>
          <label for="99295">Abstract</label>
          <div>A database is C-Armstrong for a given set of constraints in a class C if it satisfies every constraint of the set and violates every constraint in C not implied by the set. Therefore, Armstrong databases are test data that perfectly illustrate the current perceptions about the semantics of a schema. We extend the existing theory of Armstrong relations to a toolbox of Armstrong tables. That is, we investigate structural and computational properties of Armstrong tables for the class of functional dependencies (FDs) over SQL tables. Relations are special instances of SQL tables with no duplicate rows and no null value occurrences. While FDs do not enjoy Armstrong tables, the combined class of standard FDs and NOT NULL constraints does enjoy Armstrong tables. The problem of finding an Armstrong table is shown to be precisely exponential for this combined class. However, we establish an algorithm that computes Armstrong tables with a size at most quadratic in that of a minimum-sized Armstrong table. Our resulting toolbox of Armstrong tables can be applied by data engineers to concisely visualize constraints on SQL data. Such support can lead to designs that guarantee efficient data management in practice.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0240-z">Which sort orders are interesting?</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0240-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ravindra+Guravannavar%22">Ravindra Guravannavar</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Sudarshan%22">S. Sudarshan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ajit+A.+Diwan%22">Ajit A. Diwan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ch.+Sobhan+Babu%22">Ch. Sobhan Babu</a></li></ol>
          <input type="checkbox" id="9001"/>
          <label for="9001">Abstract</label>
          <div>Sort orders play an important role in query evaluation. Algorithms that rely on sorting are widely used to implement joins, grouping, duplicate elimination and other set operations. The notion of interesting orders has allowed query optimizers to consider plans that could be locally sub-optimal, but produce ordered output beneficial for other operators, and thus be part of a globally optimal plan. However, the number of interesting orders for most operators is factorial in the number of attributes involved. Optimizer implementations use heuristics to prune the number of interesting orders, but the quality of the heuristics is unclear. Increasingly complex decision support queries and increasing use of query-covering indices, which provide multiple alternative sort orders for relations, motivate us to better address the problem of choosing interesting orders. We show that even a simplified version of the problem is NP-hard and provide a 1/2-benefit approximation algorithm for a special case of the problem. We then present principled heuristics for the general case of choosing interesting orders. We have implemented the proposed techniques in a Volcano-style cost-based optimizer, and our performance study shows significant improvements in estimated cost. We also executed our plans on a widely used commercial database system, and on PostgreSQL, and found that actual execution times for our plans were significantly better than for plans generated by those systems in several cases.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 20 (February 2011 - December 2011)</h1>
          <ol><li>
          <h2>Issue 6 (December 2011)</h2>
          <ul><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0224-z">STAIRS: Towards efficient full-text filtering and dissemination in DHT environments</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0224-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Weixiong+Rao%22">Weixiong Rao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ada+Wai-Chee+Fu%22">Ada Wai-Chee Fu</a></li></ol>
          <input type="checkbox" id="99906"/>
          <label for="99906">Abstract</label>
          <div>Nowadays “live” content, such as weblog, wikipedia, and news, is ubiquitous in the Internet. Providing users with relevant content in a timely manner becomes a challenging problem. Differing from Web search technologies and RSS feeds/reader applications, this paper envisions a personalized full-text content filtering and dissemination system in a highly distributed environment such as a Distributed Hash Table (DHT) based Peer-to-Peer (P2P) Network. Users subscribe to their interested content by specifying input keywords and thresholds as filters. Then, content is disseminated to those users having interest in it. In the literature, full-text document publishing in DHTs has suffered for a long time from the high cost of forwarding a document to home nodes of all distinct terms. It is aggravated by the fact that a document contains a large number of distinct terms (typically tens or thousands of terms per document). In this paper, we propose a set of novel techniques to overcome such a high forwarding cost by carefully selecting a very small number of meaningful terms (or key features) among candidate terms inside each document. Next, to reduce the average hop count per forwarding, we further prune irrelevant documents during the forwarding path. Experiments based on two real query logs and two real data sets demonstrate the effectiveness of our solution.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0225-y">Shooting top-k stars in uncertain databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0225-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xiang+Lian%22">Xiang Lian</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li></ol>
          <input type="checkbox" id="21244"/>
          <label for="21244">Abstract</label>
          <div>Query processing in the uncertain database has played an important role in many real-world applications due to the wide existence of uncertain data. Although many previous techniques can correctly handle precise data, they are not directly applicable to the uncertain scenario. In this article, we investigate and propose a novel query, namely probabilistic top-k star (PTkS) query, which aims to retrieve k objects in an uncertain database that are “closest” to a static/dynamic query point, considering both distance and probability aspects. In order to efficiently answer PTkS queries with a static/moving query point, we propose effective pruning methods to reduce the PTkS search space, which can be seamlessly integrated into an efficient query procedure. Finally, extensive experiments have demonstrated the efficiency and effectiveness of our proposed PTkS approaches on both real and synthetic data sets, under various parameter settings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0228-8">Elastic SI-Cache: consistent and scalable caching in multi-tier architectures</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0228-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Francisco+Perez-Sorrosal%22">Francisco Perez-Sorrosal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marta+Pati%C3%B1o-Martinez%22">Marta Patiño-Martinez</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ricardo+Jimenez-Peris%22">Ricardo Jimenez-Peris</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bettina+Kemme%22">Bettina Kemme</a></li></ol>
          <input type="checkbox" id="70909"/>
          <label for="70909">Abstract</label>
          <div>The new vision of cloud computing demands scalable, available and autonomic software platforms in order to deploy applications and services accessible anywhere and anytime. Multi-tier architectures are an important building block for many applications that are deployed in the cloud. This paper presents a novel caching and replication infrastructure that facilitates the scalable and elastic deployment of multi-tier architectures. Our Elastic SI-Cache is a novel multi-version cache that attains high performance and consistency in multi-tier systems. In contrast to most existing caches, Elastic SI-Cache provides snapshot isolation coherently across all tiers. Furthermore, Elastic SI-Cache supports scalable replication of the different tiers where replicas can be added or removed dynamically as needed, making the cache amenable for cloud computing environments. Elastic SI-Cache has been implemented and integrated into an open source JEE application server and its performance evaluated with the industrial benchmark SPECjAppServer.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0229-7">UpStream: storage-centric load management for streaming applications with update semantics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0229-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alexandru+Moga%22">Alexandru Moga</a></li><li><a href="http://link.springer.com/search?facet-author=%22Irina+Botan%22">Irina Botan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nesime+Tatbul%22">Nesime Tatbul</a></li></ol>
          <input type="checkbox" id="53609"/>
          <label for="53609">Abstract</label>
          <div>This paper addresses the problem of minimizing the staleness of query results for streaming applications with update semantics under overload conditions. Staleness is a measure of how out-of-date the results are compared with the latest data arriving on the input. Real-time streaming applications are subject to overload due to unpredictably increasing data rates, while in many of them, we observe that data streams and queries in fact exhibit “update semantics” (i.e., the latest input data are all that really matters when producing a query result). Under such semantics, overload will cause staleness to build up. The key to avoid this is to exploit the update semantics of applications as early as possible in the processing pipeline. In this paper, we propose UpStream, a storage-centric framework for load management over streaming applications with update semantics. We first describe how we model streams and queries that possess the update semantics, providing definitions for correctness and staleness for the query results. Then, we show how staleness can be minimized based on intelligent update key scheduling techniques applied at the queue level, while preserving the correctness of the results, even for complex queries that involve sliding windows. UpStream is based on the simple idea of applying the updates in place, yet with great returns in terms of lowering staleness and memory consumption, as we also experimentally verify on the Borealis system.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0230-1">Maximizing bichromatic reverse nearest neighbor for L p -norm in two- and three-dimensional spaces</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0230-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Raymond+Chi-Wing+Wong%22">Raymond Chi-Wing Wong</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ada+Wai-Chee+Fu%22">Ada Wai-Chee Fu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lian+Liu%22">Lian Liu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yubao+Liu%22">Yubao Liu</a></li></ol>
          <input type="checkbox" id="31551"/>
          <label for="31551">Abstract</label>
          <div>Bichromatic reverse nearest neighbor (BRNN) has been extensively studied in spatial database literature. In this paper, we study a related problem called MaxBRNN: find an optimal region that maximizes the size of BRNNs for L p -norm in two- and three- dimensional spaces. Such a problem has many real-life applications, including the problem of finding a new server point that attracts as many customers as possible by proximity. A straightforward approach is to determine the BRNNs for all possible points that are not feasible since there are a large (or infinite) number of possible points. To the best of our knowledge, there are no existing algorithms which solve MaxBRNN for any L p -norm space of two- and three-dimensionality. Based on some interesting properties of the problem, we come up with an efficient algorithm called MaxOverlap for to solve this problem. Extensive experiments are conducted to show that our algorithm is efficient.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0231-0">Progressive processing of subspace dominating queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0231-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Eleftherios+Tiakas%22">Eleftherios Tiakas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Apostolos+N.+Papadopoulos%22">Apostolos N. Papadopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Manolopoulos%22">Yannis Manolopoulos</a></li></ol>
          <input type="checkbox" id="74679"/>
          <label for="74679">Abstract</label>
          <div>A top-k dominating query reports the k items with the highest domination score. Algorithms for efficient processing of this query have been recently proposed in the literature. Those methods, either index based or index free, apply a series of pruning criteria toward efficient processing. However, they are characterized by several limitations, such as (1) they lack progressiveness (they report the k best items at the end of the processing), (2) they require a multi-dimensional index or they build a grid-based index on-the-fly, which suffers from performance degradation, especially in high dimensionalities, and (3) they do not support vertically decomposed data. In this paper, we design efficient algorithms that can handle any subset of the dimensions in a progressive manner. Among the studied algorithms, the Differential Algorithm shows the best overall performance.</div>
        </li></ul>
        </li><li>
          <h2>Issue 5 (October 2011)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0250-x">Special issue on data management for mobile services</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0250-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ralf+Hartmut+G%C3%BCting%22">Ralf Hartmut Güting</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nikos+Mamoulis%22">Nikos Mamoulis</a></li></ol>
          <input type="checkbox" id="91438"/>
          <label for="91438">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0236-8">Indexing in-network trajectory flows</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0236-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Iulian+Sandu+Popa%22">Iulian Sandu Popa</a></li><li><a href="http://link.springer.com/search?facet-author=%22Karine+Zeitouni%22">Karine Zeitouni</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vincent+Oria%22">Vincent Oria</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dominique+Barth%22">Dominique Barth</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sandrine+Vial%22">Sandrine Vial</a></li></ol>
          <input type="checkbox" id="58892"/>
          <label for="58892">Abstract</label>
          <div>Indexing moving objects (MO) is a hot topic in the field of moving objects databases since many years. An impressive number of access methods have been proposed to optimize the processing of MO-related queries. Several methods have focused on spatio-temporal range queries, which represent the foundation of MO trajectory queries. Surprisingly, only a few of them consider that the objects movements are constrained. This is an important aspect for several reasons ranging from better capturing the relationship between the trajectory and the network space to more accurate trajectory representation with lower storage requirements. In this paper, we propose T-PARINET, an access method to efficiently retrieve the trajectories of objects moving in networks. T-PARINET is designed for continuous indexing of trajectory data flows. The cornerstone of T-PARINET is PARINET, an efficient index for historical trajectory data. The structure of PARINET is based on a combination of graph partitioning and a set of composite B+-tree local indexes. Because the network can be modeled using graphs, the partitioning of the trajectory data makes use of graph partitioning theory and can be tuned for a given query load and a given data distribution in the network space. The tuning process is built on a good quality cost model that is supplied with PARINET. The advantage of having a cost model is twofold; it allows a better integration of the index into the query optimizer of any DBMS, and it permits tuning the index structure for better performance. The tuning process can be performed before the index creation in the case of historical data or online in the case of indexing data flows. In fact, massive online updates can degrade the index quality, which can be measured by the cost model. We propose a specific maintenance process that results into T-PARINET. We study different types of queries and provide an optimized configuration for several scenarios. T-PARINET can easily be integrated into any RDBMS, which is an essential asset particularly for industrial or commercial applications. The experimental evaluation under an off-the-shelf DBMS shows that our method is robust. It also significantly outperforms the reference R-tree-based access methods for in-network trajectory databases.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0237-7">Efficient real-time trajectory tracking</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0237-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ralph+Lange%22">Ralph Lange</a></li><li><a href="http://link.springer.com/search?facet-author=%22Frank+D%C3%BCrr%22">Frank Dürr</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kurt+Rothermel%22">Kurt Rothermel</a></li></ol>
          <input type="checkbox" id="54947"/>
          <label for="54947">Abstract</label>
          <div>Moving objects databases (MOD) manage trajectory information of vehicles, animals, and other mobile objects. A crucial problem is how to efficiently track an object’s trajectory in real-time, in particular if the trajectory data is sensed at the mobile object and thus has to be communicated over a wireless network. We propose a family of tracking protocols that allow trading the communication cost and the amount of trajectory data stored at a MOD off against the spatial accuracy. With each of these protocols, the MOD manages a simplified trajectory that does not deviate by more than a certain accuracy bound from the actual movement. Moreover, the different protocols enable several trade-offs between computational costs, communication cost, and the reduction in the trajectory data: Connection-Preserving Dead Reckoning minimizes the communication cost using dead reckoning, a technique originally designed for tracking an object’s current position. Generic Remote Trajectory Simplification (GRTS) further separates between tracking of the current position and simplification of the past trajectory and can be realized with different line simplification algorithms. For both protocols, we discuss how to bound the space consumption and computing time at the moving object and thereby present an effective compression technique to optimize the reduction performance of real-time line simplification in general. Our evaluations with hundreds of real GPS traces show that a realization of GRTS with a simple simplification heuristic reaches 85–90% of the best possible reduction rate, given by retrospective offline simplification. A realization with the optimal line simplification algorithm by Imai and Iri even reaches more than 97% of the best possible reduction rate.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0244-8">Unveiling the complexity of human mobility by querying and mining massive trajectory data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0244-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Fosca+Giannotti%22">Fosca Giannotti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mirco+Nanni%22">Mirco Nanni</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dino+Pedreschi%22">Dino Pedreschi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Fabio+Pinelli%22">Fabio Pinelli</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chiara+Renso%22">Chiara Renso</a></li><li><a href="http://link.springer.com/search?facet-author=%22Salvatore+Rinzivillo%22">Salvatore Rinzivillo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Roberto+Trasarti%22">Roberto Trasarti</a></li></ol>
          <input type="checkbox" id="50181"/>
          <label for="50181">Abstract</label>
          <div>The technologies of mobile communications pervade our society and wireless networks sense the movement of people, generating large volumes of mobility data, such as mobile phone call records and Global Positioning System (GPS) tracks. In this work, we illustrate the striking analytical power of massive collections of trajectory data in unveiling the complexity of human mobility. We present the results of a large-scale experiment, based on the detailed trajectories of tens of thousands private cars with on-board GPS receivers, tracked during weeks of ordinary mobile activity. We illustrate the knowledge discovery process that, based on these data, addresses some fundamental questions of mobility analysts: what are the frequent patterns of people’s travels? How big attractors and extraordinary events influence mobility? How to predict areas of dense traffic in the near future? How to characterize traffic jams and congestions? We also describe M-Atlas, the querying and mining language and system that makes this analytical process possible, providing the mechanisms to master the complexity of transforming raw GPS tracks into mobility knowledge. M-Atlas is centered onto the concept of a trajectory, and the mobility knowledge discovery process can be specified by M-Atlas queries that realize data transformations, data-driven estimation of the parameters of the mining methods, the quality assessment of the obtained results, the quantitative and visual exploration of the discovered behavioral patterns and models, the composition of mined patterns, models and data with further analyses and mining, and the incremental mining strategies to address scalability.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0247-5">Sequenced spatiotemporal aggregation for coarse query granularities</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0247-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Igor+Timko%22">Igor Timko</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+B%C3%B6hlen%22">Michael Böhlen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Johann+Gamper%22">Johann Gamper</a></li></ol>
          <input type="checkbox" id="79395"/>
          <label for="79395">Abstract</label>
          <div>Sequenced spatiotemporal aggregation (SSTA) is an important query for many applications of spatiotemporal databases, such as traffic analysis. Conceptually, an SSTA query returns one aggregate value for each individual spatiotemporal granule. While the data is typically recorded at a fine granularity, at query time a coarser granularity is common. This calls for efficient evaluation strategies that are granularity aware. In this paper, we formally define an SSTA operator that includes a data-to-query granularity conversion. Based on a discrete time model and a discrete 1.5 dimensional space model, we generalize the concept of time constant intervals to constant rectangles, which represent maximal rectangles in the spatiotemporal domain over which an aggregation result is constant. We propose an efficient evaluation algorithm for SSTA queries that takes advantage of a coarse query granularity. The algorithm is based on the plane sweep paradigm, and we propose a granularity aware event point schedule, termed gaEPS, and a granularity aware sweep line status, termed gaSLS. These data structures store space and time points from the input relation in a compressed form using a minimal set of counters. In extensive experiments, we show that for coarse query granularities gaEPS significantly outperforms a basic EPS that is based on an extension of previous work, both in terms of memory usage and runtime.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0241-y">Direction-based surrounder queries for mobile recommendations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0241-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xi+Guo%22">Xi Guo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Baihua+Zheng%22">Baihua Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yoshiharu+Ishikawa%22">Yoshiharu Ishikawa</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yunjun+Gao%22">Yunjun Gao</a></li></ol>
          <input type="checkbox" id="35747"/>
          <label for="35747">Abstract</label>
          <div>Location-based recommendation services recommend objects to the user based on the user’s preferences. In general, the nearest objects are good choices considering their spatial proximity to the user. However, not only the distance of an object to the user but also their directional relationship are important. Motivated by these, we propose a new spatial query, namely a direction-based surrounder (DBS) query, which retrieves the nearest objects around the user from different directions. We define the DBS query not only in a two-dimensional Euclidean space ${\mathbb{E}}$ but also in a road network ${\mathbb{R}}$ . In the Euclidean space ${\mathbb{E}}$ , we consider two objects a and b are directional close w.r.t. a query point q iff the included angle ${\angle aqb}$ is bounded by a threshold specified by the user at the query time. In a road network ${\mathbb{R}}$ , we consider two objects a and b are directional close iff their shortest paths to q overlap. We say object a dominates object b iff they are directional close and meanwhile a is closer to q than b. All the objects that are not dominated by others based on the above dominance relationship constitute direction-based surrounders (DBSs). In this paper, we formalize the DBS query, study it in both the snapshot and continuous settings, and conduct extensive experiments with both real and synthetic datasets to evaluate our proposed algorithms. The experimental results demonstrate that the proposed algorithms can answer DBS queries efficiently.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0249-3">Ranking continuous nearest neighbors for uncertain trajectories</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0249-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Goce+Trajcevski%22">Goce Trajcevski</a></li><li><a href="http://link.springer.com/search?facet-author=%22Roberto+Tamassia%22">Roberto Tamassia</a></li><li><a href="http://link.springer.com/search?facet-author=%22Isabel+F.+Cruz%22">Isabel F. Cruz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+Scheuermann%22">Peter Scheuermann</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Hartglass%22">David Hartglass</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christopher+Zamierowski%22">Christopher Zamierowski</a></li></ol>
          <input type="checkbox" id="80717"/>
          <label for="80717">Abstract</label>
          <div>This article addresses the problem of performing Nearest Neighbor (NN) queries on uncertain trajectories. The answer to an NN query for certain trajectories is time parameterized due to the continuous nature of the motion. As a consequence of uncertainty, there may be several objects that have a non-zero probability of being a nearest neighbor to a given querying object, and the continuous nature further complicates the semantics of the answer. We capture the impact that the uncertainty of the trajectories has on the semantics of the answer to continuous NN queries and we propose a tree structure for representing the answers, along with efficient algorithms to compute them. We also address the issue of performing NN queries when the motion of the objects is restricted to road networks. Finally, we formally define and show how to efficiently execute several variants of continuous NN queries. Our experiments demonstrate that the proposed algorithms yield significant performance improvements when compared with the corresponding naïve approaches.</div>
        </li></ul>
        </li><li>
          <h2>Issue 4 (August 2011)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0205-7">Performance analysis of a dual-tree algorithm for computing spatial distance histograms</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0205-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Shaoping+Chen%22">Shaoping Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yi-Cheng+Tu%22">Yi-Cheng Tu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yuni+Xia%22">Yuni Xia</a></li></ol>
          <input type="checkbox" id="42956"/>
          <label for="42956">Abstract</label>
          <div>Many scientific and engineering fields produce large volume of spatiotemporal data. The storage, retrieval, and analysis of such data impose great challenges to database systems design. Analysis of scientific spatiotemporal data often involves computing functions of all point-to-point interactions. One such analytics, the Spatial Distance Histogram (SDH), is of vital importance to scientific discovery. Recently, algorithms for efficient SDH processing in large-scale scientific databases have been proposed. These algorithms adopt a recursive tree-traversing strategy to process point-to-point distances in the visited tree nodes in batches, thus require less time when compared to the brute-force approach where all pairwise distances have to be computed. Despite the promising experimental results, the complexity of such algorithms has not been thoroughly studied. In this paper, we present an analysis of such algorithms based on a geometric modeling approach. The main technique is to transform the analysis of point counts into a problem of quantifying the area of regions where pairwise distances can be processed in batches by the algorithm. From the analysis, we conclude that the number of pairwise distances that are left to be processed decreases exponentially with more levels of the tree visited. This leads to the proof of a time complexity lower than the quadratic time needed for a brute-force algorithm and builds the foundation for a constant-time approximate algorithm. Our model is also general in that it works for a wide range of point spatial distributions, histogram types, and space-partitioning options in building the tree.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0206-6">Dynamic constraints for record matching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0206-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wenfei+Fan%22">Wenfei Fan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hong+Gao%22">Hong Gao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xibei+Jia%22">Xibei Jia</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianzhong+Li%22">Jianzhong Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shuai+Ma%22">Shuai Ma</a></li></ol>
          <input type="checkbox" id="14280"/>
          <label for="14280">Abstract</label>
          <div>This paper investigates constraints for matching records from unreliable data sources. (a) We introduce a class of matching dependencies (mds) for specifying the semantics of unreliable data. As opposed to static constraints for schema design, mds are developed for record matching, and are defined in terms of similarity predicates and a dynamic semantics. (b) We identify a special case of mds, referred to as relative candidate keys (rcks), to determine what attributes to compare and how to compare them when matching records across possibly different relations. (c) We propose a mechanism for inferring mds, a departure from traditional implication analysis, such that when we cannot match records by comparing attributes that contain errors, we may still find matches by using other, more reliable attributes. Moreover, we develop a sound and complete system for inferring mds. (d) We provide a quadratic-time algorithm for inferring mds and an effective algorithm for deducing a set of high-quality rcks from mds. (e) We experimentally verify that the algorithms help matching tools efficiently identify keys at compile time for matching, blocking or windowing and in addition, that the md-based techniques effectively improve the quality and efficiency of various record matching methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0212-8">Fast graph query processing with a low-cost index</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0212-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22James+Cheng%22">James Cheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yiping+Ke%22">Yiping Ke</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ada+Wai-Chee+Fu%22">Ada Wai-Chee Fu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li></ol>
          <input type="checkbox" id="72908"/>
          <label for="72908">Abstract</label>
          <div>This paper studies the problem of processing supergraph queries, that is, given a database containing a set of graphs, find all the graphs in the database of which the query graph is a supergraph. Existing works usually construct an index and performs a filtering-and-verification process, which still requires many subgraph isomorphism testings. There are also significant overheads in both index construction and maintenance. In this paper, we design a graph querying system that achieves both fast indexing and efficient query processing. The index is constructed by a simple but fast method of extracting the commonality among the graphs, which does not involve any costly operation such as graph mining. Our query processing has two key techniques, direct inclusion and filtering. Direct inclusion allows partial query answers to be included directly without candidate verification. Our filtering technique further reduces the candidate set by operating on a much smaller projected database. Experimental results show that our method is significantly more efficient than the existing works in both indexing and query processing, and our index has a low maintenance cost.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0213-7">Privacy in geo-social networks: proximity notification with untrusted service providers and curious buddies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0213-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sergio+Mascetti%22">Sergio Mascetti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dario+Freni%22">Dario Freni</a></li><li><a href="http://link.springer.com/search?facet-author=%22Claudio+Bettini%22">Claudio Bettini</a></li><li><a href="http://link.springer.com/search?facet-author=%22X.+Sean+Wang%22">X. Sean Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sushil+Jajodia%22">Sushil Jajodia</a></li></ol>
          <input type="checkbox" id="47178"/>
          <label for="47178">Abstract</label>
          <div>A major feature of the emerging geo-social networks is the ability to notify a user when any of his friends (also called buddies) happens to be geographically in proximity. This proximity service is usually offered by the network itself or by a third party service provider (SP) using location data acquired from the users. This paper provides a rigorous theoretical and experimental analysis of the existing solutions for the location privacy problem in proximity services. This is a serious problem for users who do not trust the SP to handle their location data and would only like to release their location information in a generalized form to participating buddies. The paper presents two new protocols providing complete privacy with respect to the SP and controllable privacy with respect to the buddies. The analytical and experimental analysis of the protocols takes into account privacy, service precision, and computation and communication costs, showing the superiority of the new protocols compared to those appeared in the literature to date. The proposed protocols have also been tested in a full system implementation of the proximity service.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0214-6">Anonymity meets game theory: secure data integration with malicious participants</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0214-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Noman+Mohammed%22">Noman Mohammed</a></li><li><a href="http://link.springer.com/search?facet-author=%22Benjamin+C.+M.+Fung%22">Benjamin C. M. Fung</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mourad+Debbabi%22">Mourad Debbabi</a></li></ol>
          <input type="checkbox" id="89002"/>
          <label for="89002">Abstract</label>
          <div>Data integration methods enable different data providers to flexibly integrate their expertise and deliver highly customizable services to their customers. Nonetheless, combining data from different sources could potentially reveal person-specific sensitive information. In VLDBJ 2006, Jiang and Clifton (Very Large Data Bases J (VLDBJ) 15(4):316–333, 2006) propose a secure Distributed k-Anonymity (DkA) framework for integrating two private data tables to a k-anonymous table in which each private table is a vertical partition on the same set of records. Their proposed DkA framework is not scalable to large data sets. Moreover, DkA is limited to a two-party scenario and the parties are assumed to be semi-honest. In this paper, we propose two algorithms to securely integrate private data from multiple parties (data providers). Our first algorithm achieves the k-anonymity privacy model in a semi-honest adversary model. Our second algorithm employs a game-theoretic approach to thwart malicious participants and to ensure fair and honest participation of multiple data providers in the data integration process. Moreover, we study and resolve a real-life privacy problem in data sharing for the financial industry in Sweden. Experiments on the real-life data demonstrate that our proposed algorithms can effectively retain the essential information in anonymous data for data analysis and are scalable for anonymizing large data sets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0217-y">Interaction-aware scheduling of report-generation workloads</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0217-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mumtaz+Ahmad%22">Mumtaz Ahmad</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ashraf+Aboulnaga%22">Ashraf Aboulnaga</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shivnath+Babu%22">Shivnath Babu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kamesh+Munagala%22">Kamesh Munagala</a></li></ol>
          <input type="checkbox" id="43502"/>
          <label for="43502">Abstract</label>
          <div>The typical workload in a database system consists of a mix of multiple queries of different types that run concurrently. Interactions among the different queries in a query mix can have a significant impact on database performance. Hence, optimizing database performance requires reasoning about query mixes rather than considering queries individually. Current database systems lack the ability to do such reasoning. We propose a new approach based on planning experiments and statistical modeling to capture the impact of query interactions. Our approach requires no prior assumptions about the internal workings of the database system or the nature and cause of query interactions, making it portable across systems. To demonstrate the potential of modeling and exploiting query interactions, we have developed a novel interaction-aware query scheduler for report-generation workloads. Our scheduler, called QShuffler, uses two query scheduling algorithms that leverage models of query interactions. The first algorithm is optimized for workloads where queries are submitted in large batches. The second algorithm targets workloads where queries arrive continuously, and scheduling decisions have to be made online. We report an experimental evaluation of QShuffler using TPC-H workloads running on IBM DB2. The evaluation shows that QShuffler, by modeling and exploiting query interactions, can consistently outperform (up to 4x) query schedulers in current database systems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0218-x">Efficient fuzzy full-text type-ahead search</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0218-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Guoliang+Li%22">Guoliang Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shengyue+Ji%22">Shengyue Ji</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chen+Li%22">Chen Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianhua+Feng%22">Jianhua Feng</a></li></ol>
          <input type="checkbox" id="67693"/>
          <label for="67693">Abstract</label>
          <div>Traditional information systems return answers after a user submits a complete query. Users often feel “left in the dark” when they have limited knowledge about the underlying data and have to use a try-and-see approach for finding information. A recent trend of supporting autocomplete in these systems is a first step toward solving this problem. In this paper, we study a new information-access paradigm, called “type-ahead search” in which the system searches the underlying data “on the fly” as the user types in query keywords. It extends autocomplete interfaces by allowing keywords to appear at different places in the underlying data. This framework allows users to explore data as they type, even in the presence of minor errors. We study research challenges in this framework for large amounts of data. Since each keystroke of the user could invoke a query on the backend, we need efficient algorithms to process each query within milliseconds. We develop various incremental-search algorithms for both single-keyword queries and multi-keyword queries, using previously computed and cached results in order to achieve a high interactive speed. We develop novel techniques to support fuzzy search by allowing mismatches between query keywords and answers. We have deployed several real prototypes using these techniques. One of them has been deployed to support type-ahead search on the UC Irvine people directory, which has been used regularly and well received by users due to its friendly interface and high efficiency.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (June 2011)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0197-3">On-line rule matching for event prediction</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0197-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chung-Wen+Cho%22">Chung-Wen Cho</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yi-Hung+Wu%22">Yi-Hung Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Show-Jane+Yen%22">Show-Jane Yen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ying+Zheng%22">Ying Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arbee+L.+P.+Chen%22">Arbee L. P. Chen</a></li></ol>
          <input type="checkbox" id="96167"/>
          <label for="96167">Abstract</label>
          <div>The prediction of future events has great importance in many applications. The prediction is based on episode rules which are composed of events and two time constraints which require all the events in the episode rule and in the predicate of the rule to occur in a time interval, respectively. In an event stream, a sequence of events which matches the predicate of the rule satisfying the specified time constraint is called an occurrence of the predicate. After finding the occurrence, the consequent event which will occur in a time interval can be predicted. However, the time intervals computed from some occurrences for predicting the event can be contained in the time intervals computed from other occurrence and become redundant. As a result, how to design an efficient and effective event predictor in a stream environment is challenging. In this paper, an effective scheme is proposed to avoid matching the predicate events corresponding to redundant time intervals for prediction. Based on the scheme, we respectively consider two methodologies, forward retrieval and backward retrieval, for the efficient matching of predicate events over event streams. The approach based on forward retrieval construct a queue structure to incrementally maintain parts of the matched results as events arrive, and thus it avoids backward scans of the event stream. On the other hand, the approach based on backward retrieval maintains the recently arrived events in a tree structure. The matching of predicate events is triggered by identifiable events and achieved by an efficient retrieval on the tree structure, which avoids exhaustive scans of the arrived events. By running a series of experiments, we show that each of the proposed approaches has its advantages on particular data distributions and parameter settings.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0198-2">Mining learning-dependency between knowledge units from text</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0198-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jun+Liu%22">Jun Liu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lu+Jiang%22">Lu Jiang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhaohui+Wu%22">Zhaohui Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qinghua+Zheng%22">Qinghua Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yanan+Qian%22">Yanan Qian</a></li></ol>
          <input type="checkbox" id="63098"/>
          <label for="63098">Abstract</label>
          <div>Identifying learning-dependency among the knowledge units (KU) is a preliminary requirement of navigation learning. Methods based on link mining lack the ability of discovering such dependencies among knowledge units that are arranged in a linear way in the text. In this paper, we propose a method of mining the learning- dependencies among the KU from text document. This method is based on two features that we found and studied from the KU and the learning-dependencies among them. They are the distributional asymmetry of the domain terms and the local nature of the learning-dependency, respectively. Our method consists of three stages, (1) Build document association relationship by calculating the distributional asymmetry of the domain terms. (2) Generate the candidate KU-pairs by measuring the locality of the dependencies. (3) Use classification algorithm to identify the learning-dependency between KU-pairs. Our experimental results show that our method extracts the learning-dependency efficiently and reduces the computational complexity.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0199-1">Log-based middleware server recovery with transaction support</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0199-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rui+Wang%22">Rui Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Betty+Salzberg%22">Betty Salzberg</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Lomet%22">David Lomet</a></li></ol>
          <input type="checkbox" id="61162"/>
          <label for="61162">Abstract</label>
          <div>Providing enterprises with reliable and available Web-based application programs is a challenge. Applications are traditionally spread over multiple nodes, from user (client), to middle tier servers, to back end transaction systems, e.g. databases. It has proven very difficult to ensure that these applications persist across system crashes so that “exactly once” execution is produced, always important and sometimes essential, e.g., in the financial area. Our system provides a framework for exactly once execution of multi-tier Web applications, built on a commercially available Web infrastructure. Its capabilities include low logging overhead, recovery isolation (independence), and consistency between mid-tier and transactional back end. Good application performance is enabled via persistent shared state in the middle tier while providing for private session state as well. Our extensive experiments confirm both the desired properties and the good performance.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0200-z">Continuous visible nearest neighbor query processing in spatial databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0200-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yunjun+Gao%22">Yunjun Gao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Baihua+Zheng%22">Baihua Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gencai+Chen%22">Gencai Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qing+Li%22">Qing Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofa+Guo%22">Xiaofa Guo</a></li></ol>
          <input type="checkbox" id="46316"/>
          <label for="46316">Abstract</label>
          <div>In this paper, we identify and solve a new type of spatial queries, called continuous visible nearest neighbor (CVNN) search. Given a data set P, an obstacle set O, and a query line segment q in a two-dimensional space, a CVNN query returns a set of ${\langle p, R\rangle}$ tuples such that ${p \in P}$ is the nearest neighbor to every point r along the interval ${R \subseteq q}$ as well as p is visible to r. Note that p may be NULL, meaning that all points in P are invisible to all points in R due to the obstruction of some obstacles in O. In contrast to existing continuous nearest neighbor query, CVNN retrieval considers the impact of obstacles on visibility between objects, which is ignored by most of spatial queries. We formulate the problem, analyze its unique characteristics, and develop efficient algorithms for exact CVNN query processing. Our methods (1) utilize conventional data-partitioning indices (e.g., R-trees) on both P and O, (2) tackle the CVNN search by performing a single query for the entire query line segment, and (3) only access the data points and obstacles relevant to the final query result by employing a suite of effective pruning heuristics. In addition, several interesting variations of CVNN queries have been introduced, and they can be supported by our techniques, which further demonstrates the flexibility of the proposed algorithms. A comprehensive experimental evaluation using both real and synthetic data sets has been conducted to verify the effectiveness of our proposed pruning heuristics and the performance of our proposed algorithms.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0202-x">QFilter: rewriting insecure XML queries to secure ones using non-deterministic finite automata</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0202-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bo+Luo%22">Bo Luo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dongwon+Lee%22">Dongwon Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wang-Chien+Lee%22">Wang-Chien Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peng+Liu%22">Peng Liu</a></li></ol>
          <input type="checkbox" id="54337"/>
          <label for="54337">Abstract</label>
          <div>In this paper, we ask whether XML access control can be supported when underlying (XML or relational) storage system does not provide adequate security features and propose three alternative solutions —primitive, pre-processing, and post-processing. Toward that scenario, in particular, we advocate a scalable and effective pre-processing approach, called QFilter. QFilter is based on non-deterministic finite automata (NFA) and rewrites user’s queries such that parts violating access control rules are pre-pruned. Through analysis and experimental validation, we show that (1) QFilter guarantees that only permissible portion of data is returned to the authorized users, (2) such access controls can be efficiently enforced without relying on security features of underlying storage system, and (3) such independency makes QFilter capable of many emerging applications, such as in-network access control and access control outsourcing.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0203-9">Event correlation for process discovery from web service interaction logs</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0203-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hamid+Reza+Motahari-Nezhad%22">Hamid Reza Motahari-Nezhad</a></li><li><a href="http://link.springer.com/search?facet-author=%22Regis+Saint-Paul%22">Regis Saint-Paul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Fabio+Casati%22">Fabio Casati</a></li><li><a href="http://link.springer.com/search?facet-author=%22Boualem+Benatallah%22">Boualem Benatallah</a></li></ol>
          <input type="checkbox" id="52838"/>
          <label for="52838">Abstract</label>
          <div>Understanding, analyzing, and ultimately improving business processes is a goal of enterprises today. These tasks are challenging as business processes in modern enterprises are implemented over several applications and Web services, and the information about process execution is scattered across several data sources. Understanding modern business processes entails identifying the correlation between events in data sources in the context of business processes (event correlation is the process of finding relationships between events that belong to the same process execution instance). In this paper, we investigate the problem of event correlation for business processes that are realized through the interactions of a set of Web services. We identify various ways in which process-related events could be correlated as well as investigate the problem of discovering event correlation (semi-) automatically from service interaction logs. We introduce the concept of process view to represent the process resulting from a certain way of event correlation and that of process space referring to the set of possible process views over process events. Event correlation is a challenging problem as there are various ways in which process events could be correlated, and in many cases, it is subjective. Exploring all the possibilities of correlations is computationally expensive, and only some of the correlated event sets result in process views that are interesting. We propose efficient algorithms and heuristics to identify correlated event sets that lead potentially to interesting process views. To account for its subjectivity, we have designed the event correlation discovery process to be interactive and enable users to guide it toward process views of their interest and organize the discovered process views into a process map that allows users to effectively navigate through the process space and identify the ones of interest. We report on experiments performed on both synthetic and real-world datasets that show the viability and efficiency of the approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0204-8">Index design and query processing for graph conductance search</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0204-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Soumen+Chakrabarti%22">Soumen Chakrabarti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amit+Pathak%22">Amit Pathak</a></li><li><a href="http://link.springer.com/search?facet-author=%22Manish+Gupta%22">Manish Gupta</a></li></ol>
          <input type="checkbox" id="87575"/>
          <label for="87575">Abstract</label>
          <div>Graph conductance queries, also known as personalized PageRank and related to random walks with restarts, were originally proposed to assign a hyperlink-based prestige score to Web pages. More general forms of such queries are also very useful for ranking in entity-relation (ER) graphs used to represent relational, XML and hypertext data. Evaluation of PageRank usually involves a global eigen computation. If the graph is even moderately large, interactive response times may not be possible. Recently, the need for interactive PageRank evaluation has increased. The graph may be fully known only when the query is submitted. Browsing actions of the user may change some inputs to the PageRank computation dynamically. In this paper, we describe a system that analyzes query workloads and the ER graph, invests in limited offline indexing, and exploits those indices to achieve essentially constant-time query processing, even as the graph size scales. Our techniques—data and query statistics collection, index selection and materialization, and query-time index exploitation—have parallels in the extensive relational query optimization literature, but is applied to supporting novel graph data repositories. We report on experiments with five temporal snapshots of the CiteSeer ER graph having 74–702 thousand entity nodes, 0.17–1.16 million word nodes, 0.29–3.26 million edges between entities, and 3.29–32.8 million edges between words and entities. We also used two million actual queries from CiteSeer’s logs. Queries run 3–4 orders of magnitude faster than whole-graph PageRank, the gap growing with graph size. Index size is smaller than a text index. Ranking accuracy is 94–98% with reference to whole-graph PageRank.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 2011)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0222-1">Special issue: best papers of VLDB 2009</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0222-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Serge+Abiteboul%22">Serge Abiteboul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Volker+Markl%22">Volker Markl</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tova+Milo%22">Tova Milo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jignesh+Patel%22">Jignesh Patel</a></li></ol>
          <input type="checkbox" id="3182"/>
          <label for="3182">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0227-9">Preference elicitation in prioritized skyline queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0227-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Denis+Mindolin%22">Denis Mindolin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jan+Chomicki%22">Jan Chomicki</a></li></ol>
          <input type="checkbox" id="15288"/>
          <label for="15288">Abstract</label>
          <div>Preference queries incorporate the notion of binary preference relation into relational database querying. Instead of returning all the answers, such queries return only the best answers, according to a given preference relation. Preference queries are a fast growing area of database research. Skyline queries constitute one of the most thoroughly studied classes of preference queries. A well-known limitation of skyline queries is that skyline preference relations assign the same importance to all attributes. In this work, we study p-skyline queries that generalize skyline queries by allowing varying attribute importance in preference relations. We perform an in-depth study of the properties of p-skyline preference relations. In particular, we study the problems of containment and minimal extension. We apply the obtained results to the central problem of the paper: eliciting relative importance of attributes. Relative importance is implicit in the constructed p-skyline preference relation. The elicitation is based on user-selected sets of superior (positive) and inferior (negative) examples. We show that the computational complexity of elicitation depends on whether inferior examples are involved. If they are not, elicitation can be achieved in polynomial time. Otherwise, it is NP complete. Our experiments show that the proposed elicitation algorithm has high accuracy and good scalability.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0219-9">The SHARC framework for data quality in Web archiving</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0219-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dimitar+Denev%22">Dimitar Denev</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arturas+Mazeika%22">Arturas Mazeika</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marc+Spaniol%22">Marc Spaniol</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="54314"/>
          <label for="54314">Abstract</label>
          <div>Web archives preserve the history of born-digital content and offer great potential for sociologists, business analysts, and legal experts on intellectual property and compliance issues. Data quality is crucial for these purposes. Ideally, crawlers should gather coherent captures of entire Web sites, but the politeness etiquette and completeness requirement mandate very slow, long-duration crawling while Web sites undergo changes. This paper presents the SHARC framework for assessing the data quality in Web archives and for tuning capturing strategies toward better quality with given resources. We define data quality measures, characterize their properties, and develop a suite of quality-conscious scheduling strategies for archive crawling. Our framework includes single-visit and visit–revisit crawls. Single-visit crawls download every page of a site exactly once in an order that aims to minimize the “blur” in capturing the site. Visit–revisit strategies revisit pages after their initial downloads to check for intermediate changes. The revisiting order aims to maximize the “coherence” of the site capture(number pages that did not change during the capture). The quality notions of blur and coherence are formalized in the paper. Blur is a stochastic notion that reflects the expected number of page changes that a time-travel access to a site capture would accidentally see, instead of the ideal view of a instantaneously captured, “sharp” site. Coherence is a deterministic quality measure that counts the number of unchanged and thus coherently captured pages in a site snapshot. Strategies that aim to either minimize blur or maximize coherence are based on prior knowledge of or predictions for the change rates of individual pages. Our framework includes fairly accurate classifiers for change predictions. All strategies are fully implemented in a testbed and shown to be effective by experiments with both synthetically generated sites and a periodic crawl series for different Web sites.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0223-0">Harvesting relational tables from lists on the web</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0223-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hazem+Elmeleegy%22">Hazem Elmeleegy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jayant+Madhavan%22">Jayant Madhavan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Halevy%22">Alon Halevy</a></li></ol>
          <input type="checkbox" id="39478"/>
          <label for="39478">Abstract</label>
          <div>A large number of web pages contain data structured in the form of “lists”. Many such lists can be further split into multi-column tables, which can then be used in more semantically meaningful tasks. However, harvesting relational tables from such lists can be a challenging task. The lists are manually generated and hence need not have well-defined templates—they have inconsistent delimiters (if any) and often have missing information. We propose a novel technique for extracting tables from lists. The technique is domain independent and operates in a fully unsupervised manner. We first use multiple sources of information to split individual lines into multiple fields and then, compare the splits across multiple lines to identify and fix incorrect splits and bad alignments. In particular, we exploit a corpus of HTML tables, also extracted from the web, to identify likely fields and good alignments. For each extracted table, we compute an extraction score that reflects our confidence in the table’s quality. We conducted an extensive experimental study using both real web lists and lists derived from tables on the web. The experiments demonstrate the ability of our technique to extract tables with high accuracy. In addition, we applied our technique on a large sample of about 100,000 lists crawled from the web. The analysis of the extracted tables has led us to believe that there are likely to be tens of millions of useful and query-able relational tables extractable from lists on the web.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0221-2">Predictable performance and high query concurrency for data analytics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0221-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22George+Candea%22">George Candea</a></li><li><a href="http://link.springer.com/search?facet-author=%22Neoklis+Polyzotis%22">Neoklis Polyzotis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Radek+Vingralek%22">Radek Vingralek</a></li></ol>
          <input type="checkbox" id="26218"/>
          <label for="26218">Abstract</label>
          <div>Conventional data warehouses employ the query-at-a-time model, which maps each query to a distinct physical plan. When several queries execute concurrently, this model introduces contention and thrashing, because the physical plans—unaware of each other—compete for access to the underlying I/O and computation resources. As a result, while modern systems can efficiently optimize and evaluate a single complex data analysis query, their performance suffers significantly and can be highly erratic when multiple complex queries run at the same time. We present in this paper Cjoin, a new design that substantially improves throughput in large-scale data analytics systems processing many concurrent join queries. In contrast to the conventional query-at-a-time model our approach employs a single physical plan that shares I/O, computation, and tuple storage across all in-flight join queries. We use an “always on” pipeline of non-blocking operators, managed by a controller that continuously examines the current query mix and optimizes the pipeline on the fly. Our design enables data analytics engines to scale gracefully to large data sets, provide predictable execution times, and reduce contention. We implemented Cjoin as an extension to the PostgreSQL DBMS. This prototype outperforms conventional commercial systems by an order of magnitude for tens to hundreds of concurrent queries.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0220-3">A unified approach to ranking in probabilistic databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0220-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jian+Li%22">Jian Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Barna+Saha%22">Barna Saha</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amol+Deshpande%22">Amol Deshpande</a></li></ol>
          <input type="checkbox" id="76290"/>
          <label for="76290">Abstract</label>
          <div>Ranking is a fundamental operation in data analysis and decision support and plays an even more crucial role if the dataset being explored exhibits uncertainty. This has led to much work in understanding how to rank the tuples in a probabilistic dataset in recent years. In this article, we present a unified approach to ranking and top-k query processing in probabilistic databases by viewing it as a multi-criterion optimization problem and by deriving a set of features that capture the key properties of a probabilistic dataset that dictate the ranked result. We contend that a single, specific ranking function may not suffice for probabilistic databases, and we instead propose two parameterized ranking functions, called PRF ω and PRF e, that generalize or can approximate many of the previously proposed ranking functions. We present novel generating functions-based algorithms for efficiently ranking large datasets according to these ranking functions, even if the datasets exhibit complex correlations modeled using probabilistic and/xor trees or Markov networks. We further propose that the parameters of the ranking function be learned from user preferences, and we develop an approach to learn those parameters. Finally, we present a comprehensive experimental study that illustrates the effectiveness of our parameterized ranking functions, especially PRF e, at approximating other ranking functions and the scalability of our proposed algorithms for exact or approximate ranking.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-011-0226-x">Normalization and optimization of schema mappings</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-011-0226-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Georg+Gottlob%22">Georg Gottlob</a></li><li><a href="http://link.springer.com/search?facet-author=%22Reinhard+Pichler%22">Reinhard Pichler</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vadim+Savenkov%22">Vadim Savenkov</a></li></ol>
          <input type="checkbox" id="75776"/>
          <label for="75776">Abstract</label>
          <div>Schema mappings are high-level specifications that describe the relationship between database schemas. They are an important tool in several areas of database research, notably in data integration and data exchange. However, a concrete theory of schema mapping optimization including the formulation of optimality criteria and the construction of algorithms for computing optimal schema mappings is completely lacking to date. The goal of this work is to fill this gap. We start by presenting a system of rewrite rules to minimize sets of source-to-target tuple-generating dependencies. Moreover, we show that the result of this minimization is unique up to variable renaming. Hence, our optimization also yields a schema mapping normalization. By appropriately extending our rewrite rule system, we also provide a normalization of schema mappings containing equality-generating target dependencies. An important application of such a normalization is in the area of defining the semantics of query answering in data exchange, since several definitions in this area depend on the concrete syntactic representation of the mappings. This is, in particular, the case for queries with negated atoms and for aggregate queries. The normalization of schema mappings allows us to eliminate the effect of the concrete syntactic representation of the mapping from the semantics of query answering. We discuss in detail how our results can be fruitfully applied to aggregate queries.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (February 2011)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0188-4">Providing built-in keyword search capabilities in RDBMS</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0188-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Guoliang+Li%22">Guoliang Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianhua+Feng%22">Jianhua Feng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianyong+Wang%22">Jianyong Wang</a></li></ol>
          <input type="checkbox" id="91958"/>
          <label for="91958">Abstract</label>
          <div>A common approach to performing keyword search over relational databases is to find the minimum Steiner trees in database graphs transformed from relational data. These methods, however, are rather expensive as the minimum Steiner tree problem is known to be NP-hard. Further, these methods are independent of the underlying relational database management system (RDBMS), thus cannot benefit from the capabilities of the RDBMS. As an alternative, in this paper we propose a new concept called Compact Steiner Tree (CSTree), which can be used to approximate the Steiner tree problem for answering top-k keyword queries efficiently. We propose a novel structure-aware index, together with an effective ranking mechanism for fast, progressive and accurate retrieval of top-k highest ranked CSTrees. The proposed techniques can be implemented using a standard relational RDBMS to benefit from its indexing and query-processing capability. We have implemented our techniques in MYSQL, which can provide built-in keyword-search capabilities using SQL. The experimental results show a significant improvement in both search efficiency and result quality comparing to existing state-of-the-art approaches.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0189-3">Speed up kernel discriminant analysis</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0189-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Deng+Cai%22">Deng Cai</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofei+He%22">Xiaofei He</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiawei+Han%22">Jiawei Han</a></li></ol>
          <input type="checkbox" id="18665"/>
          <label for="18665">Abstract</label>
          <div>Linear discriminant analysis (LDA) has been a popular method for dimensionality reduction, which preserves class separability. The projection vectors are commonly obtained by maximizing the between-class covariance and simultaneously minimizing the within-class covariance. LDA can be performed either in the original input space or in the reproducing kernel Hilbert space (RKHS) into which data points are mapped, which leads to kernel discriminant analysis (KDA). When the data are highly nonlinear distributed, KDA can achieve better performance than LDA. However, computing the projective functions in KDA involves eigen-decomposition of kernel matrix, which is very expensive when a large number of training samples exist. In this paper, we present a new algorithm for kernel discriminant analysis, called Spectral Regression Kernel Discriminant Analysis (SRKDA). By using spectral graph analysis, SRKDA casts discriminant analysis into a regression framework, which facilitates both efficient computation and the use of regularization techniques. Specifically, SRKDA only needs to solve a set of regularized regression problems, and there is no eigenvector computation involved, which is a huge save of computational cost. The new formulation makes it very easy to develop incremental version of the algorithm, which can fully utilize the computational results of the existing training samples. Moreover, it is easy to produce sparse projections (Sparse KDA) with a L 1-norm regularizer. Extensive experiments on spoken letter, handwritten digit image and face image data demonstrate the effectiveness and efficiency of the proposed algorithm.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0190-x">Scalable keyword search on large data streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0190-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Lu+Qin%22">Lu Qin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lijun+Chang%22">Lijun Chang</a></li></ol>
          <input type="checkbox" id="32188"/>
          <label for="32188">Abstract</label>
          <div>It is widely recognized that the integration of information retrieval (IR) and database (DB) techniques provides users with a broad range of high quality services. Along this direction, IR-styled m-keyword query processing over a relational database in an rdbms framework has been well studied. It finds all hidden interconnected tuple structures, for example connected trees that contain keywords and are interconnected by sequences of primary/foreign key relationships among tuples. A new challenging issue is how to monitor events that are implicitly interrelated over an open-ended relational data stream for a user-given m-keyword query. Such a relational data stream is a sequence of tuple insertion/deletion operations. The difficulty of the problem is related to the number of costly joins to be processed over time when tuples are inserted and/or deleted. Such cost is mainly affected by three parameters, namely, the number of keywords, the maximum size of interconnected tuple structures, and the complexity of the database schema when it is viewed as a schema graph. In this paper, we propose new approaches. First, we propose a novel algorithm to efficiently determine all the joins that need to be processed for answering an m-keyword query. Second, we propose a new demand-driven approach to process such a query over a high speed relational data stream. We show that we can achieve high efficiency by significantly reducing the number of intermediate results when processing joins over a relational data stream. The proposed new techniques allow us to achieve high scalability in terms of both query plan generation and query plan execution. We conducted extensive experimental studies using synthetic data and real data to simulate a relational data stream. Our approach significantly outperforms existing algorithms.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0191-9">SABRE: a Sensitive Attribute Bucketization and REdistribution framework for t-closeness</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0191-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jianneng+Cao%22">Jianneng Cao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Panagiotis+Karras%22">Panagiotis Karras</a></li><li><a href="http://link.springer.com/search?facet-author=%22Panos+Kalnis%22">Panos Kalnis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li></ol>
          <input type="checkbox" id="67886"/>
          <label for="67886">Abstract</label>
          <div>Today, the publication of microdata poses a privacy threat: anonymous personal records can be re-identified using third data sources. Past research has tried to develop a concept of privacy guarantee that an anonymized data set should satisfy before publication, culminating in the notion of t-closeness. To satisfy t-closeness, the records in a data set need to be grouped into Equivalence Classes (ECs), such that each EC contains records of indistinguishable quasi-identifier values, and its local distribution of sensitive attribute (SA) values conforms to the global table distribution of SA values. However, despite this progress, previous research has not offered an anonymization algorithm tailored for t-closeness. In this paper, we cover this gap with SABRE, a SA Bucketization and REdistribution framework for t-closeness. SABRE first greedily partitions a table into buckets of similar SA values and then redistributes the tuples of each bucket into dynamically determined ECs. This approach is facilitated by a property of the Earth Mover’s Distance (EMD) that we employ as a measure of distribution closeness: If the tuples in an EC are picked proportionally to the sizes of the buckets they hail from, then the EMD of that EC is tightly upper-bounded using localized upper bounds derived for each bucket. We prove that if the t-closeness constraint is properly obeyed during partitioning, then it is obeyed by the derived ECs too. We develop two instantiations of SABRE and extend it to a streaming environment. Our extensive experimental evaluation demonstrates that SABRE achieves information quality superior to schemes that merely applied algorithms tailored for other models to t-closeness, and can be much faster as well.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0192-8">Local and global recoding methods for anonymizing set-valued data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0192-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Manolis+Terrovitis%22">Manolis Terrovitis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nikos+Mamoulis%22">Nikos Mamoulis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Panos+Kalnis%22">Panos Kalnis</a></li></ol>
          <input type="checkbox" id="27150"/>
          <label for="27150">Abstract</label>
          <div>In this paper, we study the problem of protecting privacy in the publication of set-valued data. Consider a collection of supermarket transactions that contains detailed information about items bought together by individuals. Even after removing all personal characteristics of the buyer, which can serve as links to his identity, the publication of such data is still subject to privacy attacks from adversaries who have partial knowledge about the set. Unlike most previous works, we do not distinguish data as sensitive and non-sensitive, but we consider them both as potential quasi-identifiers and potential sensitive data, depending on the knowledge of the adversary. We define a new version of the k-anonymity guarantee, the k m -anonymity, to limit the effects of the data dimensionality, and we propose efficient algorithms to transform the database. Our anonymization model relies on generalization instead of suppression, which is the most common practice in related works on such data. We develop an algorithm that finds the optimal solution, however, at a high cost that makes it inapplicable for large, realistic problems. Then, we propose a greedy heuristic, which performs generalizations in an Apriori, level-wise fashion. The heuristic scales much better and in most of the cases finds a solution close to the optimal. Finally, we investigate the application of techniques that partition the database and perform anonymization locally, aiming at the reduction of the memory consumption and further scalability. A thorough experimental evaluation with real datasets shows that a vertical partitioning approach achieves excellent results in practice.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0195-5">Probabilistic inverse ranking queries in uncertain databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0195-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xiang+Lian%22">Xiang Lian</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li></ol>
          <input type="checkbox" id="87069"/>
          <label for="87069">Abstract</label>
          <div>Query processing in the uncertain database has become increasingly important due to the wide existence of uncertain data in many real applications. Different from handling precise data, the uncertain query processing needs to consider the data uncertainty and answer queries with confidence guarantees. In this paper, we formulate and tackle an important query, namely probabilistic inverse ranking (PIR) query, which retrieves possible ranks of a given query object in an uncertain database with confidence above a probability threshold. We present effective pruning methods to reduce the PIR search space, which can be seamlessly integrated into an efficient query procedure. Moreover, we tackle the problem of PIR query processing in high dimensional spaces, which reduces high dimensional uncertain data to a lower dimensional space. Furthermore, we study three interesting and useful aggregate PIR queries, that is, MAX, top-m, and AVG  PIRs. Moreover, we also study an important query type, PIR with uncertain query object (namely UQ-PIR), and design specific rules to facilitate the pruning. Extensive experiments have demonstrated the efficiency and effectiveness of our proposed approaches over both real and synthetic data sets, under various experimental settings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0196-4">Ranking queries on uncertain data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0196-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ming+Hua%22">Ming Hua</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jian+Pei%22">Jian Pei</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li></ol>
          <input type="checkbox" id="10906"/>
          <label for="10906">Abstract</label>
          <div>Uncertain data is inherent in a few important applications. It is far from trivial to extend ranking queries (also known as top-k queries), a popular type of queries on certain data, to uncertain data. In this paper, we cast ranking queries on uncertain data using three parameters: rank threshold k, probability threshold p, and answer set size threshold l. Systematically, we identify four types of ranking queries on uncertain data. First, a probability threshold top-k query computes the uncertain records taking a probability of at least p to be in the top-k list. Second, a top-(k, l) query returns the top-l uncertain records whose probabilities of being ranked among top-k are the largest. Third, the p-rank of an uncertain record is the smallest number k such that the record takes a probability of at least p to be ranked in the top-k list. A rank threshold top-k query retrieves the records whose p-ranks are at most k. Last, a top-(p, l) query returns the top-l uncertain records with the smallest p-ranks. To answer such ranking queries, we present an efficient exact algorithm, a fast sampling algorithm, and a Poisson approximation-based algorithm. To answer top-(k, l) queries and top-(p, l) queries, we propose PRist+, a compact index. An efficient index construction algorithm and efficacious query answering methods are developed for PRist+. An empirical study using real and synthetic data sets verifies the effectiveness of the probabilistic ranking queries and the efficiency of our methods.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 19 (February 2010 - December 2010)</h1>
          <ol><li>
          <h2>Issue 6 (December 2010)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0201-y">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0201-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Klemens+B%C3%B6hm%22">Klemens Böhm</a></li><li><a href="http://link.springer.com/search?facet-author=%22Laks+V.+S.+Lakshmanan%22">Laks V. S. Lakshmanan</a></li></ol>
          <input type="checkbox" id="70760"/>
          <label for="70760">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0211-9">Social bookmark weighting for search and recommendation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0211-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22David+Carmel%22">David Carmel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Haggai+Roitman%22">Haggai Roitman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Elad+Yom-Tov%22">Elad Yom-Tov</a></li></ol>
          <input type="checkbox" id="29702"/>
          <label for="29702">Abstract</label>
          <div>Social bookmarking enables knowledge sharing and efficient discovery on the web, where users can collaborate together by tagging documents of interests. A lot of attention was given lately for utilizing social bookmarking data to enhance traditional IR tasks. Yet, much less attention was given to the problem of estimating the effectiveness of an individual bookmark for the specific tasks. In this work, we propose a novel framework for social bookmark weighting which allows us to estimate the effectiveness of each of the bookmarks individually for several IR tasks. We show that by weighting bookmarks according to their estimated quality, we can significantly improve social search effectiveness. We further demonstrate that using the same framework, we can derive solutions to several recommendation tasks such as tag recommendation, user recommendation, and document recommendation. Empirical evaluation on real data gathered from two large bookmarking systems demonstrates the effectiveness of the new social bookmark weighting framework.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0193-7">Privacy policies for shared content in social network sites</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0193-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Anna+C.+Squicciarini%22">Anna C. Squicciarini</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+Shehab%22">Mohamed Shehab</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joshua+Wede%22">Joshua Wede</a></li></ol>
          <input type="checkbox" id="70747"/>
          <label for="70747">Abstract</label>
          <div>Social networking is one of the major technological phenomena of the Web 2.0, with hundreds of millions of subscribed users. Social networks enable a form of self-expression for users and help them to socialize and share content with other users. In spite of the fact that content sharing represents one of the prominent features of existing Social network sites, they do not provide any mechanisms for collective management of privacy settings for shared content. In this paper, using game theory, we model the problem of collective enforcement of privacy policies on shared data. In particular, we propose a solution that offers automated ways to share images based on an extended notion of content ownership. Building upon the Clarke-Tax mechanism, we describe a simple mechanism that promotes truthfulness and that rewards users who promote co-ownership. Our approach enables social network users to compose friendship based policies based on distances from an agreed upon central user selected using several social networks metrics. We integrate our design with inference techniques that free the users from the burden of manually selecting privacy preferences for each picture. To the best of our knowledge, this is the first time such a privacy protection mechanism for social networking has been proposed. We also extend our mechanism so as to support collective enforcement across multiple social network sites. In the paper, we also show a proof-of-concept application, which we implemented in the context of Facebook, one of today’s most popular social networks. Through our implementation, we show the feasibility of such approach and show that it can be implemented with a minimal increase in overhead to end-users. We complete our analysis by conducting a user study to investigate users’ understanding of co-ownership, usefulness and understanding of our approach. Users responded favorably to the approach, indicating a general understanding of co-ownership and the auction, and found the approach to be both useful and fair.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0210-x">Resisting structural re-identification in anonymized social networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0210-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Michael+Hay%22">Michael Hay</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerome+Miklau%22">Gerome Miklau</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Jensen%22">David Jensen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Don+Towsley%22">Don Towsley</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chao+Li%22">Chao Li</a></li></ol>
          <input type="checkbox" id="17696"/>
          <label for="17696">Abstract</label>
          <div>We identify privacy risks associated with releasing network datasets and provide an algorithm that mitigates those risks. A network dataset is a graph representing entities connected by edges representing relations such as friendship, communication or shared activity. Maintaining privacy when publishing a network dataset is uniquely challenging because an individual’s network context can be used to identify them even if other identifying information is removed. In this paper, we introduce a parameterized model of structural knowledge available to the adversary and quantify the success of attacks on individuals in anonymized networks. We show that the risks of these attacks vary based on network structure and size and provide theoretical results that explain the anonymity risk in random networks. We then propose a novel approach to anonymizing network data that models aggregate network structure and allows analysis to be performed by sampling from the model. The approach guarantees anonymity for entities in the network while allowing accurate estimates of a variety of network measures with relatively little bias.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0207-5">Multimodal social intelligence in a real-time dashboard system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0207-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniel+Gruhl%22">Daniel Gruhl</a></li><li><a href="http://link.springer.com/search?facet-author=%22Meena+Nagarajan%22">Meena Nagarajan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jan+Pieper%22">Jan Pieper</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christine+Robson%22">Christine Robson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amit+Sheth%22">Amit Sheth</a></li></ol>
          <input type="checkbox" id="35778"/>
          <label for="35778">Abstract</label>
          <div>Social Networks provide one of the most rapidly evolving data sets in existence today. Traditional Business Intelligence applications struggle to take advantage of such data sets in a timely manner. The BBC SoundIndex, developed by the authors and others, enabled real-time analytics of music popularity using data from a variety of Social Networks. We present this system as a grounding example of how to overcome the challenges of working with this data from social networks. We discuss a variety of technologies to implement near real-time data analytics to transform Social Intelligence into Business Intelligence and evaluate their effectiveness in the music domain. The SoundIndex project helped to highlight a number of key research areas, including named entity recognition and sentiment analysis in Informal English. It also drew attention to the importance of metadata aggregation in multimodal environments. We explored challenges such as drawing data from a wide set of sources spanning a myriad of modalities, developing adjudication techniques to harmonize inputs, and performing deep analytics on extremely challenging Informal English snippets. Ultimately, we seek to provide guidance on developing applications in a variety of domains that allow an analyst to rapidly grasp the evolution in the social landscape, and show how to validate such a system for a real-world application.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0208-4">The social bookmark and publication management system bibsonomy</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0208-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dominik+Benz%22">Dominik Benz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andreas+Hotho%22">Andreas Hotho</a></li><li><a href="http://link.springer.com/search?facet-author=%22Robert+J%C3%A4schke%22">Robert Jäschke</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beate+Krause%22">Beate Krause</a></li><li><a href="http://link.springer.com/search?facet-author=%22Folke+Mitzlaff%22">Folke Mitzlaff</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christoph+Schmitz%22">Christoph Schmitz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerd+Stumme%22">Gerd Stumme</a></li></ol>
          <input type="checkbox" id="25206"/>
          <label for="25206">Abstract</label>
          <div>Social resource sharing systems are central elements of the Web 2.0 and use the same kind of lightweight knowledge representation, called folksonomy. Their large user communities and ever-growing networks of user-generated content have made them an attractive object of investigation for researchers from different disciplines like Social Network Analysis, Data Mining, Information Retrieval or Knowledge Discovery. In this paper, we summarize and extend our work on different aspects of this branch of Web 2.0 research, demonstrated and evaluated within our own social bookmark and publication sharing system BibSonomy, which is currently among the three most popular systems of its kind. We structure this presentation along the different interaction phases of a user with our system, coupling the relevant research questions of each phase with the corresponding implementation issues. This approach reveals in a systematic fashion important aspects and results of the broad bandwidth of folksonomy research like capturing of emergent semantics, spam detection, ranking algorithms, analogies to search engine log data, personalized tag recommendations and information extraction techniques. We conclude that when integrating a real-life application like BibSonomy into research, certain constraints have to be considered; but in general, the tight interplay between our scientific work and the running system has made BibSonomy a valuable platform for demonstrating and evaluating Web 2.0 research.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0209-3">Space efficiency in group recommendation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0209-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Senjuti+Basu+Roy%22">Senjuti Basu Roy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sihem+Amer-Yahia%22">Sihem Amer-Yahia</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ashish+Chawla%22">Ashish Chawla</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gautam+Das%22">Gautam Das</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cong+Yu%22">Cong Yu</a></li></ol>
          <input type="checkbox" id="20118"/>
          <label for="20118">Abstract</label>
          <div>Imagine a system that gives you satisfying recommendations when you want to rent a movie with friends or find a restaurant to celebrate a colleague’s farewell: at the core of such a system is what we call group recommendation. While computing individual recommendations have received lots of attention (e.g., Netflix prize), group recommendation has been confined to studying users’ satisfaction with different aggregation strategies. In this paper (Some results are published in an earlier conference paper (Amer-Yahia et al. in VLDB, 2009). See Sect. “Paper contributions and outline” for details.), we describe the challenges and desiderata of group recommendation and formalize different group consensus semantics that account for both an item’s predicted ratings to the group members and the disagreements among them. We focus on the design and implementation of efficient group recommendation algorithms that intelligently prune and merge per-user predicted rating lists and pairwise disagreement lists of items. We further explore the impact of space constraints on maintaining per-user and pairwise item lists and develop two complementary solutions that leverage shared user behavior to maintain the efficiency of our recommendation algorithms within a space budget. The first solution, behavior factoring, factors out user agreements from disagreement lists, while the second solution, partial materialization, selectively materializes a subset of disagreement lists. Finally, we demonstrate the usefulness of our group recommendations and the efficiency and scalability of our algorithms using an extensive set of experiments on the 10 M ratings MovieLens data set.</div>
        </li></ul>
        </li><li>
          <h2>Issue 5 (October 2010)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0182-x">A motion-aware approach for efficient evaluation of continuous queries on 3D object databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0182-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mohammed+Eunus+Ali%22">Mohammed Eunus Ali</a></li><li><a href="http://link.springer.com/search?facet-author=%22Egemen+Tanin%22">Egemen Tanin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rui+Zhang%22">Rui Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lars+Kulik%22">Lars Kulik</a></li></ol>
          <input type="checkbox" id="94089"/>
          <label for="94089">Abstract</label>
          <div>With recent advances in mobile computing technologies, mobile devices can render 3D objects realistically. Users of these devices such as tourists, mixed-reality gamers, and rescue officers, often need real-time retrieval of 3D objects over wireless networks. Due to bandwidth and latency restrictions in mobile settings, efficient continuous retrieval of 3D objects is a major challenge. In this paper, we present a motion-aware approach to this problem in a client-server model. Specifically, we propose: (i) representing 3D objects in multiple resolutions through wavelets to facilitate motion-aware incremental retrieval, (ii) motion-aware buffer management schemes for both client and server, (iii) an efficient index structure for 3D objects represented by wavelets, and (iv) techniques for processing group queries exploiting group motion behavior of clients. The results of our extensive experimental study demonstrate the effectiveness of our solution.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0183-9">Engineering scalable, cache and space efficient tries for strings</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0183-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nikolas+Askitis%22">Nikolas Askitis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ranjan+Sinha%22">Ranjan Sinha</a></li></ol>
          <input type="checkbox" id="8087"/>
          <label for="8087">Abstract</label>
          <div>Storing and retrieving strings in main memory is a fundamental problem in computer science. The efficiency of string data structures used for this task is of paramount importance for applications such as in-memory databases, text-based search engines and dictionaries. The burst trie is a leading choice for such tasks, as it can provide fast sorted access to strings. The burst trie, however, uses linked lists as substructures which can result in poor use of CPU cache and main memory. Previous research addressed this issue by replacing linked lists with dynamic arrays forming a cache-conscious array burst trie. Though faster, this variant can incur high instruction costs which can hinder its efficiency. Thus, engineering a fast, compact, and scalable trie for strings remains an open problem. In this paper, we introduce a novel and practical solution that carefully combines a trie with a hash table, creating a variant of burst trie called HAT-trie. We provide a thorough experimental analysis which demonstrates that for large set of strings and on alternative computing architectures, the HAT-trie—and two novel variants engineered to achieve further space-efficiency—is currently the leading in-memory trie-based data structure offering rapid, compact, and scalable storage and retrieval of variable-length strings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0184-8">Efficient evaluation of generalized tree-pattern queries on XML streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0184-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xiaoying+Wu%22">Xiaoying Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitri+Theodoratos%22">Dimitri Theodoratos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Calisto+Zuzarte%22">Calisto Zuzarte</a></li></ol>
          <input type="checkbox" id="94726"/>
          <label for="94726">Abstract</label>
          <div>The streaming evaluation is a popular way of evaluating queries on XML documents. Besides its many advantages, it is also the only option for a number of important XML applications. Unfortunately, existing algorithms focus almost exclusively on tree-pattern queries (TPQs). Requirements for flexible querying of XML data have motivated recently the introduction of query languages that are more general and flexible than TPQs. These languages are not supported by existing algorithms. In this paper, we consider a partial tree-pattern query (PTPQ) language which generalizes and strictly contains TPQs. PTPQs can express a fragment of XPath which comprises reverse axes and the node identity equality (is) operator, in addition to forward axes, wildcards and predicates. They constitute an important subclass of XPath, which is very useful in practice. Unfortunately, previous streaming algorithms for TPQs cannot be applied to PTPQs. PTPQs can be represented as dags enhanced with constraints. We explore this representation to design an original polynomial time streaming algorithm for PTPQs. Our algorithm aggressively filters incoming data that is irrelevant to the query and wisely avoids processing redundant query matches (i.e., matches of the query dag that do not contribute to new solutions). Our algorithm is the first one to support the streaming evaluation of such a broad fragment of XPath. We provide an analysis of it, and conduct an extensive experimental evaluation of its performance and scalability. Compared to the only known streaming algorithm that supports TPQs extended with reverse axes, our algorithm performs better by orders of magnitude while consuming a much smaller fraction of memory space. Current streaming applications have stringent requirements on query response time and memory consumption because of the large (possibly unbounded) size of data they handle. In order to keep memory usage and CPU consumption low for the PTPQ streaming evaluation, we design another streaming algorithm called Eager PSX for PTPQs. Its key feature is that it applies an eager evaluation strategy to quickly determine when node matches should be returned as solutions to the user and also to proactively detect redundant matches. We theoretically analyze Eager PSX, and experimentally test its time and space performance and scalability. We compare it with PSX. Our results show that Eager PSX not only achieves better space performance without compromising time performance, but it also greatly improves query response time for both simple and complex queries, in many cases, by orders of magnitude.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0185-7">Efficient k-nearest neighbor search on moving object trajectories</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0185-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ralf+Hartmut+G%C3%BCting%22">Ralf Hartmut Güting</a></li><li><a href="http://link.springer.com/search?facet-author=%22Thomas+Behr%22">Thomas Behr</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianqiu+Xu%22">Jianqiu Xu</a></li></ol>
          <input type="checkbox" id="19513"/>
          <label for="19513">Abstract</label>
          <div>With the growing number of mobile applications, data analysis on large sets of historical moving objects trajectories becomes increasingly important. Nearest neighbor search is a fundamental problem in spatial and spatio-temporal databases. In this paper, we consider the following problem: Given a set of moving object trajectories D and a query trajectory mq, find the k nearest neighbors to mq within D for any instant of time within the lifetime of mq. We assume D is indexed in a 3D-R-tree and employ a filter-and-refine strategy. The filter step traverses the index and creates a stream of so-called units (linear pieces of a trajectory) as a superset of the units required to build the result of the query. The refinement step processes an ordered stream of units and determines the pieces of units forming the precise result. To support the filter step, for each node p of the index, in preprocessing a time-dependent coverage function C p (t) is computed which is the number of trajectories represented in p present at time t. Within the filter step, sophisticated data structures are used to keep track of the aggregated coverages of the nodes seen so far in the index traversal to enable pruning. Moreover, the R-tree index is built in a special way to obtain coverage functions that are effective for pruning. As a result, one obtains a highly efficient kNN algorithm for moving data and query points that outperforms the two competing algorithms by a wide margin. Implementations of the new algorithms and of the competing techniques are made available as well. Algorithms can be used in a system context including, for example, visualization and animation of results. Experiments of the paper can be easily checked or repeated, and new experiments be performed.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0186-6">Top-k queries on temporal data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0186-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Feifei+Li%22">Feifei Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ke+Yi%22">Ke Yi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wangchao+Le%22">Wangchao Le</a></li></ol>
          <input type="checkbox" id="85316"/>
          <label for="85316">Abstract</label>
          <div>The database community has devoted extensive amount of efforts to indexing and querying temporal data in the past decades. However, insufficient amount of attention has been paid to temporal ranking queries. More precisely, given any time instance t, the query asks for the top-k objects at time t with respect to some score attribute. Some generic indexing structures based on R-trees do support ranking queries on temporal data, but as they are not tailored for such queries, the performance is far from satisfactory. We present the Seb-tree, a simple indexing scheme that supports temporal ranking queries much more efficiently. The Seb-tree answers a top-k query for any time instance t in the optimal number of I/Os in expectation, namely, ${O\left({\rm log}_B\,\frac{N}{B}+\frac{k}{B}\right)}$ I/Os, where N is the size of the data set and B is the disk block size. The index has near-linear size (for constant and reasonable k max values, where k max is the maximum value for the possible values of the query parameter k), can be constructed in near-linear time, and also supports insertions and deletions without affecting its query performance guarantee. Most of all, the Seb-tree is especially appealing in practice due to its simplicity as it uses the B-tree as the only building block. Extensive experiments on a number of large data sets, show that the Seb-tree is more than an order of magnitude faster than the R-tree based indexes for temporal ranking queries.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0187-5">Predicate-based indexing for desktop search</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0187-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Cristian+Duda%22">Cristian Duda</a></li><li><a href="http://link.springer.com/search?facet-author=%22Donald+Kossmann%22">Donald Kossmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chong+Zhou%22">Chong Zhou</a></li></ol>
          <input type="checkbox" id="58607"/>
          <label for="58607">Abstract</label>
          <div>Google and other products have revolutionized the way we search for information. There are, however, still a number of research challenges. One challenge that arises specifically in desktop search is to exploit the structure and semantics of documents, as defined by the application program that generated the data (e.g., Word, Excel, or Outlook). The current generation of search products does not understand these structures and therefore often returns wrong results. This paper shows how today’s search technology can be extended in order to take the specific semantics of certain structures into account. The key idea is to extend inverted file index structures with predicates which encode the circumstances under which certain keywords of a document become visible to a user. This paper provides a framework that allows to express the semantics of structures in documents and algorithms to construct enhanced, predicate-based indexes. Furthermore, this paper shows how keyword and phrase queries can be processed efficiently on such enhanced indexes. It is shown that the proposed approach has superior retrieval performance with regard to both recall and precision and has tolerable space and query running time overheads.</div>
        </li></ul>
        </li><li>
          <h2>Issue 4 (August 2010)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0175-9">Efficient privacy-preserving similar document detection</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0175-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mummoorthy+Murugesan%22">Mummoorthy Murugesan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wei+Jiang%22">Wei Jiang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chris+Clifton%22">Chris Clifton</a></li><li><a href="http://link.springer.com/search?facet-author=%22Luo+Si%22">Luo Si</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jaideep+Vaidya%22">Jaideep Vaidya</a></li></ol>
          <input type="checkbox" id="93397"/>
          <label for="93397">Abstract</label>
          <div>Similar document detection plays important roles in many applications, such as file management, copyright protection, plagiarism prevention, and duplicate submission detection. The state of the art protocols assume that the contents of files stored on a server (or multiple servers) are directly accessible. However, this makes such protocols unsuitable for any environment where the documents themselves are sensitive and cannot be openly read. Essentially, this assumption limits more practical applications, e.g., detecting plagiarized documents between two conferences, where submissions are confidential. We propose novel protocols to detect similar documents between two entities where documents cannot be openly shared with each other. The similarity measure used can be a simple cosine similarity on entire documents or on document fragments, enabling detection of partial copying. We conduct extensive experiments to show the practical value of the proposed protocols. While the proposed base protocols are much more efficient than the general secure multiparty computation based solutions, they are still slow for large document sets. We then investigate a clustering based approach that significantly reduces the running time and achieves over 90% of accuracy in our experiments. This makes secure similar document detection both practical and feasible.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0176-8">Supporting ranking queries on uncertain and incomplete data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0176-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+A.+Soliman%22">Mohamed A. Soliman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ihab+F.+Ilyas%22">Ihab F. Ilyas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shalev+Ben-David%22">Shalev Ben-David</a></li></ol>
          <input type="checkbox" id="70753"/>
          <label for="70753">Abstract</label>
          <div>Large databases with uncertain information are becoming more common in many applications including data integration, location tracking, and Web search. In these applications, ranking records with uncertain attributes introduces new problems that are fundamentally different from conventional ranking. Specifically, uncertainty in records’ scores induces a partial order over records, as opposed to the total order that is assumed in the conventional ranking settings. In this paper, we present a new probabilistic model, based on partial orders, to encapsulate the space of possible rankings originating from score uncertainty. Under this model, we formulate several ranking query types with different semantics. We describe and analyze a set of efficient query evaluation algorithms. We show that our techniques can be used to solve the problem of rank aggregation in partial orders under two widely adopted distance metrics. In addition, we design sampling techniques based on Markov chains to compute approximate query answers. Our experimental evaluation uses both real and synthetic data. The experimental study demonstrates the efficiency and effectiveness of our techniques under various configurations.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0177-7">Structural consistency: enabling XML keyword search to eliminate spurious results consistently</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0177-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ki-Hoon+Lee%22">Ki-Hoon Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyu-Young+Whang%22">Kyu-Young Whang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wook-Shin+Han%22">Wook-Shin Han</a></li><li><a href="http://link.springer.com/search?facet-author=%22Min-Soo+Kim%22">Min-Soo Kim</a></li></ol>
          <input type="checkbox" id="49024"/>
          <label for="49024">Abstract</label>
          <div>XML keyword search is a user-friendly way to query XML data using only keywords. In XML keyword search, to achieve high precision without sacrificing recall, it is important to remove spurious results not intended by the user. Efforts to eliminate spurious results have enjoyed some success using the concepts of LCA or its variants, SLCA and MLCA. However, existing methods still could find many spurious results. The fundamental cause for the occurrence of spurious results is that the existing methods try to eliminate spurious results locally without global examination of all the query results and, accordingly, some spurious results are not consistently eliminated. In this paper, we propose a novel keyword search method that removes spurious results consistently by exploiting the new concept of structural consistency. We define structural consistency as a property that is preserved if there is no query result having an ancestor-descendant relationship at the schema level with any other query results. A naive solution to obtain structural consistency would be to compute all the LCAs (or variants) and then to remove spurious results according to structural consistency. Obviously, this approach would always be slower than existing LCA-based ones. To speed up structural consistency checking, we must be able to examine the query results at the schema level without generating all the LCAs. However, this is a challenging problem since the schema-level query results do not homomorphically map to the instance-level query results, causing serious false dismissal. We present a comprehensive and practical solution to this problem and formally prove that this solution preserves structural consistency at the schema level without incurring false dismissal. We also propose a relevance-feedback-based solution for the problem where our method has low recall, which occurs when it is not the user’s intention to find more specific results. This solution has been prototyped in a full-fledged object-relational DBMS Odysseus developed at KAIST. Experimental results using real and synthetic data sets show that, compared with the state-of-the-art methods, our solution significantly (1) improves precision while providing comparable recall for most queries and (2) enhances the query performance by removing spurious results early.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0178-6">Rights protection of trajectory datasets with nearest-neighbor preservation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0178-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Claudio+Lucchese%22">Claudio Lucchese</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michail+Vlachos%22">Michail Vlachos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Deepak+Rajan%22">Deepak Rajan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li></ol>
          <input type="checkbox" id="11376"/>
          <label for="11376">Abstract</label>
          <div>Companies frequently outsource datasets to mining firms, and academic institutions create repositories or share datasets in the interest of promoting research collaboration. Still, many practitioners have reservations about sharing or outsourcing datasets, primarily because of fear of losing the principal rights over the dataset. This work presents a way of convincingly claiming ownership rights over a trajectory dataset, without, at the same time, destroying the salient dataset characteristics, which are important for accurate search operations and data-mining tasks. The digital watermarking methodology that we present distorts imperceptibly a collection of sequences, effectively embedding a secret key, while retaining as well as possible the neighborhood of each object, which is vital for operations such as similarity search, classification, or clustering. A key contribution in this methodology is a technique for discovering the maximum distortion that still maintains such desirable properties. We demonstrate both analytically and empirically that the proposed dataset marking techniques can withstand a number of attacks (such a translation, rotation, noise addition, etc) and therefore can provide a robust framework for facilitating the secure dissemination of trajectory datasets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0180-z">Streaming multiple aggregations using phantoms</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0180-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rui+Zhang%22">Rui Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Koudas%22">Nick Koudas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Divesh+Srivastava%22">Divesh Srivastava</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pu+Zhou%22">Pu Zhou</a></li></ol>
          <input type="checkbox" id="10742"/>
          <label for="10742">Abstract</label>
          <div>Data streams characterize the high speed and large volume input of a new class of applications such as network monitoring, web content analysis and sensor networks. Among these applications, network monitoring may be the most compelling one—the backbone of a large internet service provider can generate 1 petabyte of data per day. For many network monitoring tasks such as traffic analysis and statistics collection, aggregation is a primitive operation. Various analytical and statistical needs naturally lead to related aggregate queries. In this article, we address the problem of efficiently computing multiple aggregations over high-speed data streams based on the two-level query processing architecture of GS, a real data stream management system deployed in AT & T. We discern that additionally computing and maintaining fine-granularity aggregations (called phantoms) has the benefit of supporting shared computation. Based on a thorough analysis, we propose algorithms to identify the best set of phantoms to maintain and determine allocation of resources (particularly, space) to compute the aggregations. Experiments show that our algorithm achieves near-optimal computation costs, which outperforms the best adapted algorithm by more than an order of magnitude.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-010-0181-y">Path prediction and predictive range querying in road network databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-010-0181-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hoyoung+Jeung%22">Hoyoung Jeung</a></li><li><a href="http://link.springer.com/search?facet-author=%22Man+Lung+Yiu%22">Man Lung Yiu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li></ol>
          <input type="checkbox" id="91093"/>
          <label for="91093">Abstract</label>
          <div>In automotive applications, movement-path prediction enables the delivery of predictive and relevant services to drivers, e.g., reporting traffic conditions and gas stations along the route ahead. Path prediction also enables better results of predictive range queries and reduces the location update frequency in vehicle tracking while preserving accuracy. Existing moving-object location prediction techniques in spatial-network settings largely target short-term prediction that does not extend beyond the next road junction. To go beyond short-term prediction, we formulate a network mobility model that offers a concise representation of mobility statistics extracted from massive collections of historical object trajectories. The model aims to capture the turning patterns at junctions and the travel speeds on road segments at the level of individual objects. Based on the mobility model, we present a maximum likelihood and a greedy algorithm for predicting the travel path of an object (for a time duration h into the future). We also present a novel and efficient server-side indexing scheme that supports predictive range queries on the mobility statistics of the objects. Empirical studies with real data suggest that our proposals are effective and efficient.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (June 2010)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0163-0">Analysis and evaluation of V*-kNN: an efficient algorithm for moving kNN queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0163-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sarana+Nutanong%22">Sarana Nutanong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rui+Zhang%22">Rui Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Egemen+Tanin%22">Egemen Tanin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lars+Kulik%22">Lars Kulik</a></li></ol>
          <input type="checkbox" id="92252"/>
          <label for="92252">Abstract</label>
          <div>The moving k nearest neighbor (MkNN) query continuously finds the k nearest neighbors of a moving query point. MkNN queries can be efficiently processed through the use of safe regions. In general, a safe region is a region within which the query point can move without changing the query answer. This paper presents an incremental safe-region-based technique for answering MkNN queries, called the V*-Diagram, as well as analysis and evaluation of its associated algorithm, V*-kNN. Traditional safe-region approaches compute a safe region based on the data objects but independent of the query location. Our approach exploits the knowledge of the query location and the boundary of the search space in addition to the data objects. As a result, V*-kNN has much smaller I/O and computation costs than existing methods. We further provide cost models to estimate the number of data accesses for V*-kNN and a competitive technique, RIS-kNN. The V*-Diagram and V*-kNN are also applicable to the domain of spatial networks and we present algorithms to construct a spatial-network V*-Diagram. Our experimental results show that V*-kNN significantly outperforms the competitive technique. The results also verify the accuracy of the cost models.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0166-x">Z-SKY: an efficient skyline query processing framework based on Z-order</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0166-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ken+C.+K.+Lee%22">Ken C. K. Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wang-Chien+Lee%22">Wang-Chien Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Baihua+Zheng%22">Baihua Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Huajing+Li%22">Huajing Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yuan+Tian%22">Yuan Tian</a></li></ol>
          <input type="checkbox" id="92356"/>
          <label for="92356">Abstract</label>
          <div>Given a set of data points in a multidimensional space, a skyline query retrieves those data points that are not dominated by any other point in the same dataset. Observing that the properties of Z-order space filling curves (or Z-order curves) perfectly match with the dominance relationships among data points in a geometrical data space, we, in this paper, develop and present a novel and efficient processing framework to evaluate skyline queries and their variants, and to support skyline result updates based on Z-order curves. This framework consists of ZBtree, i.e., an index structure to organize a source dataset and skyline candidates, and a suite of algorithms, namely, (1) ZSearch, which processes skyline queries, (2) ZInsert, ZDelete and ZUpdate, which incrementally maintain skyline results in presence of source dataset updates, (3) ZBand, which answers skyband queries, (4) ZRank, which returns top-ranked skyline points, (5) k-ZSearch, which evaluates k-dominant skyline queries, and (6) ZSubspace, which supports skyline queries on a subset of dimensions. While derived upon coherent ideas and concepts, our approaches are shown to outperform the state-of-the-art algorithms that are specialized to address particular skyline problems, especially when a large number of skyline points are resulted, via comprehensive experiments.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0169-7">Enabling search services on outsourced private spatial data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0169-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Man+Lung+Yiu%22">Man Lung Yiu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gabriel+Ghinita%22">Gabriel Ghinita</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Panos+Kalnis%22">Panos Kalnis</a></li></ol>
          <input type="checkbox" id="20724"/>
          <label for="20724">Abstract</label>
          <div>Cloud computing services enable organizations and individuals to outsource the management of their data to a service provider in order to save on hardware investments and reduce maintenance costs. Only authorized users are allowed to access the data. Nobody else, including the service provider, should be able to view the data. For instance, a real-estate company that owns a large database of properties wants to allow its paying customers to query for houses according to location. On the other hand, the untrusted service provider should not be able to learn the property locations and, e.g., selling the information to a competitor. To tackle the problem, we propose to transform the location datasets before uploading them to the service provider. The paper develops a spatial transformation that re-distributes the locations in space, and it also proposes a cryptographic-based transformation. The data owner selects the transformation key and shares it with authorized users. Without the key, it is infeasible to reconstruct the original data points from the transformed points. The proposed transformations present distinct trade-offs between query efficiency and data confidentiality. In addition, we describe attack models for studying the security properties of the transformations. Empirical studies demonstrate that the proposed methods are efficient and applicable in practice.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0170-1">Suppressing microdata to prevent classification based inference</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0170-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ay%C3%A7a+Azgin+Hintoglu%22">Ayça Azgin Hintoglu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Y%C3%BCcel+Sayg%C4%B1n%22">Yücel Saygın</a></li></ol>
          <input type="checkbox" id="94627"/>
          <label for="94627">Abstract</label>
          <div>The revolution of the Internet together with the progression in computer technology makes it easy for institutions to collect an unprecedented amount of personal data. This pervasive data collection rally coupled with the increasing necessity of dissemination and sharing of non-aggregated data, i.e., microdata, raised a lot of concerns about privacy. One method to ensure privacy is to selectively hide the confidential, i.e. sensitive, information before disclosure. However, with data mining techniques, it is now possible for an adversary to predict the hidden confidential information from the disclosed data sets. In this paper, we concentrate on one such data mining technique called classification. We extend our previous work on microdata suppression to prevent both probabilistic and decision tree classification based inference. We also provide experimental results showing the effectiveness of not only the proposed methods but also the hybrid methods, i.e., methods suppressing microdata against both classification models, on real-life data sets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0171-0">Sliding-window top-k queries on uncertain streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0171-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Cheqing+Jin%22">Cheqing Jin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ke+Yi%22">Ke Yi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li></ol>
          <input type="checkbox" id="1504"/>
          <label for="1504">Abstract</label>
          <div>Recently, due to the imprecise nature of the data generated from a variety of streaming applications, such as sensor networks, query processing on uncertain data streams has become an important problem. However, all the existing works on uncertain data streams study unbounded streams. In this paper, we take the first step towards the important and challenging problem of answering sliding-window queries on uncertain data streams, with a focus on one of the most important types of queries—top-k queries. It is nontrivial to find an efficient solution for answering sliding-window top-k queries on uncertain data streams, because challenges not only stem from the strict space and time requirements of processing both arriving and expiring tuples in high-speed streams, but also rise from the exponential blowup in the number of possible worlds induced by the uncertain data model. In this paper, we design a unified framework for processing sliding-window top-k queries on uncertain streams. We show that all the existing top-k definitions in the literature can be plugged into our framework, resulting in several succinct synopses that use space much smaller than the window size, while they are also highly efficient in terms of processing time. We also extend our framework to answering multiple top-k queries. In addition to the theoretical space and time bounds that we prove for these synopses, we present a thorough experimental report to verify their practical efficiency on both synthetic and real data.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0174-x">Efficient processing of exact top-k queries over disk-resident sorted lists</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0174-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22HweeHwa+Pang%22">HweeHwa Pang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuhua+Ding%22">Xuhua Ding</a></li><li><a href="http://link.springer.com/search?facet-author=%22Baihua+Zheng%22">Baihua Zheng</a></li></ol>
          <input type="checkbox" id="93859"/>
          <label for="93859">Abstract</label>
          <div>The top-k query is employed in a wide range of applications to generate a ranked list of data that have the highest aggregate scores over certain attributes. As the pool of attributes for selection by individual queries may be large, the data are indexed with per-attribute sorted lists, and a threshold algorithm (TA) is applied on the lists involved in each query. The TA executes in two phases—find a cut-off threshold for the top-k result scores, then evaluate all the records that could score above the threshold. In this paper, we focus on exact top-k queries that involve monotonic linear scoring functions over disk-resident sorted lists. We introduce a model for estimating the depths to which each sorted list needs to be processed in the two phases, so that (most of) the required records can be fetched efficiently through sequential or batched I/Os. We also devise a mechanism to quickly rank the data that qualify for the query answer and to eliminate those that do not, in order to reduce the computation demand of the query processor. Extensive experiments with four different datasets confirm that our schemes achieve substantial performance speed-up of between two times and two orders of magnitude over existing TAs, at the expense of a memory overhead of 4.8 bits per attribute value. Moreover, our scheme is robust to different data distributions and query characteristics.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 2010)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0144-3">Continuous spatial assignment of moving users</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0144-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Leong+Hou+U%22">Leong Hou U</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyriakos+Mouratidis%22">Kyriakos Mouratidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nikos+Mamoulis%22">Nikos Mamoulis</a></li></ol>
          <input type="checkbox" id="19702"/>
          <label for="19702">Abstract</label>
          <div>Consider a set of servers and a set of users, where each server has a coverage region (i.e., an area of service) and a capacity (i.e., a maximum number of users it can serve). Our task is to assign every user to one server subject to the coverage and capacity constraints. To offer the highest quality of service, we wish to minimize the average distance between users and their assigned server. This is an instance of a well-studied problem in operations research, termed optimal assignment. Even though there exist several solutions for the static case (where user locations are fixed), there is currently no method for dynamic settings. In this paper, we consider the continuous assignment problem (CAP), where an optimal assignment must be constantly maintained between mobile users and a set of servers. The fact that the users are mobile necessitates real-time reassignment so that the quality of service remains high (i.e., their distance from their assigned servers is minimized). The large scale and the time-critical nature of targeted applications require fast CAP solutions. We propose an algorithm that utilizes the geometric characteristics of the problem and significantly accelerates the initial assignment computation and its subsequent maintenance. Our method applies to different cost functions (e.g., average squared distance) and to any Minkowski distance metric (e.g., Euclidean, L 1 norm, etc.).</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0145-2">Continuous authentication on relational streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0145-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Stavros+Papadopoulos%22">Stavros Papadopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yin+Yang%22">Yin Yang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Papadias%22">Dimitris Papadias</a></li></ol>
          <input type="checkbox" id="77656"/>
          <label for="77656">Abstract</label>
          <div>According to the database outsourcing model, a data owner delegates database functionality to a third-party service provider, which answers queries received from clients. Authenticated query processing enables the clients to verify the correctness of query results. Despite the abundance of methods for authenticated processing in conventional databases, there is limited work on outsourced data streams. Stream environments pose new challenges such as the need for fast structure updating, support for continuous query processing and authentication, and provision for temporal completeness. Specifically, in addition to the correctness of individual results, the client must be able to verify that there are no missing results in between data updates. This paper presents a comprehensive set of methods covering relational streams. We first describe REF, a technique that achieves correctness and temporal completeness but incurs false transmissions, i.e., the provider has to inform the clients whenever there is a data update, even if their results are not affected. Then, we propose CADS, which minimizes the processing and transmission overhead through an elaborate indexing scheme and a virtual caching mechanism. In addition, we present an analytical study to determine the optimal indexing granularity, and extend CADS for the case that the data distribution changes over time. Finally, we evaluate the effectiveness of our techniques through extensive experiments.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0148-z">Understanding the meaning of a shifted sky: a general framework on extending skyline query</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0148-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Zhenjie+Zhang%22">Zhenjie Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hua+Lu%22">Hua Lu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anthony+K.+H.+Tung%22">Anthony K. H. Tung</a></li></ol>
          <input type="checkbox" id="6410"/>
          <label for="6410">Abstract</label>
          <div>Skyline queries are often used on data sets in multi-dimensional space for many decision-making applications. Traditionally, an object p is said to dominate another object q if, for all dimensions, it is no worse than q and is better on at least one dimension. Therefore, the skyline of a data set consists of all objects not dominated by any other object. To better cater to application requirements such as controlling the size of the skyline or handling data sets that are not well-structured, various works have been proposed to extend the definition of skyline based on variants of the dominance relationship. In view of the proliferation of variants, in this paper, a generalized framework is proposed to guide the extension of skyline query from conventional definition to different variants. Our framework explicitly and carefully examines the various properties that should be preserved in a variant of the dominance relationship so that: (1) maintaining original advantages, while extending adaptivity to application semantics, and (2) keeping computational complexity almost unaffected. We prove that traditional dominance is the only relationship satisfying all desirable properties, and present some new dominance relationships by relaxing some of the properties. These relationships are general enough for us to design new top-k skyline queries that return robust results of a controllable size. We analyze the existing skyline algorithms based on their minimum requirements on dominance properties. We also extend our analysis to data sets with missing values, and present extensive experimental results on the combinations of new dominance relationships and skyline algorithms.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0157-y">A framework for testing DBMS features</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0157-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Eric+Lo%22">Eric Lo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carsten+Binnig%22">Carsten Binnig</a></li><li><a href="http://link.springer.com/search?facet-author=%22Donald+Kossmann%22">Donald Kossmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wing-Kai+Hon%22">Wing-Kai Hon</a></li></ol>
          <input type="checkbox" id="84669"/>
          <label for="84669">Abstract</label>
          <div>Testing a specific feature of a DBMS requires controlling the inputs and outputs of the operators in the query execution plan. However, that is practically difficult to achieve because the inputs/outputs of a query depend on the content of the test database. In this paper, we propose a framework to test DBMS features. The framework includes a database generator called QAGen so that the generated test databases are able to meet the test requirements defined on the test queries. The framework also includes a set of tools to automate test case constructions and test executions. A wide range of DBMS feature testing tasks can be facilitated by the proposed framework.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0159-9">Schema mapping and query translation in heterogeneous P2P XML databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0159-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Angela+Bonifati%22">Angela Bonifati</a></li><li><a href="http://link.springer.com/search?facet-author=%22Elaine+Chang%22">Elaine Chang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Terence+Ho%22">Terence Ho</a></li><li><a href="http://link.springer.com/search?facet-author=%22Laks+V.+S.+Lakshmanan%22">Laks V. S. Lakshmanan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rachel+Pottinger%22">Rachel Pottinger</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yongik+Chung%22">Yongik Chung</a></li></ol>
          <input type="checkbox" id="30269"/>
          <label for="30269">Abstract</label>
          <div>Peers in a peer-to-peer data management system often have heterogeneous schemas and no mediated global schema. To translate queries across peers, we assume each peer provides correspondences between its schema and a small number of other peer schemas. We focus on query reformulation in the presence of heterogeneous XML schemas, including data–metadata conflicts. We develop an algorithm for inferring precise mapping rules from informal schema correspondences. We define the semantics of query answering in this setting and develop query translation algorithm. Our translation handles an expressive fragment of XQuery and works both along and against the direction of mapping rules. We describe the HePToX heterogeneous P2P XML data management system which incorporates our results. We report the results of extensive experiments on HePToX on both synthetic and real datasets. We demonstrate our system utility and scalability on different P2P distributions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0160-3">Revisiting the cube lifecycle in the presence of hierarchies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0160-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Konstantinos+Morfonios%22">Konstantinos Morfonios</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Ioannidis%22">Yannis Ioannidis</a></li></ol>
          <input type="checkbox" id="68315"/>
          <label for="68315">Abstract</label>
          <div>On-line analytical processing (OLAP) typically involves complex aggregate queries over large datasets. The data cube has been proposed as a structure that materializes the results of such queries in order to accelerate OLAP. A significant fraction of the related work has been on Relational-OLAP (ROLAP) techniques, which are based on relational technology. Existing ROLAP cubing solutions mainly focus on “flat” datasets, which do not include hierarchies in their dimensions. Nevertheless, as shown in this paper, the nature of hierarchies introduces several complications into the entire lifecycle of a data cube including the operations of construction, storage, indexing, query processing, and incremental maintenance. This fact renders existing techniques essentially inapplicable in a significant number of real-world applications and mandates revisiting the entire cube lifecycle under the new perspective. In order to overcome this problem, the CURE algorithm has been recently proposed as an efficient mechanism to construct complete cubes over large datasets with arbitrary hierarchies and store them in a highly compressed format, compatible with the relational model. In this paper, we study the remaining phases in the cube lifecycle and introduce query-processing and incremental-maintenance algorithms for CURE cubes. These are significantly different from earlier approaches, which have been proposed for flat cubes constructed by other techniques and are inadequate for CURE due to its high compression rate and the presence of hierarchies. Our methods address issues such as cube indexing, query optimization, and lazy update policies. Especially regarding updates, such lazy approaches are applied for the first time on cubes. We demonstrate the effectiveness of CURE in all phases of the cube lifecycle through experiments on both real-world and synthetic datasets. Among the experimental results, we distinguish those that have made CURE the first ROLAP technique to complete the construction and usage of the cube of the highest-density dataset in the APB-1 benchmark (12 GB). CURE was in fact quite efficient on this, showing great promise with respect to the potential of the technique overall.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0162-1">Threshold-based probabilistic top-k dominating queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0162-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wenjie+Zhang%22">Wenjie Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ying+Zhang%22">Ying Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jian+Pei%22">Jian Pei</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wei+Wang%22">Wei Wang</a></li></ol>
          <input type="checkbox" id="22529"/>
          <label for="22529">Abstract</label>
          <div>Recently, due to intrinsic characteristics in many underlying data sets, a number of probabilistic queries on uncertain data have been investigated. Top-k dominating queries are very important in many applications including decision making in a multidimensional space. In this paper, we study the problem of efficiently computing top-k dominating queries on uncertain data. We first formally define the problem. Then, we develop an efficient, threshold-based algorithm to compute the exact solution. To overcome some inherent computational deficiency in an exact computation, we develop an efficient randomized algorithm with an accuracy guarantee. Our extensive experiments demonstrate that both algorithms are quite efficient, while the randomized algorithm is quite scalable against data set sizes, object areas, k values, etc. The randomized algorithm is also highly accurate in practice.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (February 2010)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0173-y">Special issue: best papers of VLDB 2008</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0173-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+Buneman%22">Peter Buneman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Volker+Markl%22">Volker Markl</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kenneth+Ross%22">Kenneth Ross</a></li></ol>
          <input type="checkbox" id="78182"/>
          <label for="78182">Abstract</label>
          <div></div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0172-z">Methods for finding frequent items in data streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0172-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Graham+Cormode%22">Graham Cormode</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marios+Hadjieleftheriou%22">Marios Hadjieleftheriou</a></li></ol>
          <input type="checkbox" id="93098"/>
          <label for="93098">Abstract</label>
          <div>The frequent items problem is to process a stream of items and find all items occurring more than a given fraction of the time. It is one of the most heavily studied problems in data stream mining, dating back to the 1980s. Many applications rely directly or indirectly on finding the frequent items, and implementations are in use in large scale industrial systems. However, there has not been much comparison of the different methods under uniform experimental conditions. It is common to find papers touching on this topic in which important related work is mischaracterized, overlooked, or reinvented. In this paper, we aim to present the most important algorithms for this problem in a common framework. We have created baseline implementations of the algorithms and used these to perform a thorough experimental study of their properties. We give empirical evidence that there is considerable variation in the performance of frequent items algorithms. The best methods can be implemented to find frequent items with high accuracy using only tens of kilobytes of memory, at rates of millions of items per second on cheap modern hardware.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0154-1">Constrained physical design tuning</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0154-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nicolas+Bruno%22">Nicolas Bruno</a></li><li><a href="http://link.springer.com/search?facet-author=%22Surajit+Chaudhuri%22">Surajit Chaudhuri</a></li></ol>
          <input type="checkbox" id="24934"/>
          <label for="24934">Abstract</label>
          <div>Existing solutions to the automated physical design problem in database systems attempt to minimize execution costs of input workloads for a given storage constraint. In this work, we argue that this model is not flexible enough to address several real-world situations. To overcome this limitation, we introduce a constraint language that is simple yet powerful enough to express many important scenarios. We build upon a previously proposed transformation-based framework to incorporate constraints into the search space. We then show experimentally that we are able to handle a rich class of constraints and that our proposed technique scales gracefully. Our approach generalizes previous work that assumes simpler optimization models where configuration size is the only fixed constraint. As a consequence, the process of tuning a workload not only becomes more flexible, but also more complex, and getting the best design in the first attempt becomes difficult. We propose a paradigm shift for physical design tuning, in which sessions are highly interactive, allowing DBAs to quickly try different options, identify problems, and obtain physical designs in an agile manner.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0168-8">Accuracy estimate and optimization techniques for SimRank computation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0168-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dmitry+Lizorkin%22">Dmitry Lizorkin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pavel+Velikhov%22">Pavel Velikhov</a></li><li><a href="http://link.springer.com/search?facet-author=%22Maxim+Grinev%22">Maxim Grinev</a></li><li><a href="http://link.springer.com/search?facet-author=%22Denis+Turdakov%22">Denis Turdakov</a></li></ol>
          <input type="checkbox" id="13734"/>
          <label for="13734">Abstract</label>
          <div>The measure of similarity between objects is a very useful tool in many areas of computer science, including information retrieval. SimRank is a simple and intuitive measure of this kind, based on a graph-theoretic model. SimRank is typically computed iteratively, in the spirit of PageRank. However, existing work on SimRank lacks accuracy estimation of iterative computation and has discouraging time complexity. In this paper, we present a technique to estimate the accuracy of computing SimRank iteratively. This technique provides a way to find out the number of iterations required to achieve a desired accuracy when computing SimRank. We also present optimization techniques that improve the computational complexity of the iterative algorithm from O(n 4) in the worst case to min(O(nl), O(n 3/ log2 n)), with n denoting the number of objects, and l denoting the number object-to-object relationships. We also introduce a threshold sieving heuristic and its accuracy estimation that further improves the efficiency of the method. As a practical illustration of our techniques, we computed SimRank scores on a subset of English Wikipedia corpus, consisting of the complete set of articles and category links.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0164-z">Online maintenance of very large random samples on flash storage</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0164-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Suman+Nath%22">Suman Nath</a></li><li><a href="http://link.springer.com/search?facet-author=%22Phillip+B.+Gibbons%22">Phillip B. Gibbons</a></li></ol>
          <input type="checkbox" id="93950"/>
          <label for="93950">Abstract</label>
          <div>Recent advances in flash storage have made it an attractive alternative for data storage in a wide spectrum of computing devices, such as embedded sensors, mobile phones, PDA’s, laptops, and even servers. However, flash storage has many unique characteristics that make existing data management/analytics algorithms designed for magnetic disks perform poorly with flash storage. For example, while random reads can be nearly as fast as sequential reads, random writes and in-place data updates are orders of magnitude slower than sequential writes. In this paper, we consider an important fundamental problem that would seem to be particularly challenging for flash storage: efficiently maintaining a very large random sample of a data stream (e.g., of sensor readings). First, we show that previous algorithms such as reservoir sampling and geometric file are not readily adapted to flash. Second, we propose B-File, an energy-efficient abstraction for flash storage to store self-expiring items, and show how a B-File can be used to efficiently maintain a large sample in flash. Our solution is simple, has a small (RAM) memory footprint, and is designed to cope with flash constraints in order to reduce latency and energy consumption. Third, we provide techniques to maintain biased samples with a B-File and to query the large sample stored in a B-File for a subsample of an arbitrary size. Finally, we present an evaluation with flash storage that shows our techniques are several orders of magnitude faster and more energy-efficient than (flash-friendly versions of) reservoir sampling and geometric file. A key finding of our study, of potential use to many flash algorithms beyond sampling, is that “semi-random” writes (as defined in the paper) on flash cards are over two orders of magnitude faster and more energy-efficient than random writes.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0165-y">The RDF-3X engine for scalable management of RDF data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0165-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Thomas+Neumann%22">Thomas Neumann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="57916"/>
          <label for="57916">Abstract</label>
          <div>RDF is a data model for schema-free structured information that is gaining momentum in the context of Semantic-Web data, life sciences, and also Web 2.0 platforms. The “pay-as-you-go” nature of RDF and the flexible pattern-matching capabilities of its query language SPARQL entail efficiency and scalability challenges for complex queries including long join paths. This paper presents the RDF-3X engine, an implementation of SPARQL that achieves excellent performance by pursuing a RISC-style architecture with streamlined indexing and query processing. The physical design is identical for all RDF-3X databases regardless of their workloads, and completely eliminates the need for index tuning by exhaustive indexes for all permutations of subject-property-object triples and their binary and unary projections. These indexes are highly compressed, and the query processor can aggressively leverage fast merge joins with excellent performance of processor caches. The query optimizer is able to choose optimal join orders even for complex queries, with a cost model that includes statistical synopses for entire join paths. Although RDF-3X is optimized for queries, it also provides good support for efficient online updates by means of a staging architecture: direct updates to the main database indexes are deferred, and instead applied to compact differential indexes which are later merged into the main indexes in a batched manner. Experimental studies with several large-scale datasets with more than 50 million RDF triples and benchmark queries that include pattern matching, manyway star-joins, and long path-joins demonstrate that RDF-3X can outperform the previously best alternatives by one or two orders of magnitude.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0167-9">Anonymizing bipartite graph data using safe groupings</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0167-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Graham+Cormode%22">Graham Cormode</a></li><li><a href="http://link.springer.com/search?facet-author=%22Divesh+Srivastava%22">Divesh Srivastava</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ting+Yu%22">Ting Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qing+Zhang%22">Qing Zhang</a></li></ol>
          <input type="checkbox" id="61058"/>
          <label for="61058">Abstract</label>
          <div>Private data often come in the form of associations between entities, such as customers and products bought from a pharmacy, which are naturally represented in the form of a large, sparse bipartite graph. As with tabular data, it is desirable to be able to publish anonymized versions of such data, to allow others to perform ad hoc analysis of aggregate graph properties. However, existing tabular anonymization techniques do not give useful or meaningful results when applied to graphs: small changes or masking of the edge structure can radically change aggregate graph properties. We introduce a new family of anonymizations for bipartite graph data, called (k, ℓ)-groupings. These groupings preserve the underlying graph structure perfectly, and instead anonymize the mapping from entities to nodes of the graph. We identify a class of “safe” (k, ℓ)-groupings that have provable guarantees to resist a variety of attacks, and show how to find such safe groupings. We perform experiments on real bipartite graph data to study the utility of the anonymized version, and the impact of publishing alternate groupings of the same graph data. Our experiments demonstrate that (k, ℓ)-groupings offer strong tradeoffs between privacy and utility.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 18 (January 2009 - December 2009)</h1>
          <ol><li>
          <h2>Issue 6 (December 2009)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0134-5">HE-Tree: a framework for detecting changes in clustering structure for categorical data streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0134-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Keke+Chen%22">Keke Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ling+Liu%22">Ling Liu</a></li></ol>
          <input type="checkbox" id="32904"/>
          <label for="32904">Abstract</label>
          <div>Analyzing clustering structures in data streams can provide critical information for real-time decision making. Most research in this area has focused on clustering algorithms for numerical data streams, and very few have proposed to monitor the change of clustering structure. Most surprisingly, to our knowledge, no work has been proposed on monitoring clustering structure for categorical data streams. In this paper, we present a framework for detecting the change of primary clustering structure in categorical data streams, which is indicated by the change of the best number of clusters (Best K) in the data stream. The framework uses a Hierarchical Entropy Tree structure (HE-Tree) to capture the entropy characteristics of clusters in a data stream, and detects the change of Best K by combining our previously developed BKPlot method. The HE-Tree can efficiently summarize the entropy property of a categorical data stream and allow us to draw precise clustering information from the data stream for generating high-quality BKPlots. We also develop the time-decaying HE-Tree structure to make the monitoring more sensitive to recent changes of clustering structure. The experimental result shows that with the combination of the HE-Tree and the BKPlot method we are able to promptly and precisely detect the change of clustering structure in categorical data streams.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0136-3">Generic entity resolution with negative rules</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0136-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Steven+Euijong+Whang%22">Steven Euijong Whang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Omar+Benjelloun%22">Omar Benjelloun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hector+Garcia-Molina%22">Hector Garcia-Molina</a></li></ol>
          <input type="checkbox" id="95484"/>
          <label for="95484">Abstract</label>
          <div>Entity resolution (ER) (also known as deduplication or merge-purge) is a process of identifying records that refer to the same real-world entity and merging them together. In practice, ER results may contain “inconsistencies,” either due to mistakes by the match and merge function writers or changes in the application semantics. To remove the inconsistencies, we introduce “negative rules” that disallow inconsistencies in the ER solution (ER-N). A consistent solution is then derived based on the guidance from a domain expert. The inconsistencies can be resolved in several ways, leading to accurate solutions. We formalize ER-N, treating the match, merge, and negative rules as black boxes, which permits expressive and extensible ER-N solutions. We identify important properties for the rules that, if satisfied, enable less costly ER-N. We develop and evaluate two algorithms that find an ER-N solution based on guidance from the domain expert: the GNR algorithm that does not assume the properties and the ENR algorithm that exploits the properties.</div>
        </li><li data-tags="big-data">
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0140-7">Statistical structures for Internet-scale data management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0140-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nikos+Ntarmos%22">Nikos Ntarmos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+Triantafillou%22">Peter Triantafillou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="7352"/>
          <label for="7352">Abstract</label>
          <div>Efficient query processing in traditional database management systems relies on statistics on base data. For centralized systems, there is a rich body of research results on such statistics, from simple aggregates to more elaborate synopses such as sketches and histograms. For Internet-scale distributed systems, on the other hand, statistics management still poses major challenges. With the work in this paper we aim to endow peer-to-peer data management over structured overlays with the power associated with such statistical information, with emphasis on meeting the scalability challenge. To this end, we first contribute efficient, accurate, and decentralized algorithms that can compute key aggregates such as Count, CountDistinct, Sum, and Average. We show how to construct several types of histograms, such as simple Equi-Width, Average-Shifted Equi-Width, and Equi-Depth histograms. We present a full-fledged open-source implementation of these tools for distributed statistical synopses, and report on a comprehensive experimental performance evaluation, evaluating our contributions in terms of efficiency, accuracy, and scalability.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0141-6">Optimizing updates of recursive XML views of relations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0141-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ramadhana+Bramandia%22">Ramadhana Bramandia</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiefeng+Cheng%22">Jiefeng Cheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Byron+Choi%22">Byron Choi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li></ol>
          <input type="checkbox" id="43807"/>
          <label for="43807">Abstract</label>
          <div>XML publishing has been an emerging technique for transforming (portions of) a relational database into an XML document, for example, to facilitate interoperability between heterogeneous applications. Such applications may update the XML document and the source relational database must be updated accordingly. In this paper, we consider such XML documents as (possibly) recursively defined XML views of relations. We propose new optimization techniques to efficiently support XML view updates specified via an XPATH expression with recursion and complex filters. The main novelties of our techniques are: (1) we propose a space-efficient relational encoding of recursive XML views; and (2) we push the bulk of update processing inside a relational database. Specifically, a compressed representation of the XML views is stored as extended shared-inlining relations. A space-efficient and updatable 2-hop index is used to optimize XPATH evaluation on XML views. Updates of the XML views are evaluated on these relations and index. View update translation is handled by a heuristic procedure inside a relational database, as opposed to previous middleware approaches. We present an experimental study to demonstrate the effectiveness of our proposed techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0142-5">BerlinMOD: a benchmark for moving object databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0142-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Christian+D%C3%BCntgen%22">Christian Düntgen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Thomas+Behr%22">Thomas Behr</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ralf+Hartmut+G%C3%BCting%22">Ralf Hartmut Güting</a></li></ol>
          <input type="checkbox" id="79574"/>
          <label for="79574">Abstract</label>
          <div>This document presents a method to design scalable and representative moving object data (MOD) and two sets of queries for benchmarking spatio-temporal DBMS. Instead of programming a dedicated generator software, we use the existing Secondo DBMS to create benchmark data. The benchmark is based on a simulation scenario, where the positions of a sample of vehicles are observed for an arbitrary period of time within the street network of Berlin. We demonstrate the data generator’s extensibility by showing how to achieve more natural movement generation patterns, and how to disturb the vehicles’ positions to create noisy data. As an application and for reference, we also present first benchmarking results for the Secondo DBMS. Whereas the benchmark focuses on range queries, we demonstrate its ability to incorporate new future classes of queries by presenting a preliminary extension handling various nearest neighbour queries. Such a benchmark is useful in several ways: It provides well-defined data sets and queries for experimental evaluations; it simplifies experimental repeatability; it emphasizes the development of complete systems; it points out weaknesses in existing systems motivating further research. Moreover, the BerlinMOD benchmark allows one to compare different representations of the same moving objects.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0143-4">Principles of Holism for sequential twig pattern matching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0143-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Federica+Mandreoli%22">Federica Mandreoli</a></li><li><a href="http://link.springer.com/search?facet-author=%22Riccardo+Martoglia%22">Riccardo Martoglia</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pavel+Zezula%22">Pavel Zezula</a></li></ol>
          <input type="checkbox" id="19382"/>
          <label for="19382">Abstract</label>
          <div>Modern applications face the challenge of dealing with structured and semi-structured data. They have to deal with complex objects, most of them presenting some kind of internal structure, which often forms a hierarchy. Though XML documents are the most known, chemical compounds, CAD drawings, web-sites and many other applications have to deal with similar problems. In such environments, ordered and unordered tree pattern matching are the fundamental search operations. One of the main thrusts of research activities for tree pattern matching is the class of holistic approaches. Their ultimate goal is to evaluate a query twig as a whole by relying on sequential access patterns and non trivial auxiliary storage structures, typically stored in main memory. Based on the pre/post-order ranks of individual tree nodes, we establish strong theoretical bases as a foundation for correct and efficient holistic pattern matching algorithms. In particular, we define and prove sufficient and necessary conditions to minimize the amount of data retained in memory, thus introducing a correct and complete framework on which different holistic solutions can be compared. We also show how these rules can be applied for building algorithms for ordered and unordered tree-pattern matching. Thanks to the above theoretical achievements, each holistic algorithm gains in efficiency as it is directly implemented on the adopted numbering scheme, avoids expensive matching refinements and keeps memory requirements stable. An experimental analysis and comparison with previous approaches confirms the superiority of our approach tested on synthetic as well as real-life data sets.</div>
        </li></ul>
        </li><li>
          <h2>Issue 5 (October 2009)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0158-x">Special issue on uncertain and probabilistic databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0158-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+J.+Haas%22">Peter J. Haas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Suciu%22">Dan Suciu</a></li></ol>
          <input type="checkbox" id="59809"/>
          <label for="59809">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0147-0">Representing uncertain data: models, properties, and algorithms</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0147-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Anish+Das+Sarma%22">Anish Das Sarma</a></li><li><a href="http://link.springer.com/search?facet-author=%22Omar+Benjelloun%22">Omar Benjelloun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Halevy%22">Alon Halevy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shubha+Nabar%22">Shubha Nabar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jennifer+Widom%22">Jennifer Widom</a></li></ol>
          <input type="checkbox" id="91181"/>
          <label for="91181">Abstract</label>
          <div>In general terms, an uncertain relation encodes a set of possible certain relations. There are many ways to represent uncertainty, ranging from alternative values for attributes to rich constraint languages. Among the possible models for uncertain data, there is a tension between simple and intuitive models, which tend to be incomplete, and complete models, which tend to be nonintuitive and more complex than necessary for many applications. We present a space of models for representing uncertain data based on a variety of uncertainty constructs and tuple-existence constraints. We explore a number of properties and results for these models. We study completeness of the models, as well as closure under relational operations, and we give results relating closure and completeness. We then examine whether different models guarantee unique representations of uncertain data, and for those models that do not, we provide complexity results and algorithms for testing equivalence of representations. The next problem we consider is that of minimizing the size of representation of models, showing that minimizing the number of tuples also minimizes the size of constraints. We show that minimization is intractable in general and study the more restricted problem of maintaining minimality incrementally when performing operations. Finally, we present several results on the problem of approximating uncertain data in an insufficiently expressive model.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0149-y">${10^{(10^{6})}}$ worlds and beyond: efficient representation and processing of incomplete information</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0149-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Lyublena+Antova%22">Lyublena Antova</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christoph+Koch%22">Christoph Koch</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Olteanu%22">Dan Olteanu</a></li></ol>
          <input type="checkbox" id="27919"/>
          <label for="27919">Abstract</label>
          <div>We present a decomposition-based approach to managing probabilistic information. We introduce world-set decompositions (WSDs), a space-efficient and complete representation system for finite sets of worlds. We study the problem of efficiently evaluating relational algebra queries on world-sets represented by WSDs. We also evaluate our technique experimentally in a large census data scenario and show that it is both scalable and efficient.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0146-1">On the expressiveness of probabilistic XML models</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0146-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Serge+Abiteboul%22">Serge Abiteboul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Benny+Kimelfeld%22">Benny Kimelfeld</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yehoshua+Sagiv%22">Yehoshua Sagiv</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pierre+Senellart%22">Pierre Senellart</a></li></ol>
          <input type="checkbox" id="73808"/>
          <label for="73808">Abstract</label>
          <div>Various known models of probabilistic XML can be represented as instantiations of the abstract notion of p-documents. In addition to ordinary nodes, p-documents have distributional nodes that specify the possible worlds and their probabilistic distribution. Particular families of p-documents are determined by the types of distributional nodes that can be used as well as by the structural constraints on the placement of those nodes in a p-document. Some of the resulting families provide natural extensions and combinations of previously studied probabilistic XML models. The focus of the paper is on the expressive power of families of p-documents. In particular, two main issues are studied. The first is the ability to (efficiently) translate a given p-document of one family into another family. The second is closure under updates, namely, the ability to (efficiently) represent the result of updating the instances of a p-document of a given family as another p-document of that family. For both issues, we distinguish two variants corresponding to value-based and object-based semantics of p-documents.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0153-2">PrDB: managing and exploiting rich correlations in probabilistic databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0153-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Prithviraj+Sen%22">Prithviraj Sen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amol+Deshpande%22">Amol Deshpande</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lise+Getoor%22">Lise Getoor</a></li></ol>
          <input type="checkbox" id="72071"/>
          <label for="72071">Abstract</label>
          <div>Due to numerous applications producing noisy data, e.g., sensor data, experimental data, data from uncurated sources, information extraction, etc., there has been a surge of interest in the development of probabilistic databases. Most probabilistic database models proposed to date, however, fail to meet the challenges of real-world applications on two counts: (1) they often restrict the kinds of uncertainty that the user can represent; and (2) the query processing algorithms often cannot scale up to the needs of the application. In this work, we define a probabilistic database model, PrDB, that uses graphical models, a state-of-the-art probabilistic modeling technique developed within the statistics and machine learning community, to model uncertain data. We show how this results in a rich, complex yet compact probabilistic database model, which can capture the commonly occurring uncertainty models (tuple uncertainty, attribute uncertainty), more complex models (correlated tuples and attributes) and allows compact representation (shared and schema-level correlations). In addition, we show how query evaluation in PrDB translates into inference in an appropriately augmented graphical model. This allows us to easily use any of a myriad of exact and approximate inference algorithms developed within the graphical modeling community. While probabilistic inference provides a generic approach to solving queries, we show how the use of shared correlations, together with a novel inference algorithm that we developed based on bisimulation, can speed query processing significantly. We present a comprehensive experimental evaluation of the proposed techniques and show that even with a few shared correlations, significant speedups are possible.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0151-4">The trichotomy of HAVING queries on a probabilistic database</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0151-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Christopher+R%C3%A9%22">Christopher Ré</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Suciu%22">Dan Suciu</a></li></ol>
          <input type="checkbox" id="33690"/>
          <label for="33690">Abstract</label>
          <div>We study the evaluation of positive conjunctive queries with Boolean aggregate tests (similar to HAVING in SQL) on probabilistic databases. More precisely, we study conjunctive queries with predicate aggregates on probabilistic databases where the aggregation function is one of MIN, MAX, EXISTS, COUNT, SUM, AVG, or COUNT(DISTINCT) and the comparison function is one of =, ≠,≥,>,≤, or <. The complexity of evaluating a HAVING query depends on the aggregation function, α, and the comparison function, θ. In this paper, we establish a set of trichotomy results for conjunctive queries with HAVING predicates parametrized by (α, θ). For such queries (without self-joins), one of the following three statements is true: (1) the exact evaluation problem has ${\mathcal P}$ -time data complexity. In this case, we call the query safe. (2) The exact evaluation problem is ${{\sharp{\mathcal P}}}$ -hard, but the approximate evaluation problem has (randomized) ${{\mathcal P}}$ -time data complexity. More precisely, there exists an FPTRAS for the query. In this case, we call the query apx-safe. (3) The exact evaluation problem is ${{\sharp{\mathcal P}}}$ -hard, and the approximate evaluation problem is also hard. We call these queries hazardous. The precise definition of each class depends on the aggregate considered and the comparison function. Thus, we have queries that are (MAX,≥ )-safe, (COUNT,≤ )-apx-safe, (SUM,=)-hazardous, etc. Our trichotomy result is a significant extension of a previous dichotomy result for Boolean conjunctive queries into safe and not safe. For each of the three classes we present novel techniques. For safe queries, we describe an evaluation algorithm that uses random variables over semirings. For apx-safe queries, we describe an FPTRAS that relies on a novel algorithm for generating a random possible world satisfying a given condition. Finally, for hazardous queries we give novel proofs of hardness of approximation. The results for safe queries were previously announced (in Ré, C., Suciu, D. Efficient evaluation of. In: DBPL, pp. 186–200, 2007), but all other results are new.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0150-5">Query evaluation over probabilistic XML</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0150-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Benny+Kimelfeld%22">Benny Kimelfeld</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yuri+Kosharovsky%22">Yuri Kosharovsky</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yehoshua+Sagiv%22">Yehoshua Sagiv</a></li></ol>
          <input type="checkbox" id="86165"/>
          <label for="86165">Abstract</label>
          <div>Query evaluation over probabilistic XML is explored. The queries are twig patterns with projection, and the data is represented in terms of three models of probabilistic XML (that extend existing ones in the literature). The first model makes an assumption of independence among the probabilistic junctions, whereas the second model can encode probabilistic dependencies. The third model combines the first two and, hence, is the most general. An efficient algorithm (under data complexity) is given for query evaluation in the first model. In addition, various optimizations are proposed, and their effectiveness is shown both analytically and experimentally. For the other two models, it is shown that every query is either intractable or trivial. Nonetheless, efficient (additive and multiplicative) approximation algorithms are given for these two models. Finally, Boolean queries are enriched by allowing disjunctions and negations of branches. The above algorithm for the first model is extended to handle these queries. For the other two models, there is an efficient additive approximation, and a multiplicative one also exists if there is no negation; in addition, it is shown that if the query is non-monotonic, then no efficient multiplicative approximation exists unless NP = RP.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0161-2">Creating probabilistic databases from duplicated data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0161-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Oktie+Hassanzadeh%22">Oktie Hassanzadeh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ren%C3%A9e+J.+Miller%22">Renée J. Miller</a></li></ol>
          <input type="checkbox" id="30015"/>
          <label for="30015">Abstract</label>
          <div>A major source of uncertainty in databases is the presence of duplicate items, i.e., records that refer to the same real-world entity. However, accurate deduplication is a difficult task and imperfect data cleaning may result in loss of valuable information. A reasonable alternative approach is to keep duplicates when the correct cleaning strategy is not certain, and utilize an efficient probabilistic query-answering technique to return query results along with probabilities of each answer being correct. In this paper, we present a flexible modular framework for scalably creating a probabilistic database out of a dirty relation of duplicated data and overview the challenges raised in utilizing this framework for large relations of string data. We study the problem of associating probabilities with duplicates that are detected using state-of-the-art scalable approximate join methods. We argue that standard thresholding techniques are not sufficiently robust for this task, and propose new clustering algorithms suitable for inferring duplicates and their associated probabilities. We show that the inferred probabilities accurately reflect the error in duplicate records.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0155-0">Query processing over incomplete autonomous databases: query rewriting using learned data dependencies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0155-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Garrett+Wolf%22">Garrett Wolf</a></li><li><a href="http://link.springer.com/search?facet-author=%22Aravind+Kalavagattu%22">Aravind Kalavagattu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hemal+Khatri%22">Hemal Khatri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raju+Balakrishnan%22">Raju Balakrishnan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bhaumik+Chokshi%22">Bhaumik Chokshi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianchun+Fan%22">Jianchun Fan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yi+Chen%22">Yi Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Subbarao+Kambhampati%22">Subbarao Kambhampati</a></li></ol>
          <input type="checkbox" id="49660"/>
          <label for="49660">Abstract</label>
          <div>Incompleteness due to missing attribute values (aka “null values”) is very common in autonomous web databases, on which user accesses are usually supported through mediators. Traditional query processing techniques that focus on the strict soundness of answer tuples often ignore tuples with critical missing attributes, even if they wind up being relevant to a user query. Ideally we would like the mediator to retrieve such possibleanswers and gauge their relevance by accessing their likelihood of being pertinent answers to the query. The autonomous nature of web databases poses several challenges in realizing this objective. Such challenges include the restricted access privileges imposed on the data, the limited support for query patterns, and the bounded pool of database and network resources in the web environment. We introduce a novel query rewriting and optimization framework QPIAD that tackles these challenges. Our technique involves reformulating the user query based on mined correlations among the database attributes. The reformulated queries are aimed at retrieving the relevant possibleanswers in addition to the certain answers. QPIAD is able to gauge the relevance of such queries allowing tradeoffs in reducing the costs of database query processing and answer transmission. To support this framework, we develop methods for mining attribute correlations (in terms of Approximate Functional Dependencies), value distributions (in the form of Naïve Bayes Classifiers), and selectivity estimates. We present empirical studies to demonstrate that our approach is able to effectively retrieve relevant possibleanswers with high precision, high recall, and manageable cost.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0156-z">Qualitative effects of knowledge rules and user feedback in probabilistic data integration</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0156-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Maurice+van+Keulen%22">Maurice van Keulen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ander+de+Keijzer%22">Ander de Keijzer</a></li></ol>
          <input type="checkbox" id="77895"/>
          <label for="77895">Abstract</label>
          <div>In data integration efforts, portal development in particular, much development time is devoted to entity resolution. Often advanced similarity measurement techniques are used to remove semantic duplicates or solve other semantic conflicts. It proves impossible, however, to automatically get rid of all semantic problems. An often-used rule of thumb states that about 90% of the development effort is devoted to semi-automatically resolving the remaining 10% hard cases. In an attempt to significantly decrease human effort at data integration time, we have proposed an approach that strives for a ‘good enough’ initial integration which stores any remaining semantic uncertainty and conflicts in a probabilistic database. The remaining cases are to be resolved with user feedback during query time. The main contribution of this paper is an experimental investigation of the effects and sensitivity of rule definition, threshold tuning, and user feedback on the integration quality. We claim that our approach indeed reduces development effort—and not merely shifts the effort—by showing that setting rough safe thresholds and defining only a few rules suffices to produce a ‘good enough’ initial integration that can be meaningfully used, and that user feedback is effective in gradually improving the integration quality.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0152-3">Scalable processing of snapshot and continuous nearest-neighbor queries over one-dimensional uncertain data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0152-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jinchuan+Chen%22">Jinchuan Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Reynold+Cheng%22">Reynold Cheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+Mokbel%22">Mohamed Mokbel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chi-Yin+Chow%22">Chi-Yin Chow</a></li></ol>
          <input type="checkbox" id="80864"/>
          <label for="80864">Abstract</label>
          <div>In several emerging and important applications, such as location-based services, sensor monitoring and biological databases, the values of the data items are inherently imprecise. A useful query class for these data is the Probabilistic Nearest-Neighbor Query (PNN), which yields the IDs of objects for being the closest neighbor of a query point, together with the objects’ probability values. Previous studies showed that this query takes a long time to evaluate. To address this problem, we propose the Constrained Nearest-Neighbor Query (C-PNN), which returns the IDs of objects whose probabilities are higher than some threshold, with a given error bound in the answers. We show that the C-PNN can be answered efficiently with verifiers. These are methods that derive the lower and upper bounds of answer probabilities, so that an object can be quickly decided on whether it should be included in the answer. We design five verifiers, which can be used on uncertain data with arbitrary probability density functions. We further develop a  partial evaluation technique, so that a user can obtain some answers quickly, without waiting for the whole query evaluation process to be completed (which may incur a high response time). In addition, we examine the maintenance of a long-standing, or continuous C-PNN query. This query requires any update to be applied to the result immediately, in order to reflect the changes to the database values (e.g., due to the change of the location of a moving object). We design an incremental update method based on previous query answers, in order to reduce the amount of I/O and CPU cost in maintaining the correctness of the answers to such a query. Performance evaluation on realistic datasets show that our methods are capable of yielding timely and accurate results.</div>
        </li></ul>
        </li><li>
          <h2>Issue 4 (August 2009)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0129-7">Privacy-preserving indexing of documents on the network</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0129-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mayank+Bawa%22">Mayank Bawa</a></li><li><a href="http://link.springer.com/search?facet-author=%22Roberto+J.+Bayardo+Jr%22">Roberto J. Bayardo Jr</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rakesh+Agrawal%22">Rakesh Agrawal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jaideep+Vaidya%22">Jaideep Vaidya</a></li></ol>
          <input type="checkbox" id="16504"/>
          <label for="16504">Abstract</label>
          <div>With the ubiquitous collection of data and creation of large distributed repositories, enabling search over this data while respecting access control is critical. A related problem is that of ensuring privacy of the content owners while still maintaining an efficient index of distributed content. We address the problem of providing privacy-preserving search over distributed access-controlled content. Indexed documents can be easily reconstructed from conventional (inverted) indexes used in search. Currently, the need to avoid breaches of access-control through the index requires the index hosting site to be fully secured and trusted by all participating content providers. This level of trust is impractical in the increasingly common case where multiple competing organizations or individuals wish to selectively share content. We propose a solution that eliminates the need of such a trusted authority. The solution builds a centralized privacy-preserving index in conjunction with a distributed access-control enforcing search protocol. Two alternative methods to build the centralized index are proposed, allowing trade offs of efficiency and security. The new index provides strong and quantifiable privacy guarantees that hold even if the entire index is made public. Experiments on a real-life dataset validate performance of the scheme. The appeal of our solution is twofold: (a) content providers maintain complete control in defining access groups and ensuring its compliance, and (b) system implementors retain tunable knobs to balance privacy and efficiency concerns for their particular domains.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0131-0">Query translation from XPath to SQL in the presence of recursive DTDs</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0131-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wenfei+Fan%22">Wenfei Fan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianzhong+Li%22">Jianzhong Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bolin+Ding%22">Bolin Ding</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lu+Qin%22">Lu Qin</a></li></ol>
          <input type="checkbox" id="90753"/>
          <label for="90753">Abstract</label>
          <div>We study the problem of evaluating xpath queries over xml data that is stored in an rdbms via schema-based shredding. The interaction between recursion (descendants-axis) in xpath queries and recursion in dtds makes it challenging to answer xpath queries using rdbms. We present a new approach to translating xpath queries into sql queries based on a notion of extended XP ath expressions and a simple least fixpoint (lfp) operator. Extended xpath expressions are a mild extension of xpath, and the lfp operator takes a single input relation and is already supported by most commercial rdbms. We show that extended xpath expressions are capable of capturing both dtd recursion and xpath queries in a uniform framework. Furthermore, they can be translated into an equivalent sequence of sql queries with the lfp operator. We present algorithms for rewriting xpath queries over a (possibly recursive) dtd into extended xpath expressions and for translating extended xpath expressions to sql queries, as well as optimization techniques. The novelty of our approach consists in its capability to answer a large class of xpath queries by means of only low-end rdbms features already available in most rdbms, as well as its flexibility to accommodate existing relational query optimization techniques. In addition, these translation algorithms provide a solution to query answering for certain (possibly recursive) xml views of xml data. Our experimental results verify the effectiveness of our techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0138-1">RATEWeb: Reputation Assessment for Trust Establishment among Web services</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0138-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Zaki+Malik%22">Zaki Malik</a></li><li><a href="http://link.springer.com/search?facet-author=%22Athman+Bouguettaya%22">Athman Bouguettaya</a></li></ol>
          <input type="checkbox" id="713"/>
          <label for="713">Abstract</label>
          <div>We introduce RATEWeb, a framework for establishing trust in service-oriented environments. RATEWeb supports a cooperative model in which Web services share their experiences of the service providers with their peers through feedback ratings. The different ratings are aggregated to derive a service provider’s reputation. This in turn is used to evaluate trust. The overall goal of RATEWeb is to facilitate trust-based selection and composition of Web services. We propose a set of decentralized techniques that aim at accurately aggregating the submitted ratings for reputation assessment. We conduct experiments to assess the fairness and accuracy of the proposed techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0139-0">Complex RFID event processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0139-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Fusheng+Wang%22">Fusheng Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shaorong+Liu%22">Shaorong Liu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peiya+Liu%22">Peiya Liu</a></li></ol>
          <input type="checkbox" id="14671"/>
          <label for="14671">Abstract</label>
          <div>Advances of sensor and radio frequency identification (RFID) technology provide significant new power for humans to sense, understand and manage the world. RFID provides fast data collection with precise identification of objects with unique IDs without line of sight, thus it can be used for identifying, locating, tracking and monitoring physical objects. Despite these benefits, RFID poses many challenges for data processing and management: (i) RFID observations have implicit meanings, which have to be transformed and aggregated into semantic data represented in their data models; and (ii) RFID data are temporal, streaming, and in high volume, and have to be processed on the fly. Thus, a general RFID data processing framework is needed to automate the transformation of physical RFID observations into the virtual counterparts in the virtual world linked to business applications. In this paper, we take an event-oriented approach to process RFID data, by devising RFID application logic into complex events. We then formalize the specification and semantics of RFID events and rules. We discover that RFID events are highly temporal constrained, and include non-spontaneous events, and develop an RFID event detection engine that can effectively process complex RFID events. The declarative event-based approach greatly simplifies the work of RFID data processing, and can significantly reduce the cost of RFID data integration.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0135-4">Large-scale indexing of spatial data in distributed repositories: the SD-Rtree</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0135-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22C%C3%A9dric+du+Mouza%22">Cédric du Mouza</a></li><li><a href="http://link.springer.com/search?facet-author=%22Witold+Litwin%22">Witold Litwin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philippe+Rigaux%22">Philippe Rigaux</a></li></ol>
          <input type="checkbox" id="24633"/>
          <label for="24633">Abstract</label>
          <div>We propose a scalable distributed data structure (SDDS) called SD-Rtree. We intend our structure for point, window and kNN queries over large spatial datasets distributed on clusters of interconnected servers. The structure balances the storage and processing load over the available resources, and aims at minimizing the size of the cluster. SD-Rtree generalizes the well-known Rtree structure. It uses a distributed balanced binary tree that scales with insertions to potentially any number of storage servers through splits of the overloaded ones. A user/application manipulates the structure from a client node. The client addresses the tree through its image that can be possibly outdated due to later split. This may generate addressing errors, solved by the forwarding among the servers. Specific messages towards the clients incrementally correct the outdated images. We present the building of an SD-Rtree through insertions, focusing on the split and rotation algorithms. We follow with the query algorithms. We describe then a flexible allocation protocol which allows to cope with a temporary shortage of storage resources through data storage balancing. Experiments show additional aspects of SD-Rtree and compare its behavior with a distributed quadtree. The results justify our various design choices and the overall utility of the structure.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0137-2">A distributed spatial index for error-prone wireless data broadcast</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0137-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Baihua+Zheng%22">Baihua Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wang-Chien+Lee%22">Wang-Chien Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ken+C.+K.+Lee%22">Ken C. K. Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dik+Lun+Lee%22">Dik Lun Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Min+Shao%22">Min Shao</a></li></ol>
          <input type="checkbox" id="31167"/>
          <label for="31167">Abstract</label>
          <div>Information is valuable to users when it is available not only at the right time but also at the right place. To support efficient location-based data access in wireless data broadcast systems, a distributed spatial index (called DSI) is presented in this paper. DSI is highly efficient because it has a linear yet fully distributed structure that naturally shares links in different search paths. DSI is very resilient to the error-prone wireless communication environment because interrupted search operations based on DSI can be resumed easily. It supports search algorithms for classical location-based queries such as window queries and kNN queries in both of the snapshot and continuous query modes. In-depth analysis and simulation-based evaluation have been conducted. The results show that DSI significantly out-performs a variant of R-trees tailored for wireless data broadcast environments.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (June 2009)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0110-5">Reducing outer joins</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0110-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Hill%22">Gerhard Hill</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andrew+Ross%22">Andrew Ross</a></li></ol>
          <input type="checkbox" id="93562"/>
          <label for="93562">Abstract</label>
          <div>We present a method for transforming some outer joins to inner joins and describe a generalized semijoin reduction technique. The first part of the paper shows how to transform a given outer join query whose join graph is a tree to an equivalent inner join query. The method uses derived relations and join predicates. Derived relations contain columns corresponding to join conditions and may have virtual row identifiers, rows and attribute values. The constructed inner join query, after elimination of virtual row identifiers, has the same join tuples as the outer join query. Both the theoretical maximum number of virtual rows and the average number in practice are shown to be low. The method confines consideration of the non-associativity of outer joins to a single step. The second part of the paper generalizes to outer joins the well known technique of semijoin reduction of inner joins. It does so by defining the notions of influencing and needing, and using them to define full reduction and reduction plans. The technique is applied here to perform one step of the method presented in the first part. Semijoin reduction is useful in practice for executing join queries in distributed databases.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0111-4">Supporting exact indexing of arbitrarily rotated shapes and periodic time series under Euclidean and warping distance measures</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0111-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Eamonn+Keogh%22">Eamonn Keogh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Li+Wei%22">Li Wei</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaopeng+Xi%22">Xiaopeng Xi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michail+Vlachos%22">Michail Vlachos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sang-Hee+Lee%22">Sang-Hee Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pavlos+Protopapas%22">Pavlos Protopapas</a></li></ol>
          <input type="checkbox" id="94394"/>
          <label for="94394">Abstract</label>
          <div>Shape matching and indexing is important topic in its own right, and is a fundamental subroutine in most shape data mining algorithms. Given the ubiquity of shape, shape matching is an important problem with applications in domains as diverse as biometrics, industry, medicine, zoology and anthropology. The distance/similarity measure for used for shape matching must be invariant to many distortions, including scale, offset, noise, articulation, partial occlusion, etc. Most of these distortions are relatively easy to handle, either in the representation of the data or in the similarity measure used. However, rotation invariance is noted in the literature as being an especially difficult challenge. Current approaches typically try to achieve rotation invariance in the representation of the data, at the expense of discrimination ability, or in the distance measure, at the expense of efficiency. In this work, we show that we can take the slow but accurate approaches and dramatically speed them up. On real world problems our technique can take current approaches and make them four orders of magnitude faster without false dismissals. Moreover, our technique can be used with any of the dozens of existing shape representations and with all the most popular distance measures including Euclidean distance, dynamic time warping and Longest Common Subsequence. We further show that our indexing technique can be used to index star light curves, an important type of astronomical data, without modification.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0113-2">Authenticated indexing for outsourced spatial databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0113-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yin+Yang%22">Yin Yang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stavros+Papadopoulos%22">Stavros Papadopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Papadias%22">Dimitris Papadias</a></li><li><a href="http://link.springer.com/search?facet-author=%22George+Kollios%22">George Kollios</a></li></ol>
          <input type="checkbox" id="37428"/>
          <label for="37428">Abstract</label>
          <div>In spatial database outsourcing, a data owner delegates its data management tasks to a location-based service (LBS), which indexes the data with an authenticated data structure (ADS). The LBS receives queries (ranges, nearest neighbors) originating from several clients/subscribers. Each query initiates the computation of a verification object (VO) based on the ADS. The VO is returned to the client that can verify the result correctness using the public key of the owner. Our first contribution is the MR-tree, a space-efficient ADS that supports fast query processing and verification. Our second contribution is the MR*-tree, a modified version of the MR-tree, which significantly reduces the VO size through a novel embedding technique. Finally, whereas most ADSs must be constructed and maintained by the owner, we outsource the MR- and MR*-tree construction and maintenance to the LBS, thus relieving the owner from this computationally intensive task.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0114-1">A self-adaptable query allocation framework for distributed information systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0114-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jorge-Arnulfo+Quian%C3%A9-Ruiz%22">Jorge-Arnulfo Quiané-Ruiz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philippe+Lamarre%22">Philippe Lamarre</a></li><li><a href="http://link.springer.com/search?facet-author=%22Patrick+Valduriez%22">Patrick Valduriez</a></li></ol>
          <input type="checkbox" id="87121"/>
          <label for="87121">Abstract</label>
          <div>In large-scale distributed information systems, where participants are autonomous and have special interests for some queries, query allocation is a challenge. Much work in this context has focused on distributing queries among providers in a way that maximizes overall performance (typically throughput and response time). However, preserving the participants’ interests is also important. In this paper, we make the following contributions. First, we provide a model to define the participants’ perception of the system regarding their interests and propose measures to evaluate the quality of query allocation methods. Then, we propose a framework for query allocation called Satisfaction-based Query Load Balancing (SQLB, for short), which dynamically trades consumers’ interests for providers’ interests based on their satisfaction. Finally, we compare SQLB, through experimentation, with two important baseline query allocation methods, namely Capacity based and Mariposa-like. The results demonstrate that SQLB yields high efficiency while satisfying the participants’ interests and significantly outperforms the baseline methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0115-0">Instance optimal query processing in spatial networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0115-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ke+Deng%22">Ke Deng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Heng+Tao+Shen%22">Heng Tao Shen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shazia+Sadiq%22">Shazia Sadiq</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xue+Li%22">Xue Li</a></li></ol>
          <input type="checkbox" id="79033"/>
          <label for="79033">Abstract</label>
          <div>The performance optimization of query processing in spatial networks focuses on minimizing network data accesses and the cost of network distance calculations. This paper proposes algorithms for network k-NN queries, range queries, closest-pair queries and multi-source skyline queries based on a novel processing framework, namely, incremental lower bound constraint. By giving high processing priority to the query associated data points and utilizing the incremental nature of the lower bound, the performance of our algorithms is better optimized in contrast to the corresponding algorithms based on known framework incremental Euclidean restriction and incremental network expansion. More importantly, the proposed algorithms are proven to be instance optimal among classes of algorithms. Through experiments on real road network datasets, the superiority of the proposed algorithms is demonstrated.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0117-y">Multi-dimensional top-k dominating queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0117-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Man+Lung+Yiu%22">Man Lung Yiu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nikos+Mamoulis%22">Nikos Mamoulis</a></li></ol>
          <input type="checkbox" id="29859"/>
          <label for="29859">Abstract</label>
          <div>The top-k dominating query returns k data objects which dominate the highest number of objects in a dataset. This query is an important tool for decision support since it provides data analysts an intuitive way for finding significant objects. In addition, it combines the advantages of top-k and skyline queries without sharing their disadvantages: (i) the output size can be controlled, (ii) no ranking functions need to be specified by users, and (iii) the result is independent of the scales at different dimensions. Despite their importance, top-k dominating queries have not received adequate attention from the research community. This paper is an extensive study on the evaluation of top-k dominating queries. First, we propose a set of algorithms that apply on indexed multi-dimensional data. Second, we investigate query evaluation on data that are not indexed. Finally, we study a relaxed variant of the query which considers dominance in dimensional subspaces. Experiments using synthetic and real datasets demonstrate that our algorithms significantly outperform a previous skyline-based approach. We also illustrate the applicability of this multi-dimensional analysis query by studying the meaningfulness of its results on real data.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0120-3">The RUM-tree: supporting frequent updates in R-trees using memos</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0120-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yasin+N.+Silva%22">Yasin N. Silva</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaopeng+Xiong%22">Xiaopeng Xiong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Walid+G.+Aref%22">Walid G. Aref</a></li></ol>
          <input type="checkbox" id="73588"/>
          <label for="73588">Abstract</label>
          <div>The problem of frequently updating multi-dimensional indexes arises in many location-dependent applications. While the R-tree and its variants are the dominant choices for indexing multi-dimensional objects, the R-tree exhibits inferior performance in the presence of frequent updates. In this paper, we present an R-tree variant, termed the RUM-tree (which stands for R-tree with update memo) that reduces the cost of object updates. The RUM-tree processes updates in a memo-based approach that avoids disk accesses for purging old entries during an update process. Therefore, the cost of an update operation in the RUM-tree is reduced to the cost of only an insert operation. The removal of old object entries is carried out by a garbage cleaner inside the RUM-tree. In this paper, we present the details of the RUM-tree and study its properties. We also address the issues of crash recovery and concurrency control for the RUM-tree. Theoretical analysis and comprehensive experimental evaluation demonstrate that the RUM-tree outperforms other R-tree variants by up to one order of magnitude in scenarios with frequent updates.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0121-2">Self-tuning management of update-intensive multidimensional data in clusters of workstations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0121-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vassil+Kriakov%22">Vassil Kriakov</a></li><li><a href="http://link.springer.com/search?facet-author=%22George+Kollios%22">George Kollios</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alex+Delis%22">Alex Delis</a></li></ol>
          <input type="checkbox" id="6047"/>
          <label for="6047">Abstract</label>
          <div>Contemporary applications continuously modify large volumes of multidimensional data that must be accessed efficiently and, more importantly, must be updated in a timely manner. Single-server storage approaches are insufficient when managing such volumes of data, while the high frequency of data modification render classical indexing methods inefficient. To address these two problems we introduce a distributed storage manager for multidimensional data based on a Cluster-of-Workstations. The manager addresses the above challenges through a set of mechanisms that, through selective on-line data reorganization, collectively maintain a balanced load across a cluster of workstations. With the help of both a highly efficient and speedy self-tuning mechanism, based on a new data structure called stat-index, as well as a query aggregation and clustering algorithm, our storage manager attains short query response times even in the presence of massive modifications and highly skewed access patterns. Furthermore, we provide a data migration cost model used to determine the best data redistribution strategy. Through extensive experimentation with our prototype, we establish that our storage manager can sustain significant update rates with minimal overhead.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0122-1">Equivalence of queries that are sensitive to multiplicities</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0122-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sara+Cohen%22">Sara Cohen</a></li></ol>
          <input type="checkbox" id="35588"/>
          <label for="35588">Abstract</label>
          <div>The query equivalence problem has been studied extensively for set-semantics and, more recently, for bag and bag-set semantics. However, SQL queries often combine set, bag and bag-set semantics. For example, an SQL query that returns a multiset of elements may call a subquery or view that returns a set of elements. Queries may access both relations that do not contain duplicates, as well as relations with duplicates. As another example, in SQL one can compute a multiset-union of queries, each of which returns a set of answers. This paper presents combined semantics, which formally models query evaluation combining set, bag and bag-set semantics. The equivalence problem for queries evaluated under combined semantics is studied. A sufficient condition for equivalence is presented. For several important common classes of queries necessary and sufficient conditions for equivalence are presented.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0123-0">Efficient processing of probabilistic reverse nearest neighbor queries over uncertain data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0123-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xiang+Lian%22">Xiang Lian</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lei+Chen%22">Lei Chen</a></li></ol>
          <input type="checkbox" id="59498"/>
          <label for="59498">Abstract</label>
          <div>Reverse nearest neighbor (RNN) search is very crucial in many real applications. In particular, given a database and a query object, an RNN query retrieves all the data objects in the database that have the query object as their nearest neighbors. Often, due to limitation of measurement devices, environmental disturbance, or characteristics of applications (for example, monitoring moving objects), data obtained from the real world are uncertain (imprecise). Therefore, previous approaches proposed for answering an RNN query over exact (precise) database cannot be directly applied to the uncertain scenario. In this paper, we re-define the RNN query in the context of uncertain databases, namely probabilistic reverse nearest neighbor (PRNN) query, which obtains data objects with probabilities of being RNNs greater than or equal to a user-specified threshold. Since the retrieval of a PRNN query requires accessing all the objects in the database, which is quite costly, we also propose an effective pruning method, called geometric pruning (GP), that significantly reduces the PRNN search space yet without introducing any false dismissals. Furthermore, we present an efficient PRNN query procedure that seamlessly integrates our pruning method. Extensive experiments have demonstrated the efficiency and effectiveness of our proposed GP-based PRNN query processing approach, under various experimental settings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0128-8">Top-k typicality queries and efficient query answering methods on large databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0128-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ming+Hua%22">Ming Hua</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jian+Pei%22">Jian Pei</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ada+W.+C.+Fu%22">Ada W. C. Fu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ho-Fung+Leung%22">Ho-Fung Leung</a></li></ol>
          <input type="checkbox" id="52109"/>
          <label for="52109">Abstract</label>
          <div>Finding typical instances is an effective approach to understand and analyze large data sets. In this paper, we apply the idea of typicality analysis from psychology and cognitive science to database query answering, and study the novel problem of answering top-k typicality queries. We model typicality in large data sets systematically. Three types of top-k typicality queries are formulated. To answer questions like “Who are the top-k most typical NBA players?”, the measure of simple typicality is developed. To answer questions like “Who are the top-k most typical guards distinguishing guards from other players?”, the notion of discriminative typicality is proposed. Moreover, to answer questions like “Who are the best k typical guards in whole representing different types of guards?”, the notion of representative typicality is used. Computing the exact answer to a top-k typicality query requires quadratic time which is often too costly for online query answering on large databases. We develop a series of approximation methods for various situations: (1) the randomized tournament algorithm has linear complexity though it does not provide a theoretical guarantee on the quality of the answers; (2) the direct local typicality approximation using VP-trees provides an approximation quality guarantee; (3) a local typicality tree data structure can be exploited to index a large set of objects. Then, typicality queries can be answered efficiently with quality guarantees by a tournament method based on a Local Typicality Tree. An extensive performance study using two real data sets and a series of synthetic data sets clearly shows that top-k typicality queries are meaningful and our methods are practical.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 2009)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0132-7">Special issue: best papers of VLDB 2007</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0132-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Minos+Garofalakis%22">Minos Garofalakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Johannes+Gehrke%22">Johannes Gehrke</a></li><li><a href="http://link.springer.com/search?facet-author=%22Divesh+Srivastava%22">Divesh Srivastava</a></li></ol>
          <input type="checkbox" id="8326"/>
          <label for="8326">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0125-y">SW-Store: a vertically partitioned DBMS for Semantic Web data management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0125-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniel+J.+Abadi%22">Daniel J. Abadi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Adam+Marcus%22">Adam Marcus</a></li><li><a href="http://link.springer.com/search?facet-author=%22Samuel+R.+Madden%22">Samuel R. Madden</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kate+Hollenbach%22">Kate Hollenbach</a></li></ol>
          <input type="checkbox" id="70769"/>
          <label for="70769">Abstract</label>
          <div>Efficient management of RDF data is an important prerequisite for realizing the Semantic Web vision. Performance and scalability issues are becoming increasingly pressing as Semantic Web technology is applied to real-world applications. In this paper, we examine the reasons why current data management solutions for RDF data scale poorly, and explore the fundamental scalability limitations of these approaches. We review the state of the art for improving performance of RDF databases and consider a recent suggestion, “property tables”. We then discuss practically and empirically why this solution has undesirable features. As an improvement, we propose an alternative solution: vertically partitioning the RDF data. We compare the performance of vertical partitioning with prior art on queries generated by a Web-based RDF browser over a large-scale (more than 50 million triples) catalog of library data. Our results show that a vertically partitioned schema achieves similar performance to the property table technique while being much simpler to design. Further, if a column-oriented DBMS (a database architected specially for the vertically partitioned case) is used instead of a row-oriented DBMS, another order of magnitude performance improvement is observed, with query times dropping from minutes to several seconds. Encouraged by these results, we describe the architecture of SW-Store, a new DBMS we are actively building that implements these techniques to achieve high performance RDF data management.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0127-9">Anytime measures for top-k algorithms on exact and fuzzy data sets</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0127-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Benjamin+Arai%22">Benjamin Arai</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gautam+Das%22">Gautam Das</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitrios+Gunopulos%22">Dimitrios Gunopulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Koudas%22">Nick Koudas</a></li></ol>
          <input type="checkbox" id="87711"/>
          <label for="87711">Abstract</label>
          <div>Top-k queries on large multi-attribute data sets are fundamental operations in information retrieval and ranking applications. In this article, we initiate research on the anytime behavior of top-k algorithms on exact and fuzzy data. In particular, given specific top-k algorithms (TA and TA-Sorted) we are interested in studying their progress toward identification of the correct result at any point during the algorithms’ execution. We adopt a probabilistic approach where we seek to report at any point of operation of the algorithm the confidence that the top-k result has been identified. Such a functionality can be a valuable asset when one is interested in reducing the runtime cost of top-k computations. We present a thorough experimental evaluation to validate our techniques using both synthetic and real data sets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0118-x">Adversarial-knowledge dimensions in data privacy</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0118-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bee-Chung+Chen%22">Bee-Chung Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kristen+LeFevre%22">Kristen LeFevre</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raghu+Ramakrishnan%22">Raghu Ramakrishnan</a></li></ol>
          <input type="checkbox" id="4229"/>
          <label for="4229">Abstract</label>
          <div>Privacy is an important issue in data publishing. Many organizations distribute non-aggregate personal data for research, and they must take steps to ensure that an adversary cannot predict sensitive information pertaining to individuals with high confidence. This problem is further complicated by the fact that, in addition to the published data, the adversary may also have access to other resources (e.g., public records and social networks relating individuals), which we call adversarial knowledge. A robust privacy framework should allow publishing organizations to analyze data privacy by means of not only data dimensions (data that a publishing organization has), but also adversarial-knowledge dimensions (information not in the data). In this paper, we first describe a general framework for reasoning about privacy in the presence of adversarial knowledge. Within this framework, we propose a novel multidimensional approach to quantifying adversarial knowledge. This approach allows the publishing organization to investigate privacy threats and enforce privacy requirements in the presence of various types and amounts of adversarial knowledge. Our main technical contributions include a multidimensional privacy criterion that is more intuitive and flexible than previous approaches to modeling background knowledge. In addition, we identify an important congregation property of the adversarial-knowledge dimensions. Based on this property, we provide algorithms for measuring disclosure and sanitizing data that improve computational efficiency several orders of magnitude over the best known techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0119-9">Data integration with uncertainty</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0119-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xin+Luna+Dong%22">Xin Luna Dong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Halevy%22">Alon Halevy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cong+Yu%22">Cong Yu</a></li></ol>
          <input type="checkbox" id="61235"/>
          <label for="61235">Abstract</label>
          <div>This paper reports our first set of results on managing uncertainty in data integration. We posit that data-integration systems need to handle uncertainty at three levels and do so in a principled fashion. First, the semantic mappings between the data sources and the mediated schema may be approximate because there may be too many of them to be created and maintained or because in some domains (e.g., bioinformatics) it is not clear what the mappings should be. Second, the data from the sources may be extracted using information extraction techniques and so may yield erroneous data. Third, queries to the system may be posed with keywords rather than in a structured form. As a first step to building such a system, we introduce the concept of probabilistic schema mappings and analyze their formal foundations. We show that there are two possible semantics for such mappings: by-table semantics assumes that there exists a correct mapping but we do not know what it is; by-tuple semantics assumes that the correct mapping may depend on the particular tuple in the source data. We present the query complexity and algorithms for answering queries in the presence of probabilistic schema mappings, and we describe an algorithm for efficiently computing the top-k answers to queries in such a setting. Finally, we consider using probabilistic mappings in the scenario of data exchange.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0116-z">CellJoin: a parallel stream join operator for the cell processor</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0116-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bu%C4%9Fra+Gedik%22">Buğra Gedik</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rajesh+R.+Bordawekar%22">Rajesh R. Bordawekar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li></ol>
          <input type="checkbox" id="52868"/>
          <label for="52868">Abstract</label>
          <div>Low-latency and high-throughput processing are key requirements of data stream management systems (DSMSs). Hence, multi-core processors that provide high aggregate processing capacity are ideal matches for executing costly DSMS operators. The recently developed Cell processor is a good example of a heterogeneous multi-core architecture and provides a powerful platform for executing data stream operators with high-performance. On the down side, exploiting the full potential of a multi-core processor like Cell is often challenging, mainly due to the heterogeneous nature of the processing elements, the software managed local memory at the co-processor side, and the unconventional programming model in general. In this paper, we study the problem of scalable execution of windowed stream join operators on multi-core processors, and specifically on the Cell processor. By examining various aspects of join execution flow, we determine the right set of techniques to apply in order to minimize the sequential segments and maximize parallelism. Concretely, we show that basic windows coupled with low-overhead pointer-shifting techniques can be used to achieve efficient join window partitioning, column-oriented join window organization can be used to minimize scattered data transfers, delay-optimized double buffering can be used for effective pipelining, rate-aware batching can be used to balance join throughput and tuple delay, and finally single-instruction multiple-data (SIMD) optimized operator code can be used to exploit data parallelism. Our experimental results show that, following the design guidelines and implementation techniques outlined in this paper, windowed stream joins can achieve high scalability (linear in the number of co-processors) by making efficient use of the extensive hardware parallelism provided by the Cell processor (reaching data processing rates of ≈13 GB/s) and significantly surpass the performance obtained form conventional high-end processors (supporting a combined input stream rate of 2,000 tuples/s using 15 min windows and without dropping any tuples, resulting in ≈8.3 times higher output rate compared to an SSE implementation on dual 3.2 GHz Intel Xeon).</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0124-z">Depth estimation for ranking query optimization</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0124-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Karl+Schnaitter%22">Karl Schnaitter</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joshua+Spiegel%22">Joshua Spiegel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Neoklis+Polyzotis%22">Neoklis Polyzotis</a></li></ol>
          <input type="checkbox" id="37491"/>
          <label for="37491">Abstract</label>
          <div>A relational ranking query uses a scoring function to limit the results of a conventional query to a small number of the most relevant answers. The increasing popularity of this query paradigm has led to the introduction of specialized rank join operators that integrate the selection of top tuples with join processing. These operators access just “enough” of the input in order to generate just “enough” output and can offer significant speed-ups for query evaluation. The number of input tuples that an operator accesses is called the input depth of the operator, and this is the driving cost factor in rank join processing. This introduces the important problem of depth estimation, which is crucial for the costing of rank join operators during query compilation and thus for their integration in optimized physical plans. We introduce an estimation methodology, termed deep, for approximating the input depths of rank join operators in a physical execution plan. At the core of deep lies a general, principled framework that formalizes depth computation in terms of the joint distribution of scores in the base tables. This framework results in a systematic estimation methodology that takes the characteristics of the data directly into account and thus enables more accurate estimates. We develop novel estimation algorithms that provide an efficient realization of the formal deep framework, and describe their integration on top of the statistics module of an existing query optimizer. We validate the performance of deep with an extensive experimental study on data sets of varying characteristics. The results verify the effectiveness of deep as an estimation method and demonstrate its advantages over previously proposed techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0126-x">Efficient keyword search over virtual XML views</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0126-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Feng+Shao%22">Feng Shao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lin+Guo%22">Lin Guo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chavdar+Botev%22">Chavdar Botev</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anand+Bhaskar%22">Anand Bhaskar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Muthiah+Chettiar%22">Muthiah Chettiar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Fan+Yang%22">Fan Yang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jayavel+Shanmugasundaram%22">Jayavel Shanmugasundaram</a></li></ol>
          <input type="checkbox" id="29496"/>
          <label for="29496">Abstract</label>
          <div>Emerging applications such as personalized portals, enterprise search, and web integration systems often require keyword search over semi-structured views. However, traditional information retrieval techniques are likely to be expensive in this context because they rely on the assumption that the set of documents being searched is materialized. In this paper, we present a system architecture and algorithm that can efficiently evaluate keyword search queries over virtual (unmaterialized) XML views. An interesting aspect of our approach is that it exploits indices present on the base data and thereby avoids materializing large parts of the view that are not relevant to the query results. Another feature of the algorithm is that by solely using indices, we can still score the results of queries over the virtual view, and the resulting scores are the same as if the view was materialized. Our performance evaluation using the INEX data set in the Quark (Bhaskar et al. in Quark: an efficient XQuery full-text implementation. In: SIGMOD, 2006) open-source XML database system indicates that the proposed approach is scalable and efficient.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-009-0133-6">Guessing the extreme values in a data set: a Bayesian method and its applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-009-0133-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mingxi+Wu%22">Mingxi Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chris+Jermaine%22">Chris Jermaine</a></li></ol>
          <input type="checkbox" id="80334"/>
          <label for="80334">Abstract</label>
          <div>For a large number of data management problems, it would be very useful to be able to obtain a few samples from a data set, and to use the samples to guess the largest (or smallest) value in the entire data set. Min/max online aggregation, Top-k query processing, outlier detection, and distance join are just a few possible applications. This paper details a statistically rigorous, Bayesian approach to attacking this problem. Just as importantly, we demonstrate the utility of our approach by showing how it can be applied to four specific problems that arise in the context of data management.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 2009)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0076-8">FENECIA: failure endurable nested-transaction based execution of composite Web services with incorporated state analysis</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0076-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Neila+Ben+Lakhal%22">Neila Ben Lakhal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Takashi+Kobayashi%22">Takashi Kobayashi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Haruo+Yokota%22">Haruo Yokota</a></li></ol>
          <input type="checkbox" id="16463"/>
          <label for="16463">Abstract</label>
          <div>Interest in the Web services (WS) composition (WSC) paradigm is increasing tremendously. A real shift in distributed computing history is expected to occur when the dream of implementing Service-Oriented Architecture (SOA) is realized. However, there is a long way to go to achieve such an ambitious goal. In this paper, we support the idea that, when challenging the WSC issue, the earlier that the inevitability of failures is recognized and proper failure-handling mechanisms are defined, from the very early stage of the composite WS (CWS) specification, the greater are the chances of achieving a significant gain in dependability. To formalize this vision, we present the FENECIA (Failure Endurable Nested-transaction based Execution of Composite Web services with Incorporated state Analysis) framework. Our framework approaches the WSC issue from different points of view to guarantee a high level of dependability. In particular, it aims at being simultaneously a failure-handling-devoted CWS specification, execution, and quality of service (QoS) assessment approach. In the first section of our framework, we focus on answering the need for a specification model tailored for the WS architecture. To this end, we introduce WS-SAGAS, a new transaction model. WS-SAGAS introduces key concepts that are not part of the WS architecture pillars, namely, arbitrary nesting, state, vitality degree, and compensation, to specify failure-endurable CWS as a hierarchy of recursively nested transactions. In addition, to define the CWS execution semantics, without suffering from the hindrance of an XML-based notation, we describe a textual notation that describes a WSC in terms of definition rules, composability rules, and ordering rules, and we introduce graphical and formal notations. These rules provide the solid foundation needed to formulate the execution semantics of a CWS in terms of execution correctness verification dependencies. To ensure dependable execution of the CWS, we present in the second section of FENECIA our architecture THROWS, in which the execution control of the resulting CWS is distributed among engines, discovered dynamically, that communicate in a peer-to-peer fashion. A dependable execution is guaranteed in THROWS by keeping track of the execution progress of a CWS and by enforcing forward and backward recovery. We concentrate in the third section of our approach on showing how the failure consideration is trivial in acquiring more accurate CWS QoS estimations. We propose a model that assesses several QoS properties of CWS, which are specified as WS-SAGAS transactions and executed in THROWS. We validate our proposal and show its feasibility and broad applicability by describing an implemented prototype and a case study.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0081-y">Approximate voronoi cell computation on spatial data streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0081-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mehdi+Sharifzadeh%22">Mehdi Sharifzadeh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cyrus+Shahabi%22">Cyrus Shahabi</a></li></ol>
          <input type="checkbox" id="82919"/>
          <label for="82919">Abstract</label>
          <div>Several studies have exploited the properties of Voronoi diagrams to improve the efficiency of variations of the nearest neighbor search on stored datasets. However, the significance of Voronoi diagrams and their basic building blocks, Voronoi cells, has been neglected when the geometry data is incrementally becoming available as a data stream. In this paper, we study the problem of Voronoi cell computation for fixed 2-d site points when the locations of the neighboring sites arrive as a spatial data stream. We show that the non-streaming solution to the problem does not meet the memory requirements of many realistic scenarios over a sliding window. Hence, we propose AVC-SW, an approximate streaming algorithm that computes (1 + ε)-approximations to the actual exact Voronoi cell in O(κ) where κ is its sample size. With the sliding window model and random arrival of points, we show both analytically and experimentally that for given window size w and parameter k, AVC-SW reduces the expected memory requirements of the classic algorithm from O(w) to $O(k \log (\frac{w}{k} + 1))$ regardless of the distribution of the points in the 2-d space. This is a significant improvement for most of the real-world scenarios where w ≫ k.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0087-5">Online pairing of VoIP conversations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0087-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Michail+Vlachos%22">Michail Vlachos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Aris+Anagnostopoulos%22">Aris Anagnostopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Olivier+Verscheure%22">Olivier Verscheure</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li></ol>
          <input type="checkbox" id="94380"/>
          <label for="94380">Abstract</label>
          <div>This paper answers the following question; given a multiplicity of evolving 1-way conversations, can a machine or an algorithm discern the conversational pairs in an online fashion, without understanding the content of the communications? Our analysis indicates that this is possible, and can be achieved just by exploiting the temporal dynamics inherent in a conversation. We also show that our findings are applicable for anonymous and encrypted conversations over VoIP networks. We achieve this by exploiting the aperiodic inter-departure time of VoIP packets, hence trivializing each VoIP stream into a binary time-series, indicating the voice activity of each stream. We propose effective techniques that progressively pair conversing parties with high accuracy and in a limited amount of time. Our findings are verified empirically on a dataset consisting of 1,000 conversations. We obtain very high pairing accuracy that reaches 97% after 5 min of voice conversations. Using a modeling approach we also demonstrate analytically that our result can be extended over an unlimited number of conversations.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0089-3">Localized monitoring of kNN queries in wireless sensor networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0089-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yuxia+Yao%22">Yuxia Yao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xueyan+Tang%22">Xueyan Tang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ee-Peng+Lim%22">Ee-Peng Lim</a></li></ol>
          <input type="checkbox" id="88467"/>
          <label for="88467">Abstract</label>
          <div>Wireless sensor networks have been widely used in civilian and military applications. Primarily designed for monitoring purposes, many sensor applications require continuous collection and processing of sensed data. Due to the limited power supply for sensor nodes, energy efficiency is a major performance concern in query processing. In this paper, we focus on continuous kNN query processing in object tracking sensor networks. We propose a localized scheme to monitor nearest neighbors to a query point. The key idea is to establish a monitoring area for each query so that only the updates relevant to the query are collected. The monitoring area is set up when the kNN query is initially evaluated and is expanded and shrunk on the fly upon object movement. We analyze the optimal maintenance of the monitoring area and develop an adaptive algorithm to dynamically decide when to shrink the monitoring area. Experimental results show that establishing a monitoring area for continuous kNN query processing greatly reduces energy consumption and prolongs network lifetime.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0090-x">Autonomic query parallelization using non-dedicated computers: an evaluation of adaptivity options</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0090-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Norman+W.+Paton%22">Norman W. Paton</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jorge+Buenabad-Chavez%22">Jorge Buenabad-Chavez</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mengsong+Chen%22">Mengsong Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vijayshankar+Raman%22">Vijayshankar Raman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Garret+Swart%22">Garret Swart</a></li><li><a href="http://link.springer.com/search?facet-author=%22Inderpal+Narang%22">Inderpal Narang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Daniel+M.+Yellin%22">Daniel M. Yellin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alvaro+A.+A.+Fernandes%22">Alvaro A. A. Fernandes</a></li></ol>
          <input type="checkbox" id="80748"/>
          <label for="80748">Abstract</label>
          <div>Writing parallel programs that can take advantage of non-dedicated processors is much more difficult than writing such programs for networks of dedicated processors. In a non-dedicated environment such programs must use autonomic techniques to respond to the unpredictable load fluctuations that prevail in the computational environment. In adaptive query processing (AQP), several techniques have been proposed for dynamically redistributing processor load assignments throughout a computation to take account of varying resource capabilities, but we know of no previous study that compares their performance. This paper presents a simulation-based evaluation of these autonomic parallelization techniques in a uniform environment and compares how well they improve the performance of the computation. Four published strategies are compared with a new algorithm that seeks to overcome some weaknesses identified in the existing approaches. In addition, we explore the use of techniques from online algorithms to provide a firm foundation for determining when to adapt in two of the existing algorithms. The evaluations identify situations in which each strategy may be used effectively and in which it should be avoided.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0093-2">Efficient storage and retrieval of probabilistic latent semantic information for information retrieval</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0093-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Laurence+A.+F.+Park%22">Laurence A. F. Park</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kotagiri+Ramamohanarao%22">Kotagiri Ramamohanarao</a></li></ol>
          <input type="checkbox" id="99590"/>
          <label for="99590">Abstract</label>
          <div>Probabilistic latent semantic analysis (PLSA) is a method for computing term and document relationships from a document set. The probabilistic latent semantic index (PLSI) has been used to store PLSA information, but unfortunately the PLSI uses excessive storage space relative to a simple term frequency index, which causes lengthy query times. To overcome the storage and speed problems of PLSI, we introduce the probabilistic latent semantic thesaurus (PLST); an efficient and effective method of storing the PLSA information. We show that through methods such as document thresholding and term pruning, we are able to maintain the high precision results found using PLSA while using a very small percent (0.15%) of the storage space of PLSI.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0094-1">B-tries for disk-based string management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0094-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nikolas+Askitis%22">Nikolas Askitis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Justin+Zobel%22">Justin Zobel</a></li></ol>
          <input type="checkbox" id="38995"/>
          <label for="38995">Abstract</label>
          <div>A wide range of applications require that large quantities of data be maintained in sort order on disk. The B-tree, and its variants, are an efficient general-purpose disk-based data structure that is almost universally used for this task. The B-trie has the potential to be a competitive alternative for the storage of data where strings are used as keys, but has not previously been thoroughly described or tested. We propose new algorithms for the insertion, deletion, and equality search of variable-length strings in a disk-resident B-trie, as well as novel splitting strategies which are a critical element of a practical implementation. We experimentally compare the B-trie against variants of B-tree on several large sets of strings with a range of characteristics. Our results demonstrate that, although the B-trie uses more memory, it is faster, more scalable, and requires less disk space.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0095-0">Sampling-based estimators for subset-based queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0095-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Shantanu+Joshi%22">Shantanu Joshi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christopher+Jermaine%22">Christopher Jermaine</a></li></ol>
          <input type="checkbox" id="8315"/>
          <label for="8315">Abstract</label>
          <div>We consider the problem of using sampling to estimate the result of an aggregation operation over a subset-based SQL query, where a subquery is correlated to an outer query by a NOT EXISTS, NOT IN, EXISTS or IN clause. We design an unbiased estimator for our query and prove that it is indeed unbiased. We then provide a second, biased estimator that makes use of the superpopulation concept from statistics to minimize the mean squared error of the resulting estimate. The two estimators are tested over an extensive set of experiments.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0096-z">Hierarchically compressed wavelet synopses</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0096-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Sacharidis%22">Dimitris Sacharidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Antonios+Deligiannakis%22">Antonios Deligiannakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+Sellis%22">Timos Sellis</a></li></ol>
          <input type="checkbox" id="21360"/>
          <label for="21360">Abstract</label>
          <div>The wavelet decomposition is a proven tool for constructing concise synopses of large data sets that can be used to obtain fast approximate answers. Existing research studies focus on selecting an optimal set of wavelet coefficients to store so as to minimize some error metric, without however seeking to reduce the size of the wavelet coefficients themselves. In many real data sets the existence of large spikes in the data values results in many large coefficient values lying on paths of a conceptual tree structure known as the error tree. To exploit this fact, we introduce in this paper a novel compression scheme for wavelet synopses, termed hierarchically compressed wavelet synopses, that fully exploits hierarchical relationships among coefficients in order to reduce their storage. Our proposed compression scheme allows for a larger number of coefficients to be stored for a given space constraint thus resulting in increased accuracy of the produced synopsis. We propose optimal, approximate and greedy algorithms for constructing hierarchically compressed wavelet synopses that minimize the sum squared error while not exceeding a given space budget. Extensive experimental results on both synthetic and real-world data sets validate our novel compression scheme and demonstrate the effectiveness of our algorithms against existing synopsis construction algorithms.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0097-y">Containment of partially specified tree-pattern queries in the presence of dimension graphs</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0097-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dimitri+Theodoratos%22">Dimitri Theodoratos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pawel+Placek%22">Pawel Placek</a></li><li><a href="http://link.springer.com/search?facet-author=%22Theodore+Dalamagas%22">Theodore Dalamagas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stefanos+Souldatos%22">Stefanos Souldatos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+Sellis%22">Timos Sellis</a></li></ol>
          <input type="checkbox" id="7375"/>
          <label for="7375">Abstract</label>
          <div>Nowadays, huge volumes of data are organized or exported in tree-structured form. Querying capabilities are provided through tree-pattern queries. The need for querying tree-structured data sources when their structure is not fully known, and the need to integrate multiple data sources with different tree structures have driven, recently, the suggestion of query languages that relax the complete specification of a tree pattern. In this paper, we consider a query language that allows the partial specification of a tree pattern. Queries in this language range from structureless keyword-based queries to completely specified tree patterns. To support the evaluation of partially specified queries, we use semantically rich constructs, called dimension graphs, which abstract structural information of the tree-structured data. We address the problem of query containment in the presence of dimension graphs and we provide necessary and sufficient conditions for query containment. As checking query containment can be expensive, we suggest two heuristic approaches for query containment in the presence of dimension graphs. Our approaches are based on extracting structural information from the dimension graph that can be added to the queries while preserving equivalence with respect to the dimension graph. We considered both cases: extracting and storing different types of structural information in advance, and extracting information on-the-fly (at query time). Both approaches are implemented, validated, and compared through experimental evaluation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0098-x">Swoosh: a generic approach to entity resolution</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0098-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Omar+Benjelloun%22">Omar Benjelloun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hector+Garcia-Molina%22">Hector Garcia-Molina</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Menestrina%22">David Menestrina</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qi+Su%22">Qi Su</a></li><li><a href="http://link.springer.com/search?facet-author=%22Steven+Euijong+Whang%22">Steven Euijong Whang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jennifer+Widom%22">Jennifer Widom</a></li></ol>
          <input type="checkbox" id="53430"/>
          <label for="53430">Abstract</label>
          <div>We consider the entity resolution (ER) problem (also known as deduplication, or merge–purge), in which records determined to represent the same real-world entity are successively located and merged. We formalize the generic ER problem, treating the functions for comparing and merging records as black-boxes, which permits expressive and extensible ER solutions. We identify four important properties that, if satisfied by the match and merge functions, enable much more efficient ER algorithms. We develop three efficient ER algorithms: G-Swoosh for the case where the four properties do not hold, and R-Swoosh and F-Swoosh that exploit the four properties. F-Swoosh in addition assumes knowledge of the “features” (e.g., attributes) used by the match function. We experimentally evaluate the algorithms using comparison shopping data from Yahoo! Shopping and hotel information data from Yahoo! Travel. We also show that R-Swoosh (and F-Swoosh) can be used even when the four match and merge properties do not hold, if an “approximate” result is acceptable.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0099-9">Context-based literature digital collection search</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0099-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nattakarn+Ratprasartporn%22">Nattakarn Ratprasartporn</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jonathan+Po%22">Jonathan Po</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ali+Cakmak%22">Ali Cakmak</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sulieman+Bani-Ahmad%22">Sulieman Bani-Ahmad</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gultekin+Ozsoyoglu%22">Gultekin Ozsoyoglu</a></li></ol>
          <input type="checkbox" id="63257"/>
          <label for="63257">Abstract</label>
          <div>We identify two issues with searching literature digital collections within digital libraries: (a) there are no effective paper-scoring and ranking mechanisms. Without a scoring and ranking system, users are often forced to scan a large and diverse set of publications listed as search results and potentially miss the important ones. (b) Topic diffusion is a common problem: publications returned by a keyword-based search query often fall into multiple topic areas, not all of which are of interest to users. This paper proposes a new literature digital collection search paradigm that effectively ranks search outputs, while controlling the diversity of keyword-based search query output topics. Our approach is as follows. First, during pre-querying, publications are assigned into pre-specified ontology-based contexts, and query-independent context scores are attached to papers with respect to the assigned contexts. When a query is posed, relevant contexts are selected, search is performed within the selected contexts, context scores of publications are revised into relevancy scores with respect to the query at hand and the context that they are in, and query outputs are ranked within each relevant context. This way, we (1) minimize query output topic diversity, (2) reduce query output size, (3) decrease user time spent scanning query results, and (4) increase query output ranking accuracy. Using genomics-oriented PubMed publications as the testbed and Gene Ontology terms as contexts, our experiments indicate that the proposed context-based search approach produces search results with up to 50% higher precision, and reduces the query output size by up to 70%.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0100-7">Efficient frequent sequence mining by a dynamic strategy switching algorithm</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0100-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ding-Ying+Chiu%22">Ding-Ying Chiu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yi-Hung+Wu%22">Yi-Hung Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arbee+L.+P.+Chen%22">Arbee L. P. Chen</a></li></ol>
          <input type="checkbox" id="44781"/>
          <label for="44781">Abstract</label>
          <div>Mining frequent sequences in large databases has been an important research topic. The main challenge of mining frequent sequences is the high processing cost due to the large amount of data. In this paper, we propose a novel strategy to find all the frequent sequences without having to compute the support counts of non-frequent sequences. The previous works prune candidate sequences based on the frequent sequences with shorter lengths, while our strategy prunes candidate sequences according to the non-frequent sequences with the same lengths. As a result, our strategy can cooperate with the previous works to achieve a better performance. We then identify three major strategies used in the previous works and combine them with our strategy into an efficient algorithm. The novelty of our algorithm lies in its ability to dynamically switch from a previous strategy to our new strategy in the mining process for a better performance. Experiment results show that our algorithm outperforms the previous ones under various parameter settings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0101-6">Speed up interactive image retrieval</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0101-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Heng+Tao+Shen%22">Heng Tao Shen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shouxu+Jiang%22">Shouxu Jiang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zi+Huang%22">Zi Huang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li></ol>
          <input type="checkbox" id="33930"/>
          <label for="33930">Abstract</label>
          <div>In multimedia retrieval, a query is typically interactively refined towards the “optimal” answers by exploiting user feedback. However, in existing work, in each iteration, the refined query is re-evaluated. This is not only inefficient but fails to exploit the answers that may be common between iterations. Furthermore, it may also take too many iterations to get the “optimal” answers. In this paper, we introduce a new approach called OptRFS (optimizing relevance feedback search by query prediction) for iterative relevance feedback search. OptRFS aims to take users to view the “optimal” results as fast as possible. It optimizes relevance feedback search by both shortening the searching time during each iteration and reducing the number of iterations. OptRFS predicts the potential candidates for the next iteration and maintains this small set for efficient sequential scan. By doing so, repeated candidate accesses (i.e., random accesses) can be saved, hence reducing the searching time for the next iteration. In addition, efficient scan on the overlap before the next search starts also tightens the search space with smaller pruning radius. As a step forward, OptRFS also predicts the “optimal” query, which corresponds to “optimal” answers, based on the early executed iterations’ queries. By doing so, some intermediate iterations can be saved, hence reducing the total number of iterations. By taking the correlations among the early executed iterations into consideration, OptRFS investigates linear regression, exponential smoothing and linear exponential smoothing to predict the next refined query so as to decide the overlap of candidates between two consecutive iterations. Considering the special features of relevance feedback, OptRFS further introduces adaptive linear exponential smoothing to self-adjust the parameters for more accurate prediction. We implemented OptRFS and our experimental study on real life data sets show that it can reduce the total cost of relevance feedback search significantly. Some interesting features of relevance feedback search are also discovered and discussed.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0104-3">Skyframe: a framework for skyline query processing in peer-to-peer systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0104-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Shiyuan+Wang%22">Shiyuan Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Quang+Hieu+Vu%22">Quang Hieu Vu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anthony+K.+H.+Tung%22">Anthony K. H. Tung</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lizhen+Xu%22">Lizhen Xu</a></li></ol>
          <input type="checkbox" id="70980"/>
          <label for="70980">Abstract</label>
          <div>This paper looks at the processing of skyline queries on peer-to-peer (P2P) networks. We propose Skyframe, a framework for efficient skyline query processing in P2P systems, which addresses the challenges of quick response time, low network communication cost and query load balancing among peers. Skyframe consists of two querying methods: one is optimized for network communication while the other focuses on query response time. These methods are different in the way in which the query search space is defined. In particular, the first method uses a high dominating point that has a large dominating region to prune the search space to achieve a low cost in network communication. On the other hand, the second method relaxes the search space in order to allow parallel query processing to speed up query response. Skyframe achieves query load balancing by both query load conscious data space splitting/merging during the join/departure of nodes and dynamic load migration. We further show how to apply Skyframe to both the P2P systems supporting multi-dimensional indexing and the P2P systems supporting single-dimensional indexing. Finally, we have conducted extensive experiments on both real and synthetic data sets over two existing P2P systems: CAN (Ratnasamy in A scalable content-addressable network. In: Proceedings of SIGCOMM Conference, pp. 161–172, 2001) and BATON (Jagadish et al. in A balanced tree structure for peer-to-peer networks. In: Proceedings of VLDB Conference, pp. 661–672, 2005) to evaluate the effectiveness and scalability of Skyframe.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0108-z">Partially materialized digest scheme: an efficient verification method for outsourced databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0108-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kyriakos+Mouratidis%22">Kyriakos Mouratidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Sacharidis%22">Dimitris Sacharidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22HweeHwa+Pang%22">HweeHwa Pang</a></li></ol>
          <input type="checkbox" id="67393"/>
          <label for="67393">Abstract</label>
          <div>In the outsourced database model, a data owner publishes her database through a third-party server; i.e., the server hosts the data and answers user queries on behalf of the owner. Since the server may not be trusted, or may be compromised, users need a means to verify that answers received are both authentic and complete, i.e., that the returned data have not been tampered with, and that no qualifying results have been omitted. We propose a result verification approach for one-dimensional queries, called Partially Materialized Digest scheme (PMD), that applies to both static and dynamic databases. PMD uses separate indexes for the data and for their associated verification information, and only partially materializes the latter. In contrast with previous work, PMD avoids unnecessary costs when processing queries that do not request verification, achieving the performance of an ordinary index (e.g., a B+-tree). On the other hand, when an authenticity and completeness proof is required, PMD outperforms the existing state-of-the-art technique by a wide margin, as we demonstrate analytically and experimentally. Furthermore, we design two verification methods for spatial queries. The first, termed Merkle R-tree (MR-tree), extends the conventional approach of embedding authentication information into the data index (i.e., an R-tree). The second, called Partially Materialized KD-tree (PMKD), follows the PMD paradigm using separate data and verification indexes. An empirical evaluation with real data shows that the PMD methodology is superior to the traditional approach for spatial queries too.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 17 (January 2008 - November 2008)</h1>
          <ol><li>
          <h2>Issue 6 (November 2008)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0112-3">Guest editorial: special issue on metadata management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0112-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Tiziana+Catarci%22">Tiziana Catarci</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ren%C3%A9e+J.+Miller%22">Renée J. Miller</a></li></ol>
          <input type="checkbox" id="73607"/>
          <label for="73607">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0105-2">Model-independent schema translation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0105-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Paolo+Atzeni%22">Paolo Atzeni</a></li><li><a href="http://link.springer.com/search?facet-author=%22Paolo+Cappellari%22">Paolo Cappellari</a></li><li><a href="http://link.springer.com/search?facet-author=%22Riccardo+Torlone%22">Riccardo Torlone</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+A.+Bernstein%22">Philip A. Bernstein</a></li><li><a href="http://link.springer.com/search?facet-author=%22Giorgio+Gianforme%22">Giorgio Gianforme</a></li></ol>
          <input type="checkbox" id="98235"/>
          <label for="98235">Abstract</label>
          <div>We discuss a proposal for the implementation of the model management operator ModelGen, which translates schemas from one model to another, for example from object-oriented to SQL or from SQL to XML schema descriptions. The operator can be used to generate database wrappers (e.g., object-oriented or XML to relational), default user interfaces (e.g., relational to forms), or default database schemas from other representations. The approach translates schemas from a model to another, within a predefined, but large and extensible, set of models: given a source schema S expressed in a source model, and a target model TM, it generates a schema S′ expressed in TM that is “equivalent” to S. A wide family of models is handled by using a metamodel in which models can be succinctly and precisely described. The approach expresses the translation as Datalog rules and exposes the source and target of the translation in a generic relational dictionary. This makes the translation transparent, easy to customize and model-independent. The proposal includes automatic generation of translations as composition of basic steps.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0103-4">PicShark: mitigating metadata scarcity through large-scale P2P collaboration</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0103-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Philippe+Cudr%C3%A9-Mauroux%22">Philippe Cudré-Mauroux</a></li><li><a href="http://link.springer.com/search?facet-author=%22Adriana+Budura%22">Adriana Budura</a></li><li><a href="http://link.springer.com/search?facet-author=%22Manfred+Hauswirth%22">Manfred Hauswirth</a></li><li><a href="http://link.springer.com/search?facet-author=%22Karl+Aberer%22">Karl Aberer</a></li></ol>
          <input type="checkbox" id="27735"/>
          <label for="27735">Abstract</label>
          <div>With the commoditization of digital devices, personal information and media sharing is becoming a key application on the pervasive Web. In such a context, data annotation rather than data production is the main bottleneck. Metadata scarcity represents a major obstacle preventing efficient information processing in large and heterogeneous communities. However, social communities also open the door to new possibilities for addressing local metadata scarcity by taking advantage of global collections of resources. We propose to tackle the lack of metadata in large-scale distributed systems through a collaborative process leveraging on both content and metadata. We develop a community-based and self-organizing system called PicShark in which information entropy—in terms of missing metadata—is gradually alleviated through decentralized instance and schema matching. Our approach focuses on semi-structured metadata and confines computationally expensive operations to the edge of the network, while keeping distributed operations as simple as possible to ensure scalability. PicShark builds on structured Peer-to-Peer networks for distributed look-up operations, but extends the application of self-organization principles to the propagation of metadata and the creation of schema mappings. We demonstrate the practical applicability of our method in an image sharing scenario and provide experimental evidences illustrating the validity of our approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0102-5">A layered framework supporting personal information integration and application design for the semantic desktop</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0102-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Isabel+F.+Cruz%22">Isabel F. Cruz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Huiyong+Xiao%22">Huiyong Xiao</a></li></ol>
          <input type="checkbox" id="24515"/>
          <label for="24515">Abstract</label>
          <div>With the development of inexpensive storage devices, space usage is no longer a bottleneck for computer users. However, the increasingly large amount of personal information poses a critical problem to those users: traditional file organization in hierarchical directories may not be suited to the effective management of personal information because it ignores the semantic associations therein and bears no connection with the applications that users will run. To address such limitations, we present our vision of a semantic desktop, which relies on the use of ontologies to annotate and organize data and on the concept of personal information application (PIA), which is associated with a user’s task. The PIA designer is the tool that is provided for building a variety of PIAs consisting of views (e.g., text, list, table, graph), which are spatially arranged and display interrelated fragments of the overall personal information. The semantic organization of the data follows a layered architecture that models separately the personal information, the domain data, and the application data. The network of concepts that ensues from extensive annotation and explicit associations lends itself well to rich browsing capabilities and to the formulation of expressive database-like queries. These queries are also the basis for the interaction among views of the PIAs in the same desktop or in networked desktops. In the latter case, the concept of desktop service provides for a semantic platform for the integration of information across different desktops and the web. In this paper, we present in detail the semantic organization of the information, the overall system architecture and implementation aspects, queries and their processing, PIAs and the PIA designer, including usability studies on the designer, and the concepts of semantic navigation in a desktop and of interoperation in a network of desktops.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0109-y">System support for exploration and expert feedback in resolving conflicts during integration of metadata</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0109-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22K.+Sel%C3%A7uk+Candan%22">K. Selçuk Candan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Huiping+Cao%22">Huiping Cao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yan+Qi%22">Yan Qi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Maria+Luisa+Sapino%22">Maria Luisa Sapino</a></li></ol>
          <input type="checkbox" id="26384"/>
          <label for="26384">Abstract</label>
          <div>A critical reality in integration is that knowledge obtained from different sources may often be conflicting. Conflict-resolution, whether performed during the design phase or during run-time, can be costly and, if done without a proper understanding of the usage context, can be ineffective. In this paper, we propose a novel exploration and feedback-based approach [FICSR (Pronounced as “fixer”)] to conflict-resolution when integrating metadata from different sources. Rather than relying on purely automated conflict-resolution mechanisms, FICSR brings the domain expert in the conflict-resolution process and informs the integration based on the expert’s feedback. In particular, instead of relying on traditional model based definition of consistency (which, whenever there are conflicts, picks a possible world among many), we introduce a ranked interpretation of the metadata and statements about the metadata. This not only enables FICSR to avoid committing to an interpretation too early, but also helps in achieving a more direct correspondence between the experts’ (subjective) interpretation of the data and the system’s (objective) treatment of the available alternatives. Consequently, the ranked interpretation leads to new opportunities for exploratory feedback for conflict-resolution: within the context of a given statement of interest, (a) a preliminary ranking of candidate matches, representing different resolutions of the conflicts, informs the user about the alternative interpretations of the metadata, while (b) user feedback regarding the preferences among alternatives is exploited to inform the system about the expert’s relevant domain knowledge. The expert’s feedback, then, is used for resolving not only the conflicts among different sources, but also possible mis-alignments due to the initial matching phase. To enable this ${(system \stackrel{_{informs}}{\longleftrightarrow} user)}$ feedback process, we develop data structures and algorithms for efficient off-line conflict/agreement analysis of the integrated metadata. We also develop algorithms for efficient on-line query processing, candidate result enumeration, validity analysis, and system feedback. The results are brought together and evaluated in the Feedback-based InConSistency Resolution (FICSR) system.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0086-6">ArchIS: an XML-based approach to transaction-time temporal database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0086-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Fusheng+Wang%22">Fusheng Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carlo+Zaniolo%22">Carlo Zaniolo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xin+Zhou%22">Xin Zhou</a></li></ol>
          <input type="checkbox" id="83092"/>
          <label for="83092">Abstract</label>
          <div>Effective support for temporal applications by database systems represents an important technical objective that is difficult to achieve since it requires an integrated solution for several problems, including (i) expressive temporal representations and data models, (ii) powerful languages for temporal queries and snapshot queries, (iii) indexing, clustering and query optimization techniques for managing temporal information efficiently, and (iv) architectures that bring together the different pieces of enabling technology into a robust system. In this paper, we present the ArchIS system that achieves these objectives by supporting a temporally grouped data model on top of RDBMS. ArchIS’ architecture uses (a) XML to support temporally grouped (virtual) representations of the database history, (b) XQuery to express powerful temporal queries on such views, (c) temporal clustering and indexing techniques for managing the actual historical data in a relational database, and (d) SQL/XML for executing the queries on the XML views as equivalent queries on the relational database. The performance studies presented in the paper show that ArchIS is quite effective at storing and retrieving under complex query conditions the transaction-time history of relational databases, and can also assure excellent storage efficiency by providing compression as an option. This approach achieves full-functionality transaction-time databases without requiring temporal extensions in XML or database standards, and provides critical support to emerging application areas such as RFID.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0077-7">Disseminating streaming data in a dynamic environment: an adaptive and cost-based approach</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0077-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yongluan+Zhou%22">Yongluan Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li></ol>
          <input type="checkbox" id="39967"/>
          <label for="39967">Abstract</label>
          <div>In a distributed stream processing system, streaming data are continuously disseminated from the sources to the distributed processing servers. To enhance the dissemination efficiency, these servers are typically organized into one or more dissemination trees. In this paper, we focus on the problem of constructing dissemination trees to minimize the average loss of fidelity of the system. We observe that existing heuristic-based approaches can only explore a limited solution space and hence may lead to sub-optimal solutions. On the contrary, we propose an adaptive and cost-based approach. Our cost model takes into account both the processing cost and the communication cost. Furthermore, as a distributed stream processing system is vulnerable to inaccurate statistics, runtime fluctuations of data characteristics, server workloads, and network conditions, we have designed our scheme to be adaptive to these situations: an operational dissemination tree may be incrementally transformed to a more cost-effective one. Our adaptive strategy employs distributed decisions made by the distributed servers independently based on localized statistics collected by each server at runtime. For a relatively static environment, we also propose two static tree construction algorithms relying on apriori system statistics. These static trees can also be used as initial trees in a dynamic environment. We apply our schemes to both single- and multi-object dissemination. Our extensive performance study shows that the adaptive mechanisms are effective in a dynamic context and the proposed static tree construction algorithms perform close to optimal in a static environment.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0082-x">Structural optimization of a full-text n-gram index using relational normalization</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0082-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Min-Soo+Kim%22">Min-Soo Kim</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyu-Young+Whang%22">Kyu-Young Whang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jae-Gil+Lee%22">Jae-Gil Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Min-Jae+Lee%22">Min-Jae Lee</a></li></ol>
          <input type="checkbox" id="13717"/>
          <label for="13717">Abstract</label>
          <div>As the amount of text data grows explosively, an efficient index structure for large text databases becomes ever important. The n-gram inverted index (simply, the n-gram index) has been widely used in information retrieval or in approximate string matching due to its two major advantages: language-neutral and error-tolerant. Nevertheless, the n-gram index also has drawbacks: the size tends to be very large, and the performance of queries tends to be bad. In this paper, we propose the two-level n-gram inverted index (simply, the n-gram/2L index) that significantly reduces the size and improves the query performance by using the relational normalization theory. We first identify that, in the (full-text) n-gram index, there exists redundancy in the position information caused by a non-trivial multivalued dependency. The proposed index eliminates such redundancy by constructing the index in two levels: the front-end index and the back-end index. We formally prove that this two-level construction is identical to the relational normalization process. We call this process structural optimization of the n-gram index. The n-gram/2L index has excellent properties: (1) it significantly reduces the size and improves the performance compared with the n-gram index with these improvements becoming more marked as the database size gets larger; (2) the query processing time increases only very slightly as the query length gets longer. Experimental results using real databases of 1 GB show that the size of the n-gram/2L index is reduced by up to 1.9–2.4 times and, at the same time, the query performance is improved by up to 13.1 times compared with those of the n-gram index. We also compare the n-gram/2L index with Makinen’s compact suffix array (CSA) (Proc. 11th Annual Symposium on Combinatorial Pattern Matching pp. 305–319, 2000) stored in disk. Experimental results show that the n-gram/2L index outperforms the CSA when the query length is short (i.e., less than 15–20), and the CSA is similar to or better than the n-gram/2L index when the query length is long (i.e., more than 15–20).</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0083-9">On the space–time of optimal, approximate and streaming algorithms for synopsis construction problems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0083-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sudipto+Guha%22">Sudipto Guha</a></li></ol>
          <input type="checkbox" id="90659"/>
          <label for="90659">Abstract</label>
          <div>Synopses construction algorithms have been found to be of interest in query optimization, approximate query answering and mining, and over the last few years several good synopsis construction algorithms have been proposed. These algorithms have mostly focused on the running time of the synopsis construction vis-a-vis the synopsis quality. However the space complexity of synopsis construction algorithms has not been investigated as thoroughly. Many of the optimum synopsis construction algorithms are expensive in space. For some of these algorithms the space required to construct the synopsis is significantly larger than the space required to store the input. These algorithms rely on the fact that they require a smaller “working space” and most of the data can be resident on disc. The large space complexity of synopsis construction algorithms is a handicap in several scenarios. In the case of streaming algorithms, space is a fundamental constraint. In case of offline optimal or approximate algorithms, a better space complexity often makes these algorithms much more attractive by allowing them to run in main memory and not use disc, or alternately allows us to scale to significantly larger problems without running out of space. In this paper, we propose a simple and general technique that reduces space complexity of synopsis construction algorithms. As a consequence we show that the notion of “working space” proposed in these contexts is redundant. This technique can be easily applied to many existing algorithms for synopsis construction problems. We demonstrate the performance benefits of our proposal through experiments on real-life and synthetic data. We believe that our algorithm also generalizes to a broader range of dynamic programs beyond synopsis construction.</div>
        </li></ul>
        </li><li>
          <h2>Issue 5 (August 2008)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0046-1">SOLE: scalable on-line execution of continuous queries on spatio-temporal data streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0046-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+F.+Mokbel%22">Mohamed F. Mokbel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Walid+G.+Aref%22">Walid G. Aref</a></li></ol>
          <input type="checkbox" id="53093"/>
          <label for="53093">Abstract</label>
          <div>This paper presents the scalable on-line execution (SOLE) algorithm for continuous and on-line evaluation of concurrent continuous spatio-temporal queries over data streams. Incoming spatio-temporal data streams are processed in-memory against a set of outstanding continuous queries. The SOLE algorithm utilizes the scarce memory resource efficiently by keeping track of only the significant objects. In-memory stored objects are expired (i.e., dropped) from memory once they become insignificant. SOLE is a scalable algorithm where all the continuous outstanding queries share the same buffer pool. In addition, SOLE is presented as a spatio-temporal join between two input streams, a stream of spatio-temporal objects and a stream of spatio-temporal queries. To cope with intervals of high arrival rates of objects and/or queries, SOLE utilizes a load-shedding approach where some of the stored objects are dropped from memory. SOLE is implemented as a pipelined query operator that can be combined with traditional query operators in a query execution plan to support a wide variety of continuous queries. Performance experiments based on a real implementation of SOLE inside a prototype of a data stream management system show the scalability and efficiency of SOLE in highly dynamic environments.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0048-z">Maintaining very large random samples using the geometric file</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0048-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Abhijit+Pol%22">Abhijit Pol</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christopher+Jermaine%22">Christopher Jermaine</a></li><li><a href="http://link.springer.com/search?facet-author=%22Subramanian+Arumugam%22">Subramanian Arumugam</a></li></ol>
          <input type="checkbox" id="45389"/>
          <label for="45389">Abstract</label>
          <div>Random sampling is one of the most fundamental data management tools available. However, most current research involving sampling considers the problem of how to use a sample, and not how to compute one. The implicit assumption is that a “sample” is a small data structure that is easily maintained as new data are encountered, even though simple statistical arguments demonstrate that very large samples of gigabytes or terabytes in size can be necessary to provide high accuracy. No existing work tackles the problem of maintaining very large, disk-based samples from a data management perspective, and no techniques now exist for maintaining very large samples in an online manner from streaming data. In this paper, we present online algorithms for maintaining on-disk samples that are gigabytes or terabytes in size. The algorithms are designed for streaming data, or for any environment where a large sample must be maintained online in a single pass through a data set. The algorithms meet the strict requirement that the sample always be a true, statistically random sample (without replacement) of all of the data processed thus far. We also present algorithms to retrieve small size random sample from large disk-based sample which may be used for various purposes including statistical analyses by a DBMS.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0049-y">The Active XML project: an overview</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0049-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Serge+Abiteboul%22">Serge Abiteboul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Omar+Benjelloun%22">Omar Benjelloun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tova+Milo%22">Tova Milo</a></li></ol>
          <input type="checkbox" id="25614"/>
          <label for="25614">Abstract</label>
          <div>This paper provides an overview of the Active XML project developed at INRIA over the past five years. Active XML (AXML, for short), is a declarative framework that harnesses Web services for distributed data management, and is put to work in a peer-to-peer architecture. The model is based on AXML documents, which are XML documents that may contain embedded calls to Web services, and on AXML services, which are Web services capable of exchanging AXML documents. An AXML peer is a repository of AXML documents that acts both as a client by invoking the embedded service calls, and as a server by providing AXML services, which are generally defined as queries or updates over the persistent AXML documents. The approach gracefully combines stored information with data defined in an intensional manner as well as dynamic information. This simple, rather classical idea leads to a number of technically challenging problems, both theoretical and practical. In this paper, we describe and motivate the AXML model and language, overview the research results obtained in the course of the project, and show how all the pieces come together in our implementation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0050-5">Enhancing histograms by tree-like bucket indices</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0050-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Francesco+Buccafurri%22">Francesco Buccafurri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gianluca+Lax%22">Gianluca Lax</a></li><li><a href="http://link.springer.com/search?facet-author=%22Domenico+Sacc%C3%A0%22">Domenico Saccà</a></li><li><a href="http://link.springer.com/search?facet-author=%22Luigi+Pontieri%22">Luigi Pontieri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Domenico+Rosaci%22">Domenico Rosaci</a></li></ol>
          <input type="checkbox" id="42585"/>
          <label for="42585">Abstract</label>
          <div>Histograms are used to summarize the contents of relations into a number of buckets for the estimation of query result sizes. Several techniques have been proposed in the past for determining bucket boundaries which provide accurate estimations. However, while search strategies for optimal bucket boundaries are rather sophisticated, no much attention has been paid for estimating queries inside buckets and all of the above techniques adopt naive methods for such an estimation. This paper focuses on the problem of improving the estimation inside a bucket once its boundaries have been fixed. The proposed technique is based on the addition, to each bucket, of a memory-word additional information (organized into a tree-like index), storing approximate cumulative frequencies in a hierarchical fashion. Both theoretical analysis and experimental results show that the proposed approach improves the accuracy of the estimation inside buckets, w.r.t. both classical approaches (like continuous value assumption and uniform spread assumption) and a number of alternative ways to organize the additional information. The index is later added to state-of-the-art histograms obtaining the non-obvious result that despite the spatial overhead which reduces the number of allowed buckets once the storage space has been fixed, the original methods are strongly improved in terms of accuracy.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0051-4">Detecting anomalous access patterns in relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0051-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ashish+Kamra%22">Ashish Kamra</a></li><li><a href="http://link.springer.com/search?facet-author=%22Evimaria+Terzi%22">Evimaria Terzi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Elisa+Bertino%22">Elisa Bertino</a></li></ol>
          <input type="checkbox" id="84591"/>
          <label for="84591">Abstract</label>
          <div>A considerable effort has been recently devoted to the development of Database Management Systems (DBMS) which guarantee high assurance and security. An important component of any strong security solution is represented by Intrusion Detection (ID) techniques, able to detect anomalous behavior of applications and users. To date, however, there have been few ID mechanisms proposed which are specifically tailored to function within the DBMS. In this paper, we propose such a mechanism. Our approach is based on mining SQL queries stored in database audit log files. The result of the mining process is used to form profiles that can model normal database access behavior and identify intruders. We consider two different scenarios while addressing the problem. In the first case, we assume that the database has a Role Based Access Control (RBAC) model in place. Under a RBAC system permissions are associated with roles, grouping several users, rather than with single users. Our ID system is able to determine role intruders, that is, individuals while holding a specific role, behave differently than expected. An important advantage of providing an ID technique specifically tailored to RBAC databases is that it can help in protecting against insider threats. Furthermore, the existence of roles makes our approach usable even for databases with large user population. In the second scenario, we assume that there are no roles associated with users of the database. In this case, we look directly at the behavior of the users. We employ clustering algorithms to form concise profiles representing normal user behavior. For detection, we either use these clustered profiles as the roles or employ outlier detection techniques to identify behavior that deviates from the profiles. Our preliminary experimental evaluation on both real and synthetic database traces shows that our methods work well in practical situations.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0052-3">Wavelet synopsis for hierarchical range queries with workloads</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0052-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sudipto+Guha%22">Sudipto Guha</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hyoungmin+Park%22">Hyoungmin Park</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyuseok+Shim%22">Kyuseok Shim</a></li></ol>
          <input type="checkbox" id="42846"/>
          <label for="42846">Abstract</label>
          <div>Synopses structures and approximate query answering have become increasingly important in DSS/ OLAP applications with stringent response time requirements. Range queries are an important class of problems in this domain, and have a wide variety of applications and have been studied in the context of histograms. However, wavelets have been shown to be quite useful in several scenarios and in fact their multi-resolution structure makes them especially appealing for hierarchical domains. Furthermore the fact that the Haar wavelet basis has a linear time algorithm for the computation of coefficients has made the Haar basis one of the important and widely used synopsis structures. Very recently optimal algorithms were proposed for the wavelet synopsis construction problem for equality/point queries. In this paper we investigate the problem of optimum Haar wavelet synopsis construction for range queries with workloads. We provide optimum algorithms as well as approximation heuristics and demonstrate the effectiveness of these algorithms with our extensive experimental evaluation using synthetic and real-life data sets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0053-2">A multi-resolution surface distance model for k-NN query processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0053-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ke+Deng%22">Ke Deng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Heng+Tao+Shen%22">Heng Tao Shen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qing+Liu%22">Qing Liu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kai+Xu%22">Kai Xu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xuemin+Lin%22">Xuemin Lin</a></li></ol>
          <input type="checkbox" id="23343"/>
          <label for="23343">Abstract</label>
          <div>A spatial k-NN query returns k nearest points in a point dataset to a given query point. To measure the distance between two points, most of the literature focuses on the Euclidean distance or the network distance. For many applications, such as wildlife movement, it is necessary to consider the surface distance, which is computed from the shortest path along a terrain surface. In this paper, we investigate the problem of efficient surface k-NN (sk-NN) query processing. This is an important yet highly challenging problem because the underlying environment data can be very large and the computational cost of finding the shortest path on a surface can be very high. To minimize the amount of surface data to be used and the cost of surface distance computation, a multi-resolution surface distance model is proposed in this paper to take advantage of monotonic distance changes when the distances are computed at different resolution levels. Based on this innovative model, sk-NN queries can be processed efficiently by accessing and processing surface data at a just-enough resolution level within a just-enough search region. Our extensive performance evaluations using real world datasets confirm the efficiency of our proposed model.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0054-1">Power-law relationship and self-similarity in the itemset support distribution: analysis and applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0054-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kun-Ta+Chuang%22">Kun-Ta Chuang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiun-Long+Huang%22">Jiun-Long Huang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ming-Syan+Chen%22">Ming-Syan Chen</a></li></ol>
          <input type="checkbox" id="60427"/>
          <label for="60427">Abstract</label>
          <div>In this paper, we identify and explore that the power-law relationship and the self-similar phenomenon appear in the itemset support distribution. The itemset support distribution refers to the distribution of the count of itemsets versus their supports. Exploring the characteristics of these natural phenomena is useful to many applications such as providing the direction of tuning the performance of the frequent-itemset mining. However, due to the explosive number of itemsets, it is prohibitively expensive to retrieve lots of itemsets before we identify the characteristics of the itemset support distribution in targeted data. As such, we also propose a valid and cost-effective algorithm, called algorithm PPL, to extract characteristics of the itemset support distribution. Furthermore, to fully explore the advantages of our discovery, we also propose novel mechanisms with the help of PPL to solve two important problems: (1) determining a subtle parameter for mining approximate frequent itemsets over data streams; and (2) determining the sufficient sample size for mining frequent patterns. As validated in our experimental results, PPL can efficiently and precisely identify the characteristics of the itemset support distribution in various real data. In addition, empirical studies also demonstrate that our mechanisms for those two challenging problems are in orders of magnitude better than previous works, showing the prominent advantage of PPL to be an important pre-processing means for mining applications.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0055-0">A survey of data replication techniques for mobile ad hoc network databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0055-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Prasanna+Padmanabhan%22">Prasanna Padmanabhan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Le+Gruenwald%22">Le Gruenwald</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anita+Vallur%22">Anita Vallur</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohammed+Atiquzzaman%22">Mohammed Atiquzzaman</a></li></ol>
          <input type="checkbox" id="47639"/>
          <label for="47639">Abstract</label>
          <div>A mobile ad hoc network (MANET) is a network that allows mobile servers and clients to communicate in the absence of a fixed infrastructure. MANET is a fast growing area of research as it finds use in a variety of applications. In order to facilitate efficient data access and update, databases are deployed on MANETs. These databases that operate on MANETs are referred to as MANET databases. Since data availability in MANETs is affected by the mobility and power constraints of the servers and clients, data in MANETs are replicated. A number of data replication techniques have been proposed for MANET databases. This paper identifies issues involved in MANET data replication and attempts to classify existing MANET data replication techniques based on the issues they address. The attributes of the replication techniques are also tabulated to facilitate a feature comparison of the existing MANET data replication works. Parameters and performance metrics are also presented to measure the performance of MANET replication techniques. In addition, this paper also proposes criteria for selecting appropriate data replication techniques for various application requirements. Finally, the paper concludes with a discussion on future research directions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0056-z">Guided perturbation: towards private and accurate mining</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0056-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sheng+Zhong%22">Sheng Zhong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhiqiang+Yang%22">Zhiqiang Yang</a></li></ol>
          <input type="checkbox" id="80962"/>
          <label for="80962">Abstract</label>
          <div>There have been two methods for privacy- preserving data mining: the perturbation approach and the cryptographic approach. The perturbation approach is typically very efficient, but it suffers from a tradeoff between accuracy and privacy. In contrast, the cryptographic approach usually maintains accuracy, but it is more expensive in computation and communication overhead. We propose a novel perturbation method, called guided perturbation. Specifically, we focus on a central problem of privacy-preserving data mining—the secure scalar product problem of vertically partitioned data, and give a solution based on guided perturbation, with good, provable privacy guarantee. Our solution achieves accuracy comparable to the cryptographic solutions, while keeping the efficiency of perturbation solutions. Our experimental results show that it can be more than one hundred times faster than a typical cryptographic solution.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0058-x">Temporal XML: modeling, indexing, and query processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0058-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Flavio+Rizzolo%22">Flavio Rizzolo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alejandro+A.+Vaisman%22">Alejandro A. Vaisman</a></li></ol>
          <input type="checkbox" id="69468"/>
          <label for="69468">Abstract</label>
          <div>In this paper we address the problem of modeling and implementing temporal data in XML. We propose a data model for tracking historical information in an XML document and for recovering the state of the document as of any given time. We study the temporal constraints imposed by the data model, and present algorithms for validating a temporal XML document against these constraints, along with methods for fixing inconsistent documents. In addition, we discuss different ways of mapping the abstract representation into a temporal XML document, and introduce TXPath, a temporal XML query language that extends XPath 2.0. In the second part of the paper, we present our approach for summarizing and indexing temporal XML documents. In particular we show that by indexing continuous paths, i.e., paths that are valid continuously during a certain interval in a temporal XML graph, we can dramatically increase query performance. To achieve this, we introduce a new class of summaries, denoted TSummary, that adds the time dimension to the well-known path summarization schemes. Within this framework, we present two new summaries: LCP and Interval summaries. The indexing scheme, denoted TempIndex, integrates these summaries with additional data structures. We give a query processing strategy based on TempIndex and a type of ancestor-descendant encoding, denoted temporal interval encoding. We present a persistent implementation of TempIndex, and a comparison against a system based on a non-temporal path index, and one based on DOM. Finally, we sketch a language for updates, and show that the cost of updating the index is compatible with real-world requirements.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0061-2">SEPIA: estimating selectivities of approximate string predicates in large Databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0061-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Liang+Jin%22">Liang Jin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chen+Li%22">Chen Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rares+Vernica%22">Rares Vernica</a></li></ol>
          <input type="checkbox" id="65764"/>
          <label for="65764">Abstract</label>
          <div>Many database applications have the emerging need to support approximate queries that ask for strings that are similar to a given string, such as “name similar to smith” and “telephone number similar to 412-0964”. Query optimization needs the selectivity of such an approximate predicate, i.e., the fraction of records in the database that satisfy the condition. In this paper, we study the problem of estimating selectivities of approximate string predicates. We develop a novel technique, called Sepia, to solve the problem. Given a bag of strings, our technique groups the strings into clusters, builds a histogram structure for each cluster, and constructs a global histogram. It is based on the following intuition: given a query string q, a preselected string p in a cluster, and a string s in the cluster, based on the proximity between q and p, and the proximity between p and s, we can obtain a probability distribution from a global histogram about the similarity between q and s. We give a full specification of the technique using the edit distance metric. We study challenges in adopting this technique, including how to construct the histogram structures, how to use them to do selectivity estimation, and how to alleviate the effect of non-uniform errors in the estimation. We discuss how to extend the techniques to other similarity functions. Our extensive experiments on real data sets show that this technique can accurately estimate selectivities of approximate string predicates.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0062-1">Reference-based indexing for metric spaces with costly distance measures</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0062-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jayendra+Venkateswaran%22">Jayendra Venkateswaran</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tamer+Kahveci%22">Tamer Kahveci</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christopher+Jermaine%22">Christopher Jermaine</a></li><li><a href="http://link.springer.com/search?facet-author=%22Deepak+Lachwani%22">Deepak Lachwani</a></li></ol>
          <input type="checkbox" id="88534"/>
          <label for="88534">Abstract</label>
          <div>We consider the problem of similarity search in databases with costly metric distance measures. Given limited main memory, our goal is to develop a reference-based index that reduces the number of comparisons in order to answer a query. The idea in reference-based indexing is to select a small set of reference objects that serve as a surrogate for the other objects in the database. We consider novel strategies for selection of references and assigning references to database objects. For dynamic databases with frequent updates, we propose two incremental versions of the selection algorithm. Our experimental results show that our selection and assignment methods far outperform competing methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0064-z">Primal or dual: which promises faster spatiotemporal search?</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0064-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yufei+Tao%22">Yufei Tao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaokui+Xiao%22">Xiaokui Xiao</a></li></ol>
          <input type="checkbox" id="29992"/>
          <label for="29992">Abstract</label>
          <div>The existing predictive spatiotemporal indexes can be classified into two categories, depending on whether they are based on the primal or dual methodology. Although we have gained considerable empirical knowledge about various access methods, currently there is only limited understanding on the theoretical characteristics of the two methodologies. In fact, the experimental results in different papers even contradict each other, regarding the relative superiority of the primal and dual techniques. This paper presents a careful study on the query performance of general primal and dual indexes, and reveals important insight into the behavior of each technique. In particular, we mathematically establish the conditions that determine the superiority of each methodology, and provide rigorous justification for well-known observations that have not been properly explained in the literature. Our analytical findings also resolve the contradiction in the experiments of previous work.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0066-x">Efficient temporal counting with bounded error</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0066-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yufei+Tao%22">Yufei Tao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaokui+Xiao%22">Xiaokui Xiao</a></li></ol>
          <input type="checkbox" id="86632"/>
          <label for="86632">Abstract</label>
          <div>This paper studies aggregate search in transaction time databases. Specifically, each object in such a database can be modeled as a horizontal segment, whose y-projection is its search key, and its x-projection represents the period when the key was valid in history. Given a query timestamp q t and a key range $\vec{q_k}$ , a count-query retrieves the number of objects that are alive at q t , and their keys fall in $\vec{q_k}$ . We provide a method that accurately answers such queries, with error less than $\frac{1}{\varepsilon} + \varepsilon \cdot N_{\rm alive}(q_t)$ , where N alive(q t ) is the number of objects alive at time q t , and ɛ is any constant in (0, 1]. Denoting the disk page size as B, and n =  N / B, our technique requires O(n) space, processes any query in O(log B n) time, and supports each update in O(log B n) amortized I/Os. As demonstrated by extensive experiments, the proposed solutions guarantee query results with extremely high precision (median relative error below 5%), while consuming only a fraction of the space occupied by the existing approaches that promise precise results.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0067-9">Applications of corpus-based semantic similarity and word segmentation to database schema matching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0067-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Aminul+Islam%22">Aminul Islam</a></li><li><a href="http://link.springer.com/search?facet-author=%22Diana+Inkpen%22">Diana Inkpen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Iluju+Kiringa%22">Iluju Kiringa</a></li></ol>
          <input type="checkbox" id="52642"/>
          <label for="52642">Abstract</label>
          <div>In this paper, we present a method for database schema matching: the problem of identifying elements of two given schemas that correspond to each other. Schema matching is useful in e-commerce exchanges, in data integration/warehousing, and in semantic web applications. We first present two corpus-based methods: one method is for determining the semantic similarity of two target words and the other is for automatic word segmentation. Then we present a name-based element-level database schema matching method that exploits both the semantic similarity and the word segmentation methods. Our word similarity method uses pointwise mutual information (PMI) to sort lists of important neighbor words of two target words; the words which are common in both lists are selected and their PMI values are aggregated to calculate the relative similarity score. Our word segmentation method uses corpus type frequency information to choose the type with maximum length and frequency from “desegmented” text. It also uses a modified forward–backward matching technique using maximum length frequency and entropy rate if any non-matching portions of the text exist. Finally, we exploit both the semantic similarity and the word segmentation methods in our proposed name-based element-level schema matching method. This method uses a single property (i.e., element name) for schema matching and nevertheless achieves a measure score that is comparable to the methods that use multiple properties (e.g., element name, text description, data instance, context description). Our schema matching method also uses normalized and modified versions of the longest common subsequence string matching algorithm with weight factors to allow for a balanced combination. We validate our methods with experimental studies, the results of which suggest that these methods can be a useful addition to the set of existing methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0078-6">Mining top-k frequent patterns in the presence of the memory constraint</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0078-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kun-Ta+Chuang%22">Kun-Ta Chuang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiun-Long+Huang%22">Jiun-Long Huang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ming-Syan+Chen%22">Ming-Syan Chen</a></li></ol>
          <input type="checkbox" id="66412"/>
          <label for="66412">Abstract</label>
          <div>We explore in this paper a practicably interesting mining task to retrieve top-k (closed) itemsets in the presence of the memory constraint. Specifically, as opposed to most previous works that concentrate on improving the mining efficiency or on reducing the memory size by best effort, we first attempt to specify the available upper memory size that can be utilized by mining frequent itemsets. To comply with the upper bound of the memory consumption, two efficient algorithms, called MTK and MTK_Close, are devised for mining frequent itemsets and closed itemsets, respectively, without specifying the subtle minimum support. Instead, users only need to give a more human-understandable parameter, namely the desired number of frequent (closed) itemsets k. In practice, it is quite challenging to constrain the memory consumption while also efficiently retrieving top-k itemsets. To effectively achieve this, MTK and MTK_Close are devised as level-wise search algorithms, where the number of candidates being generated-and-tested in each database scan will be limited. A novel search approach, called δ-stair search, is utilized in MTK and MTK_Close to effectively assign the available memory for testing candidate itemsets with various itemset-lengths, which leads to a small number of required database scans. As demonstrated in the empirical study on real data and synthetic data, instead of only providing the flexibility of striking a compromise between the execution efficiency and the memory consumption, MTK and MTK_Close can both achieve high efficiency and have a constrained memory bound, showing the prominent advantage to be practical algorithms of mining frequent patterns.</div>
        </li></ul>
        </li><li>
          <h2>Issue 4 (July 2008)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0023-0">Purpose based access control for privacy protection in relational database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0023-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ji-Won+Byun%22">Ji-Won Byun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ninghui+Li%22">Ninghui Li</a></li></ol>
          <input type="checkbox" id="31496"/>
          <label for="31496">Abstract</label>
          <div>In this article, we present a comprehensive approach for privacy preserving access control based on the notion of purpose. In our model, purpose information associated with a given data element specifies the intended use of the data element. A key feature of our model is that it allows multiple purposes to be associated with each data element and also supports explicit prohibitions, thus allowing privacy officers to specify that some data should not be used for certain purposes. An important issue addressed in this article is the granularity of data labeling, i.e., the units of data with which purposes can be associated. We address this issue in the context of relational databases and propose four different labeling schemes, each providing a different granularity. We also propose an approach to represent purpose information, which results in low storage overhead, and we exploit query modification techniques to support access control based on purpose information. Another contribution of our work is that we address the problem of how to determine the purpose for which certain data are accessed by a given user. Our proposed solution relies on role-based access control (RBAC) models as well as the notion of conditional role which is based on the notions of role attribute and system attribute.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0022-1">Hierarchical clustering for OLAP: the CUBE File approach</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0022-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nikos+Karayannidis%22">Nikos Karayannidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+Sellis%22">Timos Sellis</a></li></ol>
          <input type="checkbox" id="48751"/>
          <label for="48751">Abstract</label>
          <div>This paper deals with the problem of physical clustering of multidimensional data that are organized in hierarchies on disk in a hierarchy-preserving manner. This is called hierarchical clustering. A typical case, where hierarchical clustering is necessary for reducing I/Os during query evaluation, is the most detailed data of an OLAP cube. The presence of hierarchies in the multidimensional space results in an enormous search space for this problem. We propose a representation of the data space that results in a chunk-tree representation of the cube. The model is adaptive to the cube’s extensive sparseness and provides efficient access to subsets of data based on hierarchy value combinations. Based on this representation of the search space we formulate the problem as a chunk-to-bucket allocation problem, which is a packing problem as opposed to the linear ordering approach followed in the literature. We propose a metric to evaluate the quality of hierarchical clustering achieved (i.e., evaluate the solutions to the problem) and formulate the problem as an optimization problem. We prove its NP-Hardness and provide an effective solution based on a linear time greedy algorithm. The solution of this problem leads to the construction of the CUBE File data structure. We analyze in depth all steps of the construction and provide solutions for interesting sub-problems arising, such as the formation of bucket-regions, the storage of large data chunks and the caching of the upper nodes (root directory) in main memory. Finally, we provide an extensive experimental evaluation of the CUBE File’s adaptability to the data space sparseness as well as to an increasing number of data points. The main result is that the CUBE File is highly adaptive to even the most sparse data spaces and for realistic cases of data point cardinalities provides hierarchical clustering of high quality and significant space savings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0026-x">Extending DBMSs with satellite databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0026-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Christian+Plattner%22">Christian Plattner</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gustavo+Alonso%22">Gustavo Alonso</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li></ol>
          <input type="checkbox" id="64522"/>
          <label for="64522">Abstract</label>
          <div>In this paper, we propose an extensible architecture for database engines where satellite databases are used to scale out and implement additional functionality for a centralized database engine. The architecture uses a middleware layer that offers consistent views and a single system image over a cluster of machines with database engines. One of these engines acts as a master copy while the others are read-only snapshots which we call satellites. The satellites are lightweight DBMSs used for scalability and to provide functionality difficult or expensive to implement in the main engine. Our approach also supports the dynamic creation of satellites to be able to autonomously adapt to varying loads. The paper presents the architecture, discusses the research problems it raises, and validates its feasibility with extensive experimental results.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0032-z">DAWN: an efficient framework of DCT for data with error estimation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0032-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ming-Jyh+Hsieh%22">Ming-Jyh Hsieh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wei-Guang+Teng%22">Wei-Guang Teng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ming-Syan+Chen%22">Ming-Syan Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li></ol>
          <input type="checkbox" id="14132"/>
          <label for="14132">Abstract</label>
          <div>On-line analytical processing (OLAP) has become an important component in most data warehouse systems and decision support systems in recent years. In order to deal with the huge amount of data, highly complex queries and increasingly strict response time requirements, approximate query processing has been deemed a viable solution. Most works in this area, however, focus on the space efficiency and are unable to provide quality-guaranteed answers to queries. To remedy this, in this paper, we propose an efficient framework of DCT for dAta With error estimatioN, called DAWN, which focuses on answering range-sum queries from compressed OP-cubes transformed by DCT. Specifically, utilizing the techniques of Geometric series and Euler’s formula, we devise a robust summation function, called the GE function, to answer range queries in constant time, regardless of the number of data cells involved. Note that the GE function can estimate the summation of cosine functions precisely; thus the quality of the answers is superior to that of previous works. Furthermore, an estimator of errors based on the Brown noise assumption (BNA) is devised to provide tight bounds for answering range-sum queries. Our experiment results show that the DAWN framework is scalable to the selectivity of queries and the available storage space. With GE functions and the BNA method, the DAWN framework not only delivers high quality answers for range-sum queries, but also leads to shorter query response time due to its effectiveness in error estimation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0034-x">Anonymity preserving pattern discovery</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0034-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Maurizio+Atzori%22">Maurizio Atzori</a></li><li><a href="http://link.springer.com/search?facet-author=%22Francesco+Bonchi%22">Francesco Bonchi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Fosca+Giannotti%22">Fosca Giannotti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dino+Pedreschi%22">Dino Pedreschi</a></li></ol>
          <input type="checkbox" id="9260"/>
          <label for="9260">Abstract</label>
          <div>It is generally believed that data mining results do not violate the anonymity of the individuals recorded in the source database. In fact, data mining models and patterns, in order to ensure a required statistical significance, represent a large number of individuals and thus conceal individual identities: this is the case of the minimum support threshold in frequent pattern mining. In this paper we show that this belief is ill-founded. By shifting the concept of k -anonymity from the source data to the extracted patterns, we formally characterize the notion of a threat to anonymity in the context of pattern discovery, and provide a methodology to efficiently and effectively identify all such possible threats that arise from the disclosure of the set of extracted patterns. On this basis, we obtain a formal notion of privacy protection that allows the disclosure of the extracted knowledge while protecting the anonymity of the individuals in the source database. Moreover, in order to handle the cases where the threats to anonymity cannot be avoided, we study how to eliminate such threats by means of pattern (not data!) distortion performed in a controlled way.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0036-8">Supporting the data cube lifecycle: the power of ROLAP</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0036-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Konstantinos+Morfonios%22">Konstantinos Morfonios</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Ioannidis%22">Yannis Ioannidis</a></li></ol>
          <input type="checkbox" id="30524"/>
          <label for="30524">Abstract</label>
          <div>The lifecycle of a data cube involves efficient construction and storage, fast query answering, and incremental updating. Existing ROLAP methods that implement data cubes are weak with respect to one or more of the above, focusing mainly on construction and storage. In this paper, we present a comprehensive ROLAP solution that addresses efficiently all functionality in the lifecycle of a cube and can be implemented easily over existing relational servers. It is a family of algorithms centered around a purely ROLAP construction method that provides fast computation of a fully materialized cube in compressed form, is incrementally updateable, and exhibits quick query response times that can be improved by low-cost indexing and caching. This is demonstrated through comprehensive experiments on both synthetic and real-world datasets, whose results have shown great promise for the performance and scalability potential of the proposed techniques, with respect to both the size and dimensionality of the fact table.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0038-6">The optimal sequenced route query</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0038-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mehdi+Sharifzadeh%22">Mehdi Sharifzadeh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohammad+Kolahdouzan%22">Mohammad Kolahdouzan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cyrus+Shahabi%22">Cyrus Shahabi</a></li></ol>
          <input type="checkbox" id="9285"/>
          <label for="9285">Abstract</label>
          <div>Real-world road-planning applications often result in the formulation of new variations of the nearest neighbor (NN) problem requiring new solutions. In this paper, we study an unexplored form of NN queries named optimal sequenced route (OSR) query in both vector and metric spaces. OSR strives to find a route of minimum length starting from a given source location and passing through a number of typed locations in a particular order imposed on the types of the locations. We first transform the OSR problem into a shortest path problem on a large planar graph. We show that a classic shortest path algorithm such as Dijkstra’s is impractical for most real-world scenarios. Therefore, we propose LORD, a light threshold-based iterative algorithm, which utilizes various thresholds to prune the locations that cannot belong to the optimal route. Then we propose R-LORD, an extension of LORD which uses R-tree to examine the threshold values more efficiently. Finally, for applications that cannot tolerate the Euclidean distance as estimation and require exact distance measures in metric spaces (e.g., road networks) we propose PNE that progressively issues NN queries on different point types to construct the optimal route for the OSR query. Our extensive experiments on both real-world and synthetic datasets verify that our algorithms significantly outperform a disk-based variation of the Dijkstra approach in terms of processing time (up to two orders of magnitude) and required workspace (up to 90% reduction on average).</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0039-5">Providing k-anonymity in data mining</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0039-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Arik+Friedman%22">Arik Friedman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ran+Wolff%22">Ran Wolff</a></li><li><a href="http://link.springer.com/search?facet-author=%22Assaf+Schuster%22">Assaf Schuster</a></li></ol>
          <input type="checkbox" id="19603"/>
          <label for="19603">Abstract</label>
          <div>In this paper we present extended definitions of k-anonymity and use them to prove that a given data mining model does not violate the k-anonymity of the individuals represented in the learning examples. Our extension provides a tool that measures the amount of anonymity retained during data mining. We show that our model can be applied to various data mining problems, such as classification, association rule mining and clustering. We describe two data mining algorithms which exploit our extension to guarantee they will generate only k-anonymous output, and provide experimental results for one of them. Finally, we show that our method contributes new and efficient ways to anonymize data and preserve patterns during anonymization.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0035-9">Value complete, column complete, predicate complete</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0035-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Theo+H%C3%A4rder%22">Theo Härder</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andreas+B%C3%BChmann%22">Andreas Bühmann</a></li></ol>
          <input type="checkbox" id="13116"/>
          <label for="13116">Abstract</label>
          <div>Caching is a proven remedy to enhance scalability and availability of software systems as well as to reduce latency of user requests. In contrast to Web caching where single Web objects are accessed and kept ready somewhere in caches in the user-to-server path, database caching uses full-fledged database management systems as caches, close to application servers at the edge of the Web, to adaptively maintain sets of records from a remote database and to evaluate queries on them. We analyze a new class of approaches to database caching where the extensions of query predicates that are to be evaluated are constructed by constraints in the cache. Starting from the key concept of value completeness, we explore the application of cache constraints and their implications on query evaluation correctness and on controllable cache loading called cache safeness. Furthermore, we identify simple rules for the design of cache groups and their optimization before discussing the use of single cache groups and cache group federations. Finally, we argue that predicate completeness can be used to develop new variants of constraint-based database caching.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0043-9">Efficient algorithms for incremental Web log mining with dynamic thresholds</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0043-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jian-Chih+Ou%22">Jian-Chih Ou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chang-Hung+Lee%22">Chang-Hung Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ming-Syan+Chen%22">Ming-Syan Chen</a></li></ol>
          <input type="checkbox" id="26283"/>
          <label for="26283">Abstract</label>
          <div>With the fast increase in Web activities, Web data mining has recently become an important research topic and is receiving a significant amount of interest from both academic and industrial environments. While existing methods are efficient for the mining of frequent path traversal patterns from the access information contained in a log file, these approaches are likely to over evaluate associations. Explicitly, most previous studies of mining path traversal patterns are based on the model of a uniform support threshold, where a single support threshold is used to determine frequent traversal patterns without taking into consideration such important factors as the length of a pattern, the positions of Web pages, and the importance of a particular pattern, etc. As a result, a low support threshold will lead to lots of uninteresting patterns derived whereas a high support threshold may cause some interesting patterns with lower supports to be ignored. In view of this, this paper broadens the horizon of frequent path traversal pattern mining by introducing a flexible model of mining Web traversal patterns with dynamic thresholds. Specifically, we study and apply the Markov chain model to provide the determination of support threshold of Web documents; and further, by properly employing some effective techniques devised for joining reference sequences, the proposed algorithm dynamic threshold miner (DTM) not only possesses the capability of mining with dynamic thresholds, but also significantly improves the execution efficiency as well as contributes to the incremental mining of Web traversal patterns. Performance of algorithm DTM and the extension of existing methods is comparatively analyzed with synthetic and real Web logs. It is shown that the option of algorithm DTM is very advantageous in reducing the number of unnecessary rules produced and leads to prominent performance improvement.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0042-x">Genericity in Java: persistent and database systems implications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0042-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Suad+Alagi%C4%87%22">Suad Alagić</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mark+Royer%22">Mark Royer</a></li></ol>
          <input type="checkbox" id="27418"/>
          <label for="27418">Abstract</label>
          <div>Lack of parametric polymorphism has been a major obstacle for making Java a viable database programming language. Regrettably, a recently accepted solution for genericity in Java 5.0 has far-reaching negative implications for persistent and database systems because of static and dynamic type violations. Severe implications occur in typical database transactions when processing a variety of database collections. Well-known approaches to persistence in Java, including Java’s own persistence mechanism, do not perform correctly due to incorrect dynamic type information that gets promoted to persistence along with objects. Dynamic checking of types of objects fetched from the persistent store may now lead to unexpected type violations. Further problems occur in reflective transactions as Java Core Reflection now allows dynamic type violations without detecting them or throwing standard exceptions. All of this shows that extending Java with parametric polymorphism has not made Java a more viable database programming language. Both legacy systems, such as those based on the Java binding of the ODMG or JDO, and future Java-related persistent and database technologies will be affected. The source of these problems is in an implementation idiom called type erasure. This paper provides formal proofs of the above implications of type erasure along with specific samples of code in Java 5.0 illustrating these violations. The limitations of the virtual platform and extensions required for persistent systems to solve this problem are also elaborated.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0041-y">Privacy-preserving Naïve Bayes classification</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0041-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jaideep+Vaidya%22">Jaideep Vaidya</a></li><li><a href="http://link.springer.com/search?facet-author=%22Murat+Kantarc%C4%B1o%C4%9Flu%22">Murat Kantarcıoğlu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chris+Clifton%22">Chris Clifton</a></li></ol>
          <input type="checkbox" id="9290"/>
          <label for="9290">Abstract</label>
          <div>Privacy-preserving data mining—developing models without seeing the data – is receiving growing attention. This paper assumes a privacy-preserving distributed data mining scenario: data sources collaborate to develop a global model, but must not disclose their data to others. The problem of secure distributed classification is an important one. In many situations, data is split between multiple organizations. These organizations may want to utilize all of the data to create more accurate predictive models while revealing neither their training data/databases nor the instances to be classified. Naïve Bayes is often used as a baseline classifier, consistently providing reasonable classification performance. This paper brings privacy-preservation to that baseline, presenting protocols to develop a Naïve Bayes classifier on both vertically as well as horizontally partitioned data.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0040-z">Scaling and time warping in time series querying</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0040-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ada+Wai-Chee+Fu%22">Ada Wai-Chee Fu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eamonn+Keogh%22">Eamonn Keogh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Leo+Yung+Hang+Lau%22">Leo Yung Hang Lau</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chotirat+Ann+Ratanamahatana%22">Chotirat Ann Ratanamahatana</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raymond+Chi-Wing+Wong%22">Raymond Chi-Wing Wong</a></li></ol>
          <input type="checkbox" id="9957"/>
          <label for="9957">Abstract</label>
          <div>The last few years have seen an increasing understanding that dynamic time warping (DTW), a technique that allows local flexibility in aligning time series, is superior to the ubiquitous Euclidean distance for time series classification, clustering, and indexing. More recently, it has been shown that for some problems, uniform scaling (US), a technique that allows global scaling of time series, may just be as important for some problems. In this work, we note that for many real world problems, it is necessary to combine both DTW and US to achieve meaningful results. This is particularly true in domains where we must account for the natural variability of human actions, including biometrics, query by humming, motion-capture/animation, and handwriting recognition. We introduce the first technique which can handle both DTW and US simultaneously, our techniques involve search pruning by means of a lower bounding technique and multi-dimensional indexing to speed up the search. We demonstrate the utility and effectiveness of our method on a wide range of problems in industry, medicine, and entertainment.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0045-2">Tree-based partition querying: a methodology for computing medoids in large spatial datasets</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0045-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kyriakos+Mouratidis%22">Kyriakos Mouratidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Papadias%22">Dimitris Papadias</a></li><li><a href="http://link.springer.com/search?facet-author=%22Spiros+Papadimitriou%22">Spiros Papadimitriou</a></li></ol>
          <input type="checkbox" id="33385"/>
          <label for="33385">Abstract</label>
          <div>Besides traditional domains (e.g., resource allocation, data mining applications), algorithms for medoid computation and related problems will play an important role in numerous emerging fields, such as location based services and sensor networks. Since the k-medoid problem is NP-hard, all existing work deals with approximate solutions on relatively small datasets. This paper aims at efficient methods for very large spatial databases, motivated by: (1) the high and ever increasing availability of spatial data, and (2) the need for novel query types and improved services. The proposed solutions exploit the intrinsic grouping properties of a data partition index in order to read only a small part of the dataset. Compared to previous approaches, we achieve results of comparable or better quality at a small fraction of the CPU and I/O costs (seconds as opposed to hours, and tens of node accesses instead of thousands). In addition, we study medoid-aggregate queries, where k is not known in advance, but we are asked to compute a medoid set that leads to an average distance close to a user-specified value. Similarly, medoid-optimization queries aim at minimizing both the number of medoids k and the average distance. We also consider the max version for the aforementioned problems, where the goal is to minimize the maximum (instead of the average) distance between any object and its closest medoid. Finally, we investigate bichromatic and weighted medoid versions for all query types, as well as, maximum capacity and dynamic medoids.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0047-0">A data mining proxy approach for efficient frequent itemset mining</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0047-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhiheng+Li%22">Zhiheng Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Guimei+Liu%22">Guimei Liu</a></li></ol>
          <input type="checkbox" id="85897"/>
          <label for="85897">Abstract</label>
          <div>Data mining has attracted a lot of research efforts during the past decade. However, little work has been reported on the efficiency of supporting a large number of users who issue different data mining queries periodically when there are new needs and when data is updated. Our work is motivated by the fact that the pattern-growth method is one of the most efficient methods for frequent pattern mining which constructs an initial tree and mines frequent patterns on top of the tree. In this paper, we present a data mining proxy approach that can reduce the I/O costs to construct an initial tree by utilizing the trees that have already been resident in memory. The tree we construct is the smallest for a given data mining query. In addition, our proxy approach can also reduce CPU cost in mining patterns, because the cost of mining relies on the sizes of trees. The focus of the work is to construct an initial tree efficiently. We propose three tree operations to construct a tree. With a unique coding scheme, we can efficiently project subtrees from on-disk trees or in-memory trees. Our performance study indicated that the data mining proxy significantly reduces the I/O cost to construct trees and CPU cost to mine patterns over the trees constructed.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (May 2008)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0003-4">Enabling Schema-Free XQuery with meaningful query focus</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0003-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yunyao+Li%22">Yunyao Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cong+Yu%22">Cong Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22H.+V.+Jagadish%22">H. V. Jagadish</a></li></ol>
          <input type="checkbox" id="53932"/>
          <label for="53932">Abstract</label>
          <div>The widespread adoption of XML holds the promise that document structure can be exploited to specify precise database queries. However, users may have only a limited knowledge of the XML structure, and may be unable to produce a correct XQuery expression, especially in the context of a heterogeneous information collection. The default is to use keyword-based search and we are all too familiar with how difficult it is to obtain precise answers by these means. We seek to address these problems by introducing the notion of Meaningful Query Focus (MQF) for finding related nodes within an XML document. MQF enables users to take full advantage of the preciseness and efficiency of XQuery without requiring (perfect) knowledge of the document structure. Such a Schema-Free XQuery is potentially of value not just to casual users with partial knowledge of schema, but also to experts working in data integration or data evolution. In such a context, a schema-free query, once written, can be applied universally to multiple data sources that supply similar content under different schemas, and applied “forever” as these schemas evolve. Our experimental evaluation found that it is possible to express a wide variety of queries in a schema-free manner and efficiently retrieve correct results over a broad diversity of schemas. Furthermore, the evaluation of a schema-free query is not expensive: using a novel stack-based algorithm we developed for computing MQF, the overhead is from 1 to 4 times the execution time of an equivalent schema-aware query. The evaluation cost of schema-free queries can be further reduced by as much as 68% using a selectivity-based algorithm we develop to enable the integration of MQF operation into the query pipeline.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0013-2">The B dual -Tree: indexing moving objects by space filling curves in the dual space</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0013-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Man+Lung+Yiu%22">Man Lung Yiu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yufei+Tao%22">Yufei Tao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nikos+Mamoulis%22">Nikos Mamoulis</a></li></ol>
          <input type="checkbox" id="23077"/>
          <label for="23077">Abstract</label>
          <div>Existing spatiotemporal indexes suffer from either large update cost or poor query performance, except for the B x -tree (the state-of-the-art), which consists of multiple B +-trees indexing the 1D values transformed from the (multi-dimensional) moving objects based on a space filling curve (Hilbert, in particular). This curve, however, does not consider object velocities, and as a result, query processing with a B x -tree retrieves a large number of false hits, which seriously compromises its efficiency. It is natural to wonder “can we obtain better performance by capturing also the velocity information, using a Hilbert curve of a higher dimensionality?”. This paper provides a positive answer by developing the B dual -tree, a novel spatiotemporal access method leveraging pure relational methodology. We show, with theoretical evidence, that the B dual -tree indeed outperforms the B x -tree in most circum- stances. Furthermore, our technique can effectively answer progressive spatiotemporal queries, which are poorly supported by B x -trees.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0014-1">Predicting WWW surfing using multiple evidence combination</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0014-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mamoun+Awad%22">Mamoun Awad</a></li><li><a href="http://link.springer.com/search?facet-author=%22Latifur+Khan%22">Latifur Khan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bhavani+Thuraisingham%22">Bhavani Thuraisingham</a></li></ol>
          <input type="checkbox" id="22903"/>
          <label for="22903">Abstract</label>
          <div>The improvement of many applications such as web search, latency reduction, and personalization/ recommendation systems depends on surfing prediction. Predicting user surfing paths involves tradeoffs between model complexity and predictive accuracy. In this paper, we combine two classification techniques, namely, the Markov model and Support Vector Machines (SVM), to resolve prediction using Dempster’s rule. Such fusion overcomes the inability of the Markov model in predicting the unseen data as well as overcoming the problem of multiclassification in the case of SVM, especially when dealing with large number of classes. We apply feature extraction to increase the power of discrimination of SVM. In addition, during prediction we employ domain knowledge to reduce the number of classifiers for the improvement of accuracy and the reduction of prediction time. We demonstrate the effectiveness of our hybrid approach by comparing our results with widely used techniques, namely, SVM, the Markov model, and association rule mining.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0015-0">Histograms based on the minimum description length principle</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0015-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hai+Wang%22">Hai Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kenneth+C.+Sevcik%22">Kenneth C. Sevcik</a></li></ol>
          <input type="checkbox" id="51298"/>
          <label for="51298">Abstract</label>
          <div>Histograms have been widely used for selectivity estimation in query optimization, as well as for fast approximate query answering in many OLAP, data mining, and data visualization applications. This paper presents a new family of histograms, the Hierarchical Model Fitting (HMF) histograms, based on the Minimum Description Length principle. Rather than having each bucket of a histogram described by the same type of model, the HMF histograms employ a local optimal model for each bucket. The improved effectiveness of the locally chosen models offsets more than the overhead of keeping track of the representation of each individual bucket. Through a set of experiments, we show that the HMF histograms are capable of providing more accurate approximations than previously proposed techniques for many real and synthetic data sets across a variety of query workloads.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0016-z">Bandwidth-constrained queries in sensor networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0016-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Antonios+Deligiannakis%22">Antonios Deligiannakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Kotidis%22">Yannis Kotidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Roussopoulos%22">Nick Roussopoulos</a></li></ol>
          <input type="checkbox" id="46793"/>
          <label for="46793">Abstract</label>
          <div>Sensor networks consist of battery-powered wireless devices that are required to operate unattended for long periods of time. Thus, reducing energy drain is of utmost importance when designing algorithms and applications for such networks. Aggregate queries are often used by monitoring applications to assess the status of the network and detect abnormal behavior. Since radio transmission often constitutes the biggest factor of energy drain in a node, in this paper we propose novel algorithms for the evaluation of bandwidth- constrained queries over sensor networks. The goal of our techniques is, given a target bandwidth utilization factor, to program the sensor nodes in a way that seeks to maximize the accuracy of the produced query results at the monitoring node, while always providing strong error guarantees to the monitoring application. This is a distinct difference of our framework from previous techniques that only provide probabilistic guarantees on the accuracy of the query result. Our algorithms are equally applicable when the nodes have ample power resources, but bandwidth consumption needs to be minimized, for instance in densely distributed networks, to ensure proper operation of the nodes. Our experiments with real sensor data show that bandwidth-constrained queries can substantially reduce the number of messages in the network while providing very tight error bounds on the query result.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0017-y">Query processing of multi-way stream window joins</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0017-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Moustafa+A.+Hammad%22">Moustafa A. Hammad</a></li><li><a href="http://link.springer.com/search?facet-author=%22Walid+G.+Aref%22">Walid G. Aref</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ahmed+K.+Elmagarmid%22">Ahmed K. Elmagarmid</a></li></ol>
          <input type="checkbox" id="79381"/>
          <label for="79381">Abstract</label>
          <div>This paper introduces a class of join algorithms, termed W-join, for joining multiple infinite data streams. W-join addresses the infinite nature of the data streams by joining stream data items that lie within a sliding window and that match a certain join condition. In addition to its general applicability in stream query processing, W-join can be used to track the motion of a moving object or detect the propagation of clouds of hazardous material or pollution spills over time in a sensor network environment. We describe two new algorithms for W-join and address variations and local/global optimizations related to specifying the nature of the window constraints to fulfill the posed queries. The performance of the proposed algorithms is studied experimentally in a prototype stream database system, using synthetic data streams and real time-series data. Tradeoffs of the proposed algorithms and their advantages and disadvantages are highlighted, given variations in the aggregate arrival rates of the input data streams and the desired response times per query.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0018-x">Form-based proxy caching for database-backed web sites: keywords and functions</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0018-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Qiong+Luo%22">Qiong Luo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+F.+Naughton%22">Jeffrey F. Naughton</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wenwei+Xue%22">Wenwei Xue</a></li></ol>
          <input type="checkbox" id="56046"/>
          <label for="56046">Abstract</label>
          <div>Web caching proxy servers are essential for improving web performance and scalability, and recent research has focused on making proxy caching work for database-backed web sites. In this paper, we explore a new proxy caching framework that exploits the query semantics of HTML forms. We identify two common classes of form-based queries from real-world database-backed web sites, namely, keyword-based queries and function-embedded queries. Using typical examples of these queries, we study two representative caching schemes within our framework: (i) traditional passive query caching, and (ii) active query caching, in which the proxy cache can service a request by evaluating a query over the contents of the cache. Results from our experimental implementation show that our form-based proxy is a general and flexible approach that efficiently enables active caching schemes for database-backed web sites. Furthermore, handling query containment at the proxy yields significant performance advantages over passive query caching, but extending the power of the active cache to do full semantic caching appears to be less generally effective.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0019-9">Efficient algorithms for mining maximal valid groups</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0019-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yida+Wang%22">Yida Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ee-Peng+Lim%22">Ee-Peng Lim</a></li><li><a href="http://link.springer.com/search?facet-author=%22San-Yih+Hwang%22">San-Yih Hwang</a></li></ol>
          <input type="checkbox" id="72224"/>
          <label for="72224">Abstract</label>
          <div>A valid group is defined as a group of moving users that are within a distance threshold from one another for at least a minimum time duration. Unlike grouping of users determined by traditional clustering algorithms, members of a valid group are expected to stay close to one another during their movement. Each valid group suggests some social grouping that can be used in targeted marketing and social network analysis. The existing valid group mining algorithms are designed to mine a complete set of valid groups from time series of user location data, known as the user movement database. Unfortunately, there are considerable redundancy in the complete set of valid groups. In this paper, we therefore address this problem of mining the set of maximal valid groups. We first extend our previous valid group mining algorithms to mine maximal valid groups, leading to AMG and VGMax algorithms. We further propose the VGBK algorithm based on maximal clique enumeration to mine the maximal valid groups. The performance results of these algorithms under different sets of mining parameters are also reported.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0020-3">Deploying and managing Web services: issues, solutions, and directions</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0020-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Qi+Yu%22">Qi Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xumin+Liu%22">Xumin Liu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Athman+Bouguettaya%22">Athman Bouguettaya</a></li><li><a href="http://link.springer.com/search?facet-author=%22Brahim+Medjahed%22">Brahim Medjahed</a></li></ol>
          <input type="checkbox" id="16808"/>
          <label for="16808">Abstract</label>
          <div>Web services are expected to be the key technology in enabling the next installment of the Web in the form of the Service Web. In this paradigm shift, Web services would be treated as first-class objects that can be manipulated much like data is now manipulated using a database management system. Hitherto, Web services have largely been driven by standards. However, there is a strong impetus for defining a solid and integrated foundation that would facilitate the kind of innovations witnessed in other fields, such as databases. This survey focuses on investigating the different research problems, solutions, and directions to deploying Web services that are managed by an integrated Web Service Management System (WSMS). The survey identifies the key features of a WSMS and conducts a comparative study on how current research approaches and projects fit in.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0021-2">Efficient updates in dynamic XML data: from binary string to quaternary string</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0021-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Changqing+Li%22">Changqing Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tok+Wang+Ling%22">Tok Wang Ling</a></li><li><a href="http://link.springer.com/search?facet-author=%22Min+Hu%22">Min Hu</a></li></ol>
          <input type="checkbox" id="71283"/>
          <label for="71283">Abstract</label>
          <div>XML query processing based on labeling schemes has been thoroughly studied in the past several years. Recently efficient processing of updates in dynamic XML data has gained more attention. However, all the existing techniques have high update cost, they cannot completely avoid re-labeling in XML updates, and they will increase the label size which will influence the query performance. Thus, in this paper we propose a novel Compact Dynamic Binary String (CDBS) encoding to efficiently process updates. CDBS has two important properties which form the foundations of this paper: (1) CDBS supports that CDBS codes can be inserted between any two consecutive CDBS codes with orders kept and without re-encoding the existing codes; (2) CDBS is orthogonal to specific labeling schemes; thus it can be applied broadly to different labeling schemes or other applications to efficiently process updates. Moreover, because CDBS will encounter the overflow problem, we improve CDBS to Compact Dynamic Quaternary String (CDQS) encoding which can completely avoid re-labeling in XML leaf node updates no matter what the labeling schemes are. Meanwhile, we also discuss how to efficiently process internal node updates. We report the experimental results to show that our CDBS and CDQS are superior to previous approaches to process both leaf node and internal node updates.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (March 2008)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-008-0091-4">In memoriam Klaus R. Dittrich (1950–2007)</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-008-0091-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+C.+Lockemann%22">Peter C. Lockemann</a></li></ol>
          <input type="checkbox" id="95068"/>
          <label for="95068">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0085-7">Guest Editors’ message</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0085-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gustavo+Alonso%22">Gustavo Alonso</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Lomet%22">David Lomet</a></li><li><a href="http://link.springer.com/search?facet-author=%22Umesh+Dayal%22">Umesh Dayal</a></li></ol>
          <input type="checkbox" id="50821"/>
          <label for="50821">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0065-y">Maintaining bounded-size sample synopses of evolving datasets</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0065-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rainer+Gemulla%22">Rainer Gemulla</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wolfgang+Lehner%22">Wolfgang Lehner</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+J.+Haas%22">Peter J. Haas</a></li></ol>
          <input type="checkbox" id="41747"/>
          <label for="41747">Abstract</label>
          <div>Perhaps the most flexible synopsis of a database is a uniform random sample of the data; such samples are widely used to speed up processing of analytic queries and data-mining tasks, enhance query optimization, and facilitate information integration. The ability to bound the maximum size of a sample can be very convenient from a system-design point of view, because the task of memory management is simplified, especially when many samples are maintained simultaneously. In this paper, we study methods for incrementally maintaining a bounded-size uniform random sample of the items in a dataset in the presence of an arbitrary sequence of insertions and deletions. For “stable” datasets whose size remains roughly constant over time, we provide a novel sampling scheme, called “random pairing” (RP), that maintains a bounded-size uniform sample by using newly inserted data items to compensate for previous deletions. The RP algorithm is the first extension of the 45-year-old reservoir sampling algorithm to handle deletions; RP reduces to the “passive” algorithm of Babcock et al. when the insertions and deletions correspond to a moving window over a data stream. Experiments show that, when dataset-size fluctuations over time are not too extreme, RP is the algorithm of choice with respect to speed and sample-size stability. For “growing” datasets, we consider algorithms for periodically resizing a bounded-size random sample upwards. We prove that any such algorithm cannot avoid accessing the base data, and provide a novel resizing algorithm that minimizes the time needed to increase the sample size. We also show how to merge uniform samples from disjoint datasets to obtain a uniform sample of the union of the datasets; the merged sample can be incrementally maintained. Our new RPMerge algorithm extends the HRMerge algorithm of Brown and Haas to effectively deal with deletions, thereby facilitating efficient parallel sampling.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0063-0">XML schema refinement through redundancy detection and normalization</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0063-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Cong+Yu%22">Cong Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22H.+V.+Jagadish%22">H. V. Jagadish</a></li></ol>
          <input type="checkbox" id="32747"/>
          <label for="32747">Abstract</label>
          <div>As XML becomes increasingly popular, XML schema design has become an increasingly important issue. One of the central objectives of good schema design is to avoid data redundancies: redundantly stored information can lead not just only to a higher data storage cost but also to increased costs for data transfer and data manipulation. Furthermore, such data redundancies can lead to potential update anomalies, rendering the database inconsistent. One strategy to avoid data redundancies is to design redundancy-free schema from the start on the basis of known functional dependencies. We observe that XML databases are often “casually designed” and XML FDs may not be determined in advance. Under such circumstances, discovering XML data redundancies from the data itself becomes necessary and is an integral part of the schema refinement (or re-design) process. We present the design and implementation of the first system, DiscoverXFD, for efficient discovery of XML data redundancies. It employs a novel XML data structure and introduces a new class of partition-based algorithms. The XML data redundancies are defined on the basis of a new notion of XML functional dependency (XML FD) that (1) extends previous notions by incorporating set elements into the XML FD specification, and (2) maintains tuple-based semantics through the novel concept of Generalized Tree Tuple (GTT). Using this comprehensive XML FD notion, we introduce a new normal form (GTT-XNF) for XML documents, and provide comprehensive comparisons with previous studies. Given the set of data redundancies (in the form of redundancy-indicating XML FDs) discovered by DiscoverXFD, we describe a normalization algorithm for converting any original XML schema into one in GTT-XNF.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0069-7">Trustworthy keyword search for compliance storage</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0069-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Soumyadeb+Mitra%22">Soumyadeb Mitra</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marianne+Winslett%22">Marianne Winslett</a></li><li><a href="http://link.springer.com/search?facet-author=%22Windsor+W.+Hsu%22">Windsor W. Hsu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kevin+Chen-Chuan+Chang%22">Kevin Chen-Chuan Chang</a></li></ol>
          <input type="checkbox" id="2284"/>
          <label for="2284">Abstract</label>
          <div>Intense regulatory focus on secure retention of electronic records has led to a need to ensure that records are trustworthy, i.e., able to provide irrefutable proof and accurate details of past events. In this paper, we analyze the requirements for a trustworthy index to support keyword-based search queries. We argue that trustworthy index entries must be durable—the index must be updated when new documents arrive, and not periodically deleted and rebuilt. To this end, we propose a scheme for efficiently updating an inverted index, based on judicious merging of the posting lists of terms. Through extensive simulations and experiments with two real world data sets and workloads, we demonstrate that the scheme achieves online update speed while maintaining good query performance. We also present and evaluate jump indexes, a novel trustworthy and efficient index for join operations on posting lists for multi-keyword queries. Jump indexes support insert, lookup and range queries in time logarithmic in the number of indexed documents.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0080-z">Databases with uncertainty and lineage</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0080-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Omar+Benjelloun%22">Omar Benjelloun</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anish+Das+Sarma%22">Anish Das Sarma</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Halevy%22">Alon Halevy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Martin+Theobald%22">Martin Theobald</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jennifer+Widom%22">Jennifer Widom</a></li></ol>
          <input type="checkbox" id="59634"/>
          <label for="59634">Abstract</label>
          <div>This paper introduces uldbs, an extension of relational databases with simple yet expressive constructs for representing and manipulating both lineage and uncertainty. Uncertain data and data lineage are two important areas of data management that have been considered extensively in isolation, however many applications require the features in tandem. Fundamentally, lineage enables simple and consistent representation of uncertain data, it correlates uncertainty in query results with uncertainty in the input data, and query processing with lineage and uncertainty together presents computational benefits over treating them separately. We show that the uldb representation is complete, and that it permits straightforward implementation of many relational operations. We define two notions of uldb minimality—data-minimal and lineage-minimal—and study minimization of uldb representations under both notions. With lineage, derived relations are no longer self-contained: their uncertainty depends on uncertainty in the base data. We provide an algorithm for the new operation of extracting a database subset in the presence of interconnected uncertainty. We also show how uldbs enable a new approach to query processing in probabilistic databases. Finally, we describe the current state of the Trio system, our implementation of uldbs under development at Stanford.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0084-8">An adaptive RFID middleware for supporting metaphysical data independence</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0084-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Shawn+R.+Jeffery%22">Shawn R. Jeffery</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Franklin%22">Michael J. Franklin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Minos+Garofalakis%22">Minos Garofalakis</a></li></ol>
          <input type="checkbox" id="3372"/>
          <label for="3372">Abstract</label>
          <div>Sensor devices produce data that are unreliable, low-level, and seldom able to be used directly by applications. In this paper, we propose metaphysical data independence (MDI), a layer of independence that shields applications from the challenges that arise when interacting directly with sensor devices. The key philosophy behind MDI is that applications do not deal with any aspect of physical device data, but rather interface with a high-level reconstruction of the physical world created by a sensor infrastructure. As a concrete instantiation of MDI in such a sensor infrastructure, we detail MDI-SMURF, a Radio Frequency Identification (RFID) middleware system that alleviates issues associated with using RFID data through adaptive techniques based on a novel statistical framework.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0057-y">The Juxtaposed approximate PageRank method for robust PageRank approximation in a peer-to-peer web search network</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0057-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Josiane+Xavier+Parreira%22">Josiane Xavier Parreira</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carlos+Castillo%22">Carlos Castillo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Debora+Donato%22">Debora Donato</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sebastian+Michel%22">Sebastian Michel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="99074"/>
          <label for="99074">Abstract</label>
          <div>We present Juxtaposed approximate PageRank (JXP), a distributed algorithm for computing PageRank-style authority scores of Web pages on a peer-to-peer (P2P) network. Unlike previous algorithms, JXP allows peers to have overlapping content and requires no a priori knowledge of other peers’ content. Our algorithm combines locally computed authority scores with information obtained from other peers by means of random meetings among the peers in the network. This computation is based on a Markov-chain state-lumping technique, and iteratively approximates global authority scores. The algorithm scales with the number of peers in the network and we show that the JXP scores converge to the true PageRank scores that one would obtain with a centralized algorithm. Finally, we show how to deal with misbehaving peers by extending JXP with a reputation model.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0060-3">Delay aware querying with Seaweed</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0060-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dushyanth+Narayanan%22">Dushyanth Narayanan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Austin+Donnelly%22">Austin Donnelly</a></li><li><a href="http://link.springer.com/search?facet-author=%22Richard+Mortier%22">Richard Mortier</a></li><li><a href="http://link.springer.com/search?facet-author=%22Antony+Rowstron%22">Antony Rowstron</a></li></ol>
          <input type="checkbox" id="5220"/>
          <label for="5220">Abstract</label>
          <div>Large highly distributed data sets are poorly supported by current query technologies. Applications such as endsystem-based network management are characterized by data stored on large numbers of endsystems, with frequent local updates and relatively infrequent global one-shot queries. The challenges are scale (103 to 109 endsystems) and endsystem unavailability. In such large systems, a significant fraction of endsystems and their data will be unavailable at any given time. Existing methods to provide high data availability despite endsystem unavailability involve centralizing, redistributing or replicating the data. At large scale these methods are not scalable. We advocate a design that trades query delay for completeness, incrementally returning results as endsystems become available. We also introduce the idea of completeness prediction, which provides the user with explicit feedback about this delay/completeness trade-off. Completeness prediction is based on replication of compact data summaries and availability models. This metadata is orders of magnitude smaller than the data. Seaweed is a scalable query infrastructure supporting incremental results, online in-network aggregation and completeness prediction. It is built on a distributed hash table (DHT) but unlike previous DHT based approaches it does not redistribute data across the network. It exploits the DHT infrastructure for failure-resilient metadata replication, query dissemination, and result aggregation. We analytically compare Seaweed’s scalability against other approaches and also evaluate the Seaweed prototype running on a large-scale network simulator driven by real-world traces.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0059-9">Implementing mapping composition</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0059-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Philip+A.+Bernstein%22">Philip A. Bernstein</a></li><li><a href="http://link.springer.com/search?facet-author=%22Todd+J.+Green%22">Todd J. Green</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sergey+Melnik%22">Sergey Melnik</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alan+Nash%22">Alan Nash</a></li></ol>
          <input type="checkbox" id="17955"/>
          <label for="17955">Abstract</label>
          <div>Mapping composition is a fundamental operation in metadata driven applications. Given a mapping over schemas σ1 and σ2 and a mapping over schemas σ2 and σ3, the composition problem is to compute an equivalent mapping over σ1 and σ3. We describe a new composition algorithm that targets practical applications. It incorporates view unfolding. It eliminates as many σ2 symbols as possible, even if not all can be eliminated. It covers constraints expressed using arbitrary monotone relational operators and, to a lesser extent, non-monotone operators. And it introduces the new technique of left composition. We describe our implementation, explain how to extend it to support user-defined operators, and present experimental results which validate its effectiveness.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 2008)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0074-x">Introduction to the special issue on database and information retrieval integration</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0074-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22W.+Bruce+Croft%22">W. Bruce Croft</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hans-J.+Schek%22">Hans-J. Schek</a></li></ol>
          <input type="checkbox" id="1566"/>
          <label for="1566">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0073-y">Modelling retrieval models in a probabilistic relational algebra with a new operator: the relational Bayes</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0073-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Thomas+Roelleke%22">Thomas Roelleke</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hengzhi+Wu%22">Hengzhi Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jun+Wang%22">Jun Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hany+Azzam%22">Hany Azzam</a></li></ol>
          <input type="checkbox" id="33151"/>
          <label for="33151">Abstract</label>
          <div>This paper presents a probabilistic relational modelling (implementation) of the major probabilistic retrieval models. Such a high-level implementation is useful since it supports the ranking of any object, it allows for the reasoning across structured and unstructured data, and it gives the software (knowledge) engineer control over ranking and thus supports customisation. The contributions of this paper include the specification of probabilistic SQL (PSQL) and probabilistic relational algebra (PRA), a new relational operator for probability estimation (the relational Bayes), the probabilistic relational modelling of retrieval models, a comparison of modelling retrieval with traditional SQL versus modelling retrieval with PSQL, and a comparison of the performance of probability estimation with traditional SQL versus PSQL. The main findings are that the PSQL/PRA paradigm allows for the description of advanced retrieval models, is suitable for solving large-scale retrieval tasks, and outperforms traditional SQL in terms of abstraction and performance regarding probability estimation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0070-1">QQL: A DB&amp;IR Query Language</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0070-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ingo+Schmitt%22">Ingo Schmitt</a></li></ol>
          <input type="checkbox" id="90152"/>
          <label for="90152">Abstract</label>
          <div>Traditional database query languages are based on set theory and crisp first order logic. However, many applications require retrieval-like queries which return result objects associated with a degree of being relevant to the query. Historically, retrieval systems estimate relevance by exploiting hidden object semantics whereas query processing in database systems relies on matching select-conditions with attribute values. Thus, different mechanisms were developed for database and information retrieval systems. In consequence, there is a lack of support for queries involving both retrieval and database search terms. In this work, we introduce the quantum query language (QQL). Its underlying unifying theory is based on the mathematical formalism of quantum mechanics and quantum logic. Van Rijsbergen already discussed the strong relation between the formalism of quantum mechanics and information retrieval. In this work, we interrelate concepts from database query processing to concepts from quantum mechanics and logic. As result, we obtain a common theory which allows us to incorporate seamlessly retrieval search into traditional database query processing.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0068-8">A multi-ranker model for adaptive XML searching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0068-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ho+Lam+Lau%22">Ho Lam Lau</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wilfred+Ng%22">Wilfred Ng</a></li></ol>
          <input type="checkbox" id="25926"/>
          <label for="25926">Abstract</label>
          <div>The evolution of computing technology suggests that it has become more feasible to offer access to Web information in a ubiquitous way, through various kinds of interaction devices such as PCs, laptops, palmtops, and so on. As XML has become a de-facto standard for exchanging Web data, an interesting and practical research problem is the development of models and techniques to satisfy various needs and preferences in searching XML data. In this paper, we employ a list of simple XML tagged keywords as a vehicle for searching XML fragments in a collection of XML documents. In order to deal with the diversified nature of XML documents as well as user preferences, we propose a novel multi-ranker model (MRM), which is able to abstract a spectrum of important XML properties and adapt the features to different XML search needs. The MRM is composed of three ranking levels. The lowest level consists of two categories of similarity and granularity features. At the intermediate level, we define four tailored XML rankers (XRs), which consist of different lower level features and have different strengths in searching XML fragments. The XRs are trained via a learning mechanism called the Ranking Support Vector Machine in a voting Spy Naïve Bayes framework (RSSF). The RSSF takes as input a set of labeled fragments and feature vectors and generates as output Adaptive Rankers (ARs) in the learning process. The ARs are defined over the XRs and generated at the top level of the MRM. We show empirically that the RSSF is able to improve the MRM significantly in the learning process that needs only a small set of training XML fragments. We demonstrate that the trained MRM is able to bring out the strengths of the XRs in order to adapt different preferences and queries.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0072-z">TopX: efficient and versatile top-k query processing for semistructured data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0072-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Martin+Theobald%22">Martin Theobald</a></li><li><a href="http://link.springer.com/search?facet-author=%22Holger+Bast%22">Holger Bast</a></li><li><a href="http://link.springer.com/search?facet-author=%22Debapriyo+Majumdar%22">Debapriyo Majumdar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ralf+Schenkel%22">Ralf Schenkel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="65422"/>
          <label for="65422">Abstract</label>
          <div>Recent IR extensions to XML query languages such as Xpath 1.0 Full-Text or the NEXI query language of the INEX benchmark series reflect the emerging interest in IR-style ranked retrieval over semistructured data. TopX is a top-k retrieval engine for text and semistructured data. It terminates query execution as soon as it can safely determine the k top-ranked result elements according to a monotonic score aggregation function with respect to a multidimensional query. It efficiently supports vague search on both content- and structure-oriented query conditions for dynamic query relaxation with controllable influence on the result ranking. The main contributions of this paper unfold into four main points: (1) fully implemented models and algorithms for ranked XML retrieval with XPath Full-Text functionality, (2) efficient and effective top-k query processing for semistructured data, (3) support for integrating thesauri and ontologies with statistically quantified relationships among concepts, leveraged for word-sense disambiguation and query expansion, and (4) a comprehensive description of the TopX system, with performance experiments on large-scale corpora like TREC Terabyte and INEX Wikipedia.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0075-9">Précis: from unstructured keywords as queries to structured databases as answers</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0075-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alkis+Simitsis%22">Alkis Simitsis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Georgia+Koutrika%22">Georgia Koutrika</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Ioannidis%22">Yannis Ioannidis</a></li></ol>
          <input type="checkbox" id="81398"/>
          <label for="81398">Abstract</label>
          <div>Précis queries represent a novel way of accessing data, which combines ideas and techniques from the fields of databases and information retrieval. They are free-form, keyword-based, queries on top of relational databases that generate entire multi-relation databases, which are logical subsets of the original ones. A logical subset contains not only items directly related to the given query keywords but also items implicitly related to them in various ways, with the purpose of providing to the user much greater insight into the original data. In this paper, we lay the foundations for the concept of logical database subsets that are generated from précis queries under a generalized perspective that removes several restrictions of previous work. In particular, we extend the semantics of précis queries considering that they may contain multiple terms combined through the AND, OR, and NOT operators. On the basis of these extended semantics, we define the concept of a logical database subset, we identify the one that is most relevant to a given query, and we provide algorithms for its generation. Finally, we present an extensive set of experimental results that demonstrate the efficiency and benefits of our approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0071-0">Flexible and efficient IR using array databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0071-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Roberto+Cornacchia%22">Roberto Cornacchia</a></li><li><a href="http://link.springer.com/search?facet-author=%22S%C3%A1ndor+H%C3%A9man%22">Sándor Héman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marcin+Zukowski%22">Marcin Zukowski</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arjen+P.+de+Vries%22">Arjen P. de Vries</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+Boncz%22">Peter Boncz</a></li></ol>
          <input type="checkbox" id="53628"/>
          <label for="53628">Abstract</label>
          <div>The Matrix Framework is a recent proposal by Information Retrieval (IR) researchers to flexibly represent information retrieval models and concepts in a single multi-dimensional array framework. We provide computational support for exactly this framework with the array database system SRAM (Sparse Relational Array Mapping), that works on top of a DBMS. Information retrieval models can be specified in its comprehension-based array query language, in a way that directly corresponds to the underlying mathematical formulas. SRAM efficiently stores sparse arrays in (compressed) relational tables and translates and optimizes array queries into relational queries. In this work, we describe a number of array query optimization rules. To demonstrate their effect on text retrieval, we apply them in the TREC TeraByte track (TREC-TB) efficiency task, using the Okapi BM25 model as our example. It turns out that these optimization rules enable SRAM to automatically translate the BM25 array queries into the relational equivalent of inverted list processing including compression, score materialization and quantization, such as employed by custom-built IR systems. The use of the high-performance MonetDB/X100 relational backend, that provides transparent database compression, allows the system to achieve very fast response times with good precision and low resource usage.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 16 (January 2007 - October 2007)</h1>
          <ol><li>
          <h2>Issue 4 (October 2007)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0171-7">The partitioned exponential file for database storage management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0171-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Christopher+Jermaine%22">Christopher Jermaine</a></li><li><a href="http://link.springer.com/search?facet-author=%22Edward+Omiecinski%22">Edward Omiecinski</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wai+Gen+Yee%22">Wai Gen Yee</a></li></ol>
          <input type="checkbox" id="11158"/>
          <label for="11158">Abstract</label>
          <div>The rate of increase in hard disk storage capacity continues to outpace the rate of decrease in hard disk seek time. This trend implies that the value of a seek is increasing exponentially relative to the value of storage. With this trend in mind, we introduce the partitioned exponential file (PE file) which is a generic storage manager that can be customized for many different types of data (e.g., numerical, spatial, or temporal). The PE file is intended for use in environments with intense update loads and concurrent, analytic queries. Such an environment may be found, for example, in long-running scientific applications which can produce petabytes of data. For example, the proposed Large Synoptic Survey Telescope [36] will produce 50–100 petabytes of observational, scientific data over its multi-year lifetime. This database will never be taken off-line, so bursty update loads of tens of terabytes per day must be handled concurrently with data analysis. In the PE file, data are organized as a series of on-disk sorts with a careful, global organization. Because the PE file relies heavily on sequential I/O, only a fraction of a disk seek is required for a typical record insertion or retrieval. In addition to describing the PE file, we also detail a set of benchmarking experiments for T1SM, which is a PE file customized for use with multi-attribute data records ordered on a single numerical attribute. In our benchmarking, we implement and test many competing data organizations that can be used to index and store such data, such as the B+-Tree, the LSM-Tree, the Buffer Tree, the Stepped Merge Method, and the Y-Tree. As expected, no organization is the best over all benchmarks, but our experiments show that T1SM is the best choice in many situations, suggesting that it is the best overall. Specifically, T1SM performs exceptionally well in the case of a heavy query workload that must be handled concurrently with an intense insertion stream. Our experiments show that T1SM (and its close cousin, the T2SM storage manager for spatial data) can handle very heavy mixed workloads of this type, and still maintain acceptably small query latencies.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0173-5">Dissemination of compressed historical information in sensor networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0173-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Antonios+Deligiannakis%22">Antonios Deligiannakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Kotidis%22">Yannis Kotidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Roussopoulos%22">Nick Roussopoulos</a></li></ol>
          <input type="checkbox" id="87376"/>
          <label for="87376">Abstract</label>
          <div>Sensor nodes are small devices that “measure” their environment and communicate feeds of low-level data values to a base station for further processing and archiving. Dissemination of these multi-valued feeds is challenging because of the limited resources (processing, bandwidth, energy) available in the nodes of the network. In this paper, we first describe the SBR algorithm for compressing multi-valued feeds containing historical data from each sensor. The key to our technique is the base signal, a series of values extracted from the real measurements that is used to provide piece-wise approximation of the measurements. While our basic technique exploits correlations among measurements taken on a single node, we further show how it can be adapted to exploit correlations among multiple nodes in a localized setting. Sensor nodes may form clusters and, within a cluster, a group leader identifies and coalesces similar measurements taken by different nodes. This localized mode of operation further improves the accuracy of the approximation, typically by a factor from 5 to 15. We provide detailed experiments of our algorithms and make direct comparisons against standard approximation techniques like Wavelets, Histograms and the Discrete Cosine Transform, on a variety of error metrics and for real data sets from different domains.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0175-3">Free riding-aware forwarding in Content-Addressable Networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0175-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Klemens+B%C3%B6hm%22">Klemens Böhm</a></li><li><a href="http://link.springer.com/search?facet-author=%22Erik+Buchmann%22">Erik Buchmann</a></li></ol>
          <input type="checkbox" id="86482"/>
          <label for="86482">Abstract</label>
          <div>Research on P2P data structures has tacitly assumed that peers readily participate in the work, i.e., are cooperative. But such participation is voluntary, and free riding is the dominant strategy. This article describes a protocol that renders free riding unattractive, for one particular P2P data structure. The protocol is based on feedback that adjacent nodes exchange. This induces transitive logical networks of nodes that rule out uncooperative peers. The protocol uses proofs of work to deter free riding. To show that cooperative behavior dominates, we have come up with a cost model that quantifies the overall cost of peers, depending on their degree of cooperativeness and many other parameters. The cost model tells us that we can achieve a good discrimination against peers that are less cooperative, with moderate additional cost for cooperative peers. Extensive experiments confirm the validity of our approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0178-0">The Omni-family of all-purpose access methods: a simple and effective way to make similarity search more efficient</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0178-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Caetano+Traina+Jr.%22">Caetano Traina Jr.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Roberto+F.+Santos+Filho%22">Roberto F. Santos Filho</a></li><li><a href="http://link.springer.com/search?facet-author=%22Agma+J.+M.+Traina%22">Agma J. M. Traina</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marcos+R.+Vieira%22">Marcos R. Vieira</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christos+Faloutsos%22">Christos Faloutsos</a></li></ol>
          <input type="checkbox" id="86118"/>
          <label for="86118">Abstract</label>
          <div>Similarity search operations require executing expensive algorithms, and although broadly useful in many new applications, they rely on specific structures not yet supported by commercial DBMS. In this paper we discuss the new Omni-technique, which allows to build a variety of dynamic Metric Access Methods based on a number of selected objects from the dataset, used as global reference objects. We call them as the Omni-family of metric access methods. This technique enables building similarity search operations on top of existing structures, significantly improving their performance, regarding the number of disk access and distance calculations. Additionally, our methods scale up well, exhibiting sub-linear behavior with growing database size.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0002-5">A new intrusion detection system using support vector machines and hierarchical clustering</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0002-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Latifur+Khan%22">Latifur Khan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mamoun+Awad%22">Mamoun Awad</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bhavani+Thuraisingham%22">Bhavani Thuraisingham</a></li></ol>
          <input type="checkbox" id="23160"/>
          <label for="23160">Abstract</label>
          <div>Whenever an intrusion occurs, the security and value of a computer system is compromised. Network-based attacks make it difficult for legitimate users to access various network services by purposely occupying or sabotaging network resources and services. This can be done by sending large amounts of network traffic, exploiting well-known faults in networking services, and by overloading network hosts. Intrusion Detection attempts to detect computer attacks by examining various data records observed in processes on the network and it is split into two groups, anomaly detection systems and misuse detection systems. Anomaly detection is an attempt to search for malicious behavior that deviates from established normal patterns. Misuse detection is used to identify intrusions that match known attack scenarios. Our interest here is in anomaly detection and our proposed method is a scalable solution for detecting network-based anomalies. We use Support Vector Machines (SVM) for classification. The SVM is one of the most successful classification algorithms in the data mining area, but its long training time limits its use. This paper presents a study for enhancing the training time of SVM, specifically when dealing with large data sets, using hierarchical clustering analysis. We use the Dynamically Growing Self-Organizing Tree (DGSOT) algorithm for clustering because it has proved to overcome the drawbacks of traditional hierarchical clustering algorithms (e.g., hierarchical agglomerative clustering). Clustering analysis helps find the boundary points, which are the most qualified data points to train SVM, between two classes. We present a new approach of combination of SVM and DGSOT, which starts with an initial training set and expands it gradually using the clustering structure produced by the DGSOT algorithm. We compare our approach with the Rocchio Bundling technique and random selection in terms of accuracy loss and training time gain using a single benchmark real data set. We show that our proposed variations contribute significantly in improving the training process of SVM with high generalization accuracy and outperform the Rocchio Bundling technique.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0004-3">Efficient query evaluation on probabilistic databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0004-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nilesh+Dalvi%22">Nilesh Dalvi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Suciu%22">Dan Suciu</a></li></ol>
          <input type="checkbox" id="65718"/>
          <label for="65718">Abstract</label>
          <div>We describe a framework for supporting arbitrarily complex SQL queries with “uncertain” predicates. The query semantics is based on a probabilistic model and the results are ranked, much like in Information Retrieval. Our main focus is query evaluation. We describe an optimization algorithm that can compute efficiently most queries. We show, however, that the data complexity of some queries is #P-complete, which implies that these queries do not admit any efficient evaluation methods. For these queries we describe both an approximation algorithm and a Monte-Carlo simulation algorithm.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (July 2007)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0168-2">Multidimensional reverse kNN search</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0168-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yufei+Tao%22">Yufei Tao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Papadias%22">Dimitris Papadias</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiang+Lian%22">Xiang Lian</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaokui+Xiao%22">Xiaokui Xiao</a></li></ol>
          <input type="checkbox" id="67199"/>
          <label for="67199">Abstract</label>
          <div>Given a multidimensional point q, a reverse k nearest neighbor (RkNN) query retrieves all the data points that have q as one of their k nearest neighbors. Existing methods for processing such queries have at least one of the following deficiencies: they (i) do not support arbitrary values of k, (ii) cannot deal efficiently with database updates, (iii) are applicable only to 2D data but not to higher dimensionality, and (iv) retrieve only approximate results. Motivated by these shortcomings, we develop algorithms for exact RkNN processing with arbitrary values of k on dynamic, multidimensional datasets. Our methods utilize a conventional data-partitioning index on the dataset and do not require any pre-computation. As a second step, we extend the proposed techniques to continuous RkNN search, which returns the RkNN results for every point on a line segment. We evaluate the effectiveness of our algorithms with extensive experiments using both real and synthetic datasets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0169-1">Attribute grammars for scalable query processing on XML streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0169-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Christoph+Koch%22">Christoph Koch</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stefanie+Scherzinger%22">Stefanie Scherzinger</a></li></ol>
          <input type="checkbox" id="53458"/>
          <label for="53458">Abstract</label>
          <div>We introduce the notion of XML Stream Attribute Grammars (XSAGs). XSAGs are the first scalable query language for XML streams (running strictly in linear time with bounded memory consumption independent of the size of the stream) that allows for actual data transformations rather than just document filtering. XSAGs are also relatively easy to use for humans. Moreover, the XSAG formalism provides a strong intuition for which queries can or cannot be processed scalably on streams. We introduce XSAGs together with the necessary language-theoretic machinery, study their theoretical properties such as expressiveness and complexity, and discuss their implementation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0177-1">Optimization and evaluation of shortest path queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0177-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Edward+P.+F.+Chan%22">Edward P. F. Chan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Heechul+Lim%22">Heechul Lim</a></li></ol>
          <input type="checkbox" id="92721"/>
          <label for="92721">Abstract</label>
          <div>We investigate the problem of how to evaluate efficiently a collection of shortest path queries on massive graphs that are too big to fit in the main memory. To evaluate a shortest path query efficiently, we introduce two pruning algorithms. These algorithms differ on the extent of materialization of shortest path cost and on how the search space is pruned. By grouping shortest path queries properly, batch processing improves the performance of shortest path query evaluation. Extensive study is also done on fragment sizes, cache sizes and query types that we show that affect the performance of a disk-based shortest path algorithm. The performance and scalability of proposed techniques are evaluated with large road systems in the Eastern United States. To demonstrate that the proposed disk-based algorithms are viable, we show that their search times are significant better than that of main-memory Dijkstra's algorithm.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0037-7">The dynamic predicate: integrating access control with query processing in XML databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0037-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jae-Gil+Lee%22">Jae-Gil Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyu-Young+Whang%22">Kyu-Young Whang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wook-Shin+Han%22">Wook-Shin Han</a></li><li><a href="http://link.springer.com/search?facet-author=%22Il-Yeol+Song%22">Il-Yeol Song</a></li></ol>
          <input type="checkbox" id="67971"/>
          <label for="67971">Abstract</label>
          <div>Recently, access control on XML data has become an important research topic. Previous research on access control mechanisms for XML data has focused on increasing the efficiency of access control itself, but has not addressed the issue of integrating access control with query processing. In this paper, we propose an efficient access control mechanism tightly integrated with query processing for XML databases. We present the novel concept of the dynamic predicate (DP), which represents a dynamically constructed condition during query execution. A DP is derived from instance-level authorizations and constrains accessibility of the elements. The DP allows us to effectively integrate authorization checking into the query plan so that unauthorized elements are excluded in the process of query execution. Experimental results show that the proposed access control mechanism improves query processing time significantly over the state-of-the-art access control mechanisms. We conclude that the DP is highly effective in efficiently checking instance-level authorizations in databases with hierarchical structures.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-007-0044-3">Service oriented architectures: approaches, technologies and research issues</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-007-0044-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mike+P.+Papazoglou%22">Mike P. Papazoglou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Willem-Jan+van+den+Heuvel%22">Willem-Jan van den Heuvel</a></li></ol>
          <input type="checkbox" id="92945"/>
          <label for="92945">Abstract</label>
          <div>Service-oriented architectures (SOA) is an emerging approach that addresses the requirements of loosely coupled, standards-based, and protocol- independent distributed computing. Typically business operations running in an SOA comprise a number of invocations of these different components, often in an event-driven or asynchronous fashion that reflects the underlying business process needs. To build an SOA a highly distributable communications and integration backbone is required. This functionality is provided by the Enterprise Service Bus (ESB) that is an integration platform that utilizes Web services standards to support a wide variety of communications patterns over multiple transport protocols and deliver value-added capabilities for SOA applications. This paper reviews technologies and approaches that unify the principles and concepts of SOA with those of event-based programing. The paper also focuses on the ESB and describes a range of functions that are designed to offer a manageable, standards-based SOA backbone that extends middleware functionality throughout by connecting heterogeneous components and systems and offers integration services. Finally, the paper proposes an approach to extend the conventional SOA to cater for essential ESB requirements that include capabilities such as service orchestration, “intelligent” routing, provisioning, integrity and security of message as well as service management. The layers in this extended SOA, in short xSOA, are used to classify research issues and current research activities.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 2007)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0001-y">Using a distributed quadtree index in peer-to-peer networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0001-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Egemen+Tanin%22">Egemen Tanin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Aaron+Harwood%22">Aaron Harwood</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hanan+Samet%22">Hanan Samet</a></li></ol>
          <input type="checkbox" id="99951"/>
          <label for="99951">Abstract</label>
          <div>Peer-to-peer (P2P) networks have become a powerful means for online data exchange. Currently, users are primarily utilizing these networks to perform exact-match queries and retrieve complete files. However, future more data intensive applications, such as P2P auction networks, P2P job-search networks, P2P multiplayer games, will require the capability to respond to more complex queries such as range queries involving numerous data types including those that have a spatial component. In this paper, a distributed quadtree index that adapts the MX-CIF quadtree is described that enables more powerful accesses to data in P2P networks. This index has been implemented for various prototype P2P applications and results of experiments are presented. Our index is easy to use, scalable, and exhibits good load-balancing properties. Similar indices can be constructed for various multidimensional data types with both spatial and non-spatial components.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0161-9">SQL extension for spatio-temporal data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0161-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jose+R.+Rios+Viqueira%22">Jose R. Rios Viqueira</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nikos+A.+Lorentzos%22">Nikos A. Lorentzos</a></li></ol>
          <input type="checkbox" id="2594"/>
          <label for="2594">Abstract</label>
          <div>An SQL extension is formalized for the management of spatio-temporal data, i.e. of spatial data that evolves with respect to time. The extension is dedicated to applications such as topography, cartography, and cadastral systems, hence it considers discrete changes both in space and in time. It is based on the rigid formalization of data types and of SQL constructs. Data types are defined in terms of time and spatial quanta. The SQL constructs are defined in terms of a kernel of few relational algebra operations, composed of the well-known operations of the 1NF model and of two more, Unfold and Fold. In conjunction with previous work, it enables the uniform management of 1NF structures that may contain not only spatio-temporal but also either purely temporal or purely spatial or conventional data. The syntax and semantics of the extension is fully consistent with the {SQL:2003} standard.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0164-6">Constrained data clustering by depth control and progressive constraint relaxation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0164-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bi-Ru+Dai%22">Bi-Ru Dai</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cheng-Ru+Lin%22">Cheng-Ru Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ming-Syan+Chen%22">Ming-Syan Chen</a></li></ol>
          <input type="checkbox" id="15070"/>
          <label for="15070">Abstract</label>
          <div>In order to import the domain knowledge or application-dependent parameters into the data mining systems, constraint-based mining has attracted a lot of research attention recently. In this paper, the attributes employed to model the constraints are called constraint attributes and those attributes involved in the objective function to be optimized are called optimization attributes. The constrained clustering considered in this paper is conducted in such a way that the objective function of optimization attributes is optimized subject to the condition that the imposed constraint is satisfied. Explicitly, we address the problem of constrained clustering with numerical constraints, in which the constraint attribute values of any two data items in the same cluster are required to be within the corresponding constraint range. This numerical constrained clustering problem, however, cannot be dealt with by any conventional clustering algorithms. Consequently, we devise several effective and efficient algorithms to solve such a clustering problem. It is noted that due to the intrinsic nature of the numerical constrained clustering, there is an order dependency on the process of attaining the clustering, which in many cases degrades the clustering results. In view of this, we devise a progressive constraint relaxation technique to remedy this drawback and improve the overall performance of clustering results. Explicitly, by using a smaller (tighter) constraint range in earlier iterations of merge, we will have more room to relax the constraint and seek for better solutions in subsequent iterations. It is empirically shown that the progressive constraint relaxation technique is able to improve not only the execution efficiency but also the clustering quality.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0167-3">An adaptive and dynamic dimensionality reduction method for high-dimensional indexing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0167-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Heng+Tao+Shen%22">Heng Tao Shen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaofang+Zhou%22">Xiaofang Zhou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Aoying+Zhou%22">Aoying Zhou</a></li></ol>
          <input type="checkbox" id="20372"/>
          <label for="20372">Abstract</label>
          <div>The notorious “dimensionality curse” is a well-known phenomenon for any multi-dimensional indexes attempting to scale up to high dimensions. One well-known approach to overcome degradation in performance with respect to increasing dimensions is to reduce the dimensionality of the original dataset before constructing the index. However, identifying the correlation among the dimensions and effectively reducing them are challenging tasks. In this paper, we present an adaptive Multi-level Mahalanobis-based Dimensionality Reduction (MMDR) technique for high-dimensional indexing. Our MMDR technique has four notable features compared to existing methods. First, it discovers elliptical clusters for more effective dimensionality reduction by using only the low-dimensional subspaces. Second, data points in the different axis systems are indexed using a single B +-tree. Third, our technique is highly scalable in terms of data size and dimension. Finally, it is also dynamic and adaptive to insertions. An extensive performance study was conducted using both real and synthetic datasets, and the results show that our technique not only achieves higher precision, but also enables queries to be processed efficiently.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0174-4">Path and cache conscious prefetching (PCCP)</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0174-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Zhen+He%22">Zhen He</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alonso+Marquez%22">Alonso Marquez</a></li></ol>
          <input type="checkbox" id="15798"/>
          <label for="15798">Abstract</label>
          <div>Main memory cache performance continues to play an important role in determining the overall performance of object-oriented, object-relational and XML databases. An effective method of improving main memory cache performance is to prefetch or pre-load pages in advance to their usage, in anticipation of main memory cache misses. In this paper we describe a framework for creating prefetching algorithms with the novel features of path and cache consciousness. Path consciousness refers to the use of short sequences of object references at key points in the reference trace to identify paths of navigation. Cache consciousness refers to the use of historical page access knowledge to guess which pages are likely to be main memory cache resident most of the time and then assumes these pages do not exist in the context of prefetching. We have conducted a number of experiments comparing our approach against four highly competitive prefetching algorithms. The results shows our approach outperforms existing prefetching techniques in some situations while performing worse in others. We provide guidelines as to when our algorithm should be used and when others maybe more desirable.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0176-2">MEMS based storage architecture for relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0176-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hailing+Yu%22">Hailing Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Divyakant+Agrawal%22">Divyakant Agrawal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amr+El+Abbadi%22">Amr El Abbadi</a></li></ol>
          <input type="checkbox" id="8865"/>
          <label for="8865">Abstract</label>
          <div>Due to recent advances in semiconductor manufacturing, the gap between main memory and disks is constantly increasing. This leads to a significant performance bottleneck for Relational Database Management Systems. Recent advances in nanotechnology have led to the invention of MicroElectroMechanical Systems (MEMS) based storage technology to replace disks. In this paper, we exploit the physical characteristics of MEMS-based storage devices to develop a placement scheme for relational data that enables retrieval in both row-wise and column-wise manner. We develop algorithms for different relational operations based on this data layout. Our experimental results and analysis demonstrate that this data layout not only improves I/O utilization, but results in better cache performance for a variety of different relational operations.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0005-2">Compression techniques for fast external sorting</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0005-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22John+Yiannis%22">John Yiannis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Justin+Zobel%22">Justin Zobel</a></li></ol>
          <input type="checkbox" id="63554"/>
          <label for="63554">Abstract</label>
          <div>External sorting of large files of records involves use of disk space to store temporary files, processing time for sorting, and transfer time between CPU, cache, memory, and disk. Compression can reduce disk and transfer costs, and, in the case of external sorts, cut merge costs by reducing the number of runs. It is therefore plausible that overall costs of external sorting could be reduced through use of compression. In this paper, we propose new compression techniques for data consisting of sets of records. The best of these techniques, based on building a trie of variable-length common strings, provides fast compression and decompression and allows random access to individual records. We show experimentally that our trie-based compression leads to significant reduction in sorting costs; that is, it is faster to compress the data, sort it, and then decompress it than to sort the uncompressed data. While the degree of compression is not quite as great as can be obtained with adaptive techniques such as Lempel-Ziv methods, these cannot be applied to sorting. Our experiments show that, in comparison to approaches such as Huffman coding of fixed-length substrings, our novel trie-based method is faster and provides greater size reductions.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 2007)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0031-0">Special issue: best papers of VLDB 2005</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0031-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Laura+M.+Haas%22">Laura M. Haas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Martin+L.+Kersten%22">Martin L. Kersten</a></li></ol>
          <input type="checkbox" id="72017"/>
          <label for="72017">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0029-7">Algorithms and analyses for maximal vector computation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0029-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Parke+Godfrey%22">Parke Godfrey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ryan+Shipley%22">Ryan Shipley</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jarek+Gryz%22">Jarek Gryz</a></li></ol>
          <input type="checkbox" id="24971"/>
          <label for="24971">Abstract</label>
          <div>The maximal vector problem is to identify the maximals over a collection of vectors. This arises in many contexts and, as such, has been well studied.The problem recently gained renewed attention with skyline queries for relational databases and with work to develop skyline algorithms that are external and relationally well behaved. While many algorithms have been proposed, how they perform has been unclear. We study the performance of, and design choices behind, these algorithms. We prove runtime bounds based on the number of vectors N and the dimensionality K. Early algorithms based on divide and conquer established seemingly good average and worst-case asymptotic runtimes. In fact, the problem can be solved in $\mathcal{O}(KN)$ average-case (holding K as fixed). We prove, however, that the performance is quite bad with respect to K. We demonstrate that the more recent skyline algorithms are better behaved, and can also achieve $\mathcal{O}(KN)$ average-case. While K matters for these, in practice, its effect vanishes in the asymptotic. We introduce a new external algorithm, LESS, that is more efficient and better behaved. We evaluate LESS’s effectiveness and improvement over the field, and prove that its average-case running time is $\mathcal{O}(KN)$ .</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0027-9">View matching for outer-join views</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0027-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Per-%C3%85ke+Larson%22">Per-Åke Larson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jingren+Zhou%22">Jingren Zhou</a></li></ol>
          <input type="checkbox" id="68533"/>
          <label for="68533">Abstract</label>
          <div>Prior work on computing queries from materialized views has focused on views defined by expressions consisting of selection, projection, and inner joins, with an optional aggregation on top (SPJG views). This paper provides a view matching algorithm for views that may also contain outer joins (SPOJG views). The algorithm relies on a normal form for outer-join expressions and is not based on bottom-up syntactic matching of expressions. It handles any combination of inner and outer joins, deals correctly with SQL bag semantics, and exploits not-null constraints, uniqueness constraints and foreign key constraints.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0030-1">Consistent selectivity estimation via maximum entropy</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0030-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22V.+Markl%22">V. Markl</a></li><li><a href="http://link.springer.com/search?facet-author=%22P.+J.+Haas%22">P. J. Haas</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Kutsch%22">M. Kutsch</a></li><li><a href="http://link.springer.com/search?facet-author=%22N.+Megiddo%22">N. Megiddo</a></li><li><a href="http://link.springer.com/search?facet-author=%22U.+Srivastava%22">U. Srivastava</a></li><li><a href="http://link.springer.com/search?facet-author=%22T.+M.+Tran%22">T. M. Tran</a></li></ol>
          <input type="checkbox" id="50578"/>
          <label for="50578">Abstract</label>
          <div>Cost-based query optimizers need to estimate the selectivity of conjunctive predicates when comparing alternative query execution plans. To this end, advanced optimizers use multivariate statistics to improve information about the joint distribution of attribute values in a table. The joint distribution for all columns is almost always too large to store completely, and the resulting use of partial distribution information raises the possibility that multiple, non-equivalent selectivity estimates may be available for a given predicate. Current optimizers use cumbersome ad hoc methods to ensure that selectivities are estimated in a consistent manner. These methods ignore valuable information and tend to bias the optimizer toward query plans for which the least information is available, often yielding poor results. In this paper we present a novel method for consistent selectivity estimation based on the principle of maximum entropy (ME). Our method exploits all available information and avoids the bias problem. In the absence of detailed knowledge, the ME approach reduces to standard uniformity and independence assumptions. Experiments with our prototype implementation in DB2 UDB show that use of the ME approach can improve the optimizer’s cardinality estimates by orders of magnitude, resulting in better plan quality and significantly reduced query execution times. For almost all queries, these improvements are obtained while adding only tens of milliseconds to the overall time required for query optimization.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0025-y">Cache-conscious frequent pattern mining on modern and emerging processors</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0025-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Amol+Ghoting%22">Amol Ghoting</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gregory+Buehrer%22">Gregory Buehrer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Srinivasan+Parthasarathy%22">Srinivasan Parthasarathy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Daehyun+Kim%22">Daehyun Kim</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anthony+Nguyen%22">Anthony Nguyen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yen-Kuang+Chen%22">Yen-Kuang Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pradeep+Dubey%22">Pradeep Dubey</a></li></ol>
          <input type="checkbox" id="71929"/>
          <label for="71929">Abstract</label>
          <div>Algorithms are typically designed to exploit the current state of the art in processor technology. However, as processor technology evolves, said algorithms are often unable to derive the maximum achievable performance on these modern architectures. In this paper, we examine the performance of frequent pattern mining algorithms on a modern processor. A detailed performance study reveals that even the best frequent pattern mining implementations, with highly efficient memory managers, still grossly under-utilize a modern processor. The primary performance bottlenecks are poor data locality and low instruction level parallelism (ILP). We propose a cache-conscious prefix tree to address this problem. The resulting tree improves spatial locality and also enhances the benefits from hardware cache line prefetching. Furthermore, the design of this data structure allows the use of path tiling, a novel tiling strategy, to improve temporal locality. The result is an overall speedup of up to 3.2 when compared with state of the art implementations. We then show how these algorithms can be improved further by realizing a non-naive thread-based decomposition that targets simultaneously multi-threaded processors (SMT). A key aspect of this decomposition is to ensure cache re-use between threads that are co-scheduled at a fine granularity. This optimization affords an additional speedup of 50%, resulting in an overall speedup of up to 4.8. The proposed optimizations also provide performance improvements on SMPs, and will most likely be beneficial on emerging processors.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0024-z">eTuner: tuning schema matching software using synthetic scenarios</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0024-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yoonkyong+Lee%22">Yoonkyong Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mayssam+Sayyadian%22">Mayssam Sayyadian</a></li><li><a href="http://link.springer.com/search?facet-author=%22AnHai+Doan%22">AnHai Doan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arnon+S.+Rosenthal%22">Arnon S. Rosenthal</a></li></ol>
          <input type="checkbox" id="87740"/>
          <label for="87740">Abstract</label>
          <div>Most recent schema matching systems assemble multiple components, each employing a particular matching technique. The domain user mustthen tune the system: select the right component to be executed and correctly adjust their numerous “knobs” (e.g., thresholds, formula coefficients). Tuning is skill and time intensive, but (as we show) without it the matching accuracy is significantly inferior. We describe eTuner, an approach to automatically tune schema matching systems. Given a schema S, we match S against synthetic schemas, for which the ground truth mapping is known, and find a tuning that demonstrably improves the performance of matching S against real schemas. To efficiently search the huge space of tuning configurations, eTuner works sequentially, starting with tuning the lowest level components. To increase the applicability of eTuner, we develop methods to tune a broad range of matching components. While the tuning process is completely automatic, eTuner can also exploit user assistance (whenever available) to further improve the tuning quality. We employed eTuner to tune four recently developed matching systems on several real-world domains. The results show that eTuner produced tuned matching systems that achieve higher accuracy than using the systems with currently possible tuning methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0033-y">OLAP over uncertain and imprecise data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0033-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Doug+Burdick%22">Doug Burdick</a></li><li><a href="http://link.springer.com/search?facet-author=%22Prasad+M.+Deshpande%22">Prasad M. Deshpande</a></li><li><a href="http://link.springer.com/search?facet-author=%22T.+S.+Jayram%22">T. S. Jayram</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raghu+Ramakrishnan%22">Raghu Ramakrishnan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shivakumar+Vaithyanathan%22">Shivakumar Vaithyanathan</a></li></ol>
          <input type="checkbox" id="49005"/>
          <label for="49005">Abstract</label>
          <div>We extend the OLAP data model to represent data ambiguity, specifically imprecision and uncertainty, and introduce an allocation-based approach to the semantics of aggregation queries over such data. We identify three natural query properties and use them to shed light on alternative query semantics. While there is much work on representing and querying ambiguous data, to our knowledge this is the first paper to handle both imprecision and uncertainty in an OLAP setting.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0028-8">A framework for efficient regression tests on database applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0028-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Florian+Haftmann%22">Florian Haftmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Donald+Kossmann%22">Donald Kossmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eric+Lo%22">Eric Lo</a></li></ol>
          <input type="checkbox" id="85802"/>
          <label for="85802">Abstract</label>
          <div>Regression testing is an important software maintenance activity to ensure the integrity of a software after modification. However, most methods and tools developed for software testing today do not work well for database applications; these tools only work well if applications are stateless or tests can be designed in such a way that they do not alter the state. To execute tests for database applications efficiently, the challenge is to control the state of the database during testing and to order the test runs such that expensive database reset operations that bring the database into the right state need to be executed as seldom as possible. This work devises a regression testing framework for database applications so that test runs can be executed in parallel. The goal is to achieve linear speed-up and/or exploit the available resources as well as possible. This problem is challenging because parallel testing needs to consider both load balancing and controlling the state of the database. Experimental results show that test run execution can achieve linear speed-up by using the proposed framework.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 15 (January 2006 - November 2006)</h1>
          <ol><li>
          <h2>Issue 4 (November 2006)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0012-3">Guest editorial: special issue on privacy preserving data management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0012-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Elena+Ferrari%22">Elena Ferrari</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bhavani+Thuraisingham%22">Bhavani Thuraisingham</a></li></ol>
          <input type="checkbox" id="1393"/>
          <label for="1393">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0010-5">A privacy-preserving technique for Euclidean distance-based mining algorithms using Fourier-related transforms</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0010-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Shibnath+Mukherjee%22">Shibnath Mukherjee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhiyuan+Chen%22">Zhiyuan Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Aryya+Gangopadhyay%22">Aryya Gangopadhyay</a></li></ol>
          <input type="checkbox" id="86151"/>
          <label for="86151">Abstract</label>
          <div>Privacy preserving data mining has become increasingly popular because it allows sharing of privacy-sensitive data for analysis purposes. However, existing techniques such as random perturbation do not fare well for simple yet widely used and efficient Euclidean distance-based mining algorithms. Although original data distributions can be pretty accurately reconstructed from the perturbed data, distances between individual data points are not preserved, leading to poor accuracy for the distance-based mining methods. Besides, they do not generally focus on data reduction. Other studies on secure multi-party computation often concentrate on techniques useful to very specific mining algorithms and scenarios such that they require modification of the mining algorithms and are often difficult to generalize to other mining algorithms or scenarios. This paper proposes a novel generalized approach using the well-known energy compaction power of Fourier-related transforms to hide sensitive data values and to approximately preserve Euclidean distances in centralized and distributed scenarios to a great degree of accuracy. Three algorithms to select the most important transform coefficients are presented, one for a centralized database case, the second one for a horizontally partitioned, and the third one for a vertically partitioned database case. Experimental results demonstrate the effectiveness of the proposed approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0008-z">A secure distributed framework for achieving k-anonymity</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0008-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wei+Jiang%22">Wei Jiang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chris+Clifton%22">Chris Clifton</a></li></ol>
          <input type="checkbox" id="30238"/>
          <label for="30238">Abstract</label>
          <div>k-anonymity provides a measure of privacy protection by preventing re-identification of data to fewer than a group of k data items. While algorithms exist for producing k-anonymous data, the model has been that of a single source wanting to publish data. Due to privacy issues, it is common that data from different sites cannot be shared directly. Therefore, this paper presents a two-party framework along with an application that generates k-anonymous data from two vertically partitioned sources without disclosing data from one site to the other. The framework is privacy preserving in the sense that it satisfies the secure definition commonly defined in the literature of Secure Multiparty Computation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0006-1">Succinct representation of flexible and privacy-preserving access rights</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0006-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Marina+Blanton%22">Marina Blanton</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mikhail+Atallah%22">Mikhail Atallah</a></li></ol>
          <input type="checkbox" id="81264"/>
          <label for="81264">Abstract</label>
          <div>We explore the problem of portable and flexible privacy preserving access rights that permit access to a large collection of digital goods. Privacy-preserving access control means that the service provider can neither learn what access rights a customer has nor link a request to access an item to a particular customer, thus maintaining privacy of both customer activity and customer access rights. Flexible access rights allow a customer to choose a subset of items or groups of items from the repository, obtain access to and be charged only for the items selected. And portability of access rights means that the rights themselves can be stored on small devices of limited storage space and computational capabilities such as smartcards or sensors, and therefore the rights must be enforced using the limited resources available. In this paper, we present and compare two schemes that address the problem of such access rights. We show that much can be achieved if one allows for even a negligible amount of false positives – items that were not requested by the customer, but inadvertently were included in the customer access right representation due to constrained space resources. But minimizing false positives is one of many other desiderata that include protection against sharing of false positives information by unscrupulous users, providing the users with transaction untraceability and unlinkability, and forward compatibility of the scheme. Our first scheme does not place any constraints on the amount of space available on the limited-capacity storage device, and searches for the best representation that meets the requirements. The second scheme, on the other hand, has (modest) requirements on the storage space available, but guarantees a low rate of false positives: with O(mc) storage space available on the smartcard (where m is the number of items or groups of items included in the subscription and c is a selectable parameter), it achieves a rate of false positives of m −c .</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0007-0">Efficient multivariate data-oriented microaggregation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0007-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Josep+Domingo-Ferrer%22">Josep Domingo-Ferrer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Antoni+Mart%C3%ADnez-Ballest%C3%A9%22">Antoni Martínez-Ballesté</a></li><li><a href="http://link.springer.com/search?facet-author=%22Josep+Maria+Mateo-Sanz%22">Josep Maria Mateo-Sanz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Francesc+Seb%C3%A9%22">Francesc Sebé</a></li></ol>
          <input type="checkbox" id="21947"/>
          <label for="21947">Abstract</label>
          <div>Microaggregation is a family of methods for statistical disclosure control (SDC) of microdata (records on individuals and/or companies), that is, for masking microdata so that they can be released while preserving the privacy of the underlying individuals. The principle of microaggregation is to aggregate original database records into small groups prior to publication. Each group should contain at least k records to prevent disclosure of individual information, where k is a constant value preset by the data protector. Recently, microaggregation has been shown to be useful to achieve k-anonymity, in addition to it being a good masking method. Optimal microaggregation (with minimum within-groups variability loss) can be computed in polynomial time for univariate data. Unfortunately, for multivariate data it is an NP-hard problem. Several heuristic approaches to microaggregation have been proposed in the literature. Heuristics yielding groups with fixed size k tends to be more efficient, whereas data-oriented heuristics yielding variable group size tends to result in lower information loss. This paper presents new data-oriented heuristics which improve on the trade-off between computational complexity and information loss and are thus usable for large datasets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0009-y">Hierarchical hippocratic databases with minimal disclosure for virtual organizations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0009-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Fabio+Massacci%22">Fabio Massacci</a></li><li><a href="http://link.springer.com/search?facet-author=%22John+Mylopoulos%22">John Mylopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nicola+Zannone%22">Nicola Zannone</a></li></ol>
          <input type="checkbox" id="2201"/>
          <label for="2201">Abstract</label>
          <div>The protection of customer privacy is a fundamental issue in today’s corporate marketing strategies. Not surprisingly, many research efforts have proposed new privacy-aware technologies. Among them, Hippocratic databases offer mechanisms for enforcing privacy rules in database systems for inter-organizational business processes (also known as virtual organizations). This paper extends these mechanisms to allow for hierarchical purposes, distributed authorizations and minimal disclosure supporting the business processes of virtual organizations that want to offer their clients a number of ways to fulfill a service. Specifically, we use a goal-oriented approach to analyze privacy policies of the enterprises involved in a business process. On the basis of the purpose hierarchy derived through a goal refinement process, we provide algorithms for determining the minimum set of authorizations needed to achieve a service. This allows us to automatically derive access control policies for an inter-organizational business process from the collection of privacy policies associated with different participating enterprises. By using effective on-line algorithms, the derivation of such minimal information can also be done on-the-fly by the customer wishing to access a service.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-006-0011-4">Privacy leakage in multi-relational databases: a semi-supervised learning perspective</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-006-0011-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hui+Xiong%22">Hui Xiong</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Steinbach%22">Michael Steinbach</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vipin+Kumar%22">Vipin Kumar</a></li></ol>
          <input type="checkbox" id="87256"/>
          <label for="87256">Abstract</label>
          <div>In multi-relational databases, a view, which is a context- and content-dependent subset of one or more tables (or other views), is often used to preserve privacy by hiding sensitive information. However, recent developments in data mining present a new challenge for database security even when traditional database security techniques, such as database access control, are employed. This paper presents a data mining framework using semi-supervised learning that demonstrates the potential for privacy leakage in multi-relational databases. Many different types of semi-supervised learning techniques, such as the K-nearest neighbor (KNN) method, can be used to demonstrate privacy leakage. However, we also introduce a new approach to semi-supervised learning, hyperclique pattern-based semi-supervised learning (HPSL), which differs from traditional semi-supervised learning approaches in that it considers the similarity among groups of objects instead of only pairs of objects. Our experimental results show that both the KNN and HPSL methods have the ability to compromise database security, although the HPSL is better at this privacy violation (has higher prediction accuracy) than the KNN method. Finally, we provide a principle for avoiding privacy leakage in multi-relational databases via semi-supervised learning and illustrate this principle with a simple preventive technique whose effectiveness is demonstrated by experiments.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (September 2006)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0162-8">Answering queries using materialized views with minimum size</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0162-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rada+Chirkova%22">Rada Chirkova</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chen+Li%22">Chen Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jia+Li%22">Jia Li</a></li></ol>
          <input type="checkbox" id="98282"/>
          <label for="98282">Abstract</label>
          <div>In this paper, we study the following problem. Given a database and a set of queries, we want to find a set of views that can compute the answers to the queries, such that the amount of space, in bytes, required to store the viewset is minimum on the given database. (We also handle problem instances where the input has a set of database instances, as described by an oracle that returns the sizes of view relations for given view definitions.) This problem is important for applications such as distributed databases, data warehousing, and data integration. We explore the decidability and complexity of the problem for workloads of conjunctive queries. We show that results differ significantly depending on whether the workload queries have self-joins. Further, for queries without self-joins we describe a very compact search space of views, which contains all views in at least one optimal viewset. We present techniques for finding a minimum-size viewset for a single query without self-joins by using the shape of the query and its constraints, and validate the approach by extensive experiments.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0163-7">Spatio-temporal data reduction with deterministic error bounds</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0163-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hu+Cao%22">Hu Cao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ouri+Wolfson%22">Ouri Wolfson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Goce+Trajcevski%22">Goce Trajcevski</a></li></ol>
          <input type="checkbox" id="61373"/>
          <label for="61373">Abstract</label>
          <div>A common way of storing spatio-temporal information about mobile devices is in the form of a 3D (2D geography + time) trajectory. We argue that when cellular phones and Personal Digital Assistants become location-aware, the size of the spatio-temporal information generated may prohibit efficient processing. We propose to adopt a technique studied in computer graphics, namely line-simplification, as an approximation technique to solve this problem. Line simplification will reduce the size of the trajectories. Line simplification uses a distance function in producing the trajectory approximation. We postulate the desiderata for such a distance-function: it should be sound, namely the error of the answers to spatio-temporal queries must be bounded. We analyze several distance functions, and prove that some are sound in this sense for some types of queries, while others are not. A distance function that is sound for all common spatio-temporal query types is introduced and analyzed. Then we propose an aging mechanism which gradually shrinks the size of the trajectories as time progresses. We also propose to adopt existing linguistic constructs to manage the uncertainty introduced by the trajectory approximation. Finally, we analyze experimentally the effectiveness of line-simplification in reducing the size of a trajectories database.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0166-4">Nearest and reverse nearest neighbor queries for moving objects</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0166-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rimantas+Benetis%22">Rimantas Benetis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gytis+Kar%C4%89iauskas%22">Gytis Karĉiauskas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Simonas+%C5%9Caltenis%22">Simonas Ŝaltenis</a></li></ol>
          <input type="checkbox" id="14224"/>
          <label for="14224">Abstract</label>
          <div>With the continued proliferation of wireless communications and advances in positioning technologies, algorithms for efficiently answering queries about large populations of moving objects are gaining interest. This paper proposes algorithms for k nearest and reverse k nearest neighbor queries on the current and anticipated future positions of points moving continuously in the plane. The former type of query returns k objects nearest to a query object for each time point during a time interval, while the latter returns the objects that have a specified query object as one of their k closest neighbors, again for each time point during a time interval. In addition, algorithms for so-called persistent and continuous variants of these queries are provided. The algorithms are based on the indexing of object positions represented as linear functions of time. The results of empirical performance experiments are reported.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0170-8">Dependency trees in sub-linear time and bounded memory</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0170-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dan+Pelleg%22">Dan Pelleg</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andrew+Moore%22">Andrew Moore</a></li></ol>
          <input type="checkbox" id="85667"/>
          <label for="85667">Abstract</label>
          <div>We focus on the problem of efficient learning of dependency trees. Once grown, they can be used as a special case of a Bayesian network, for PDF approximation, and for many other uses. Given the data, a well-known algorithm can fit an optimal tree in time that is quadratic in the number of attributes and linear in the number of records. We show how to modify it to exploit partial knowledge about edge weights. Experimental results show running time that is near-constant in the number of records, without significant loss in accuracy of the generated trees.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0172-6">Query optimization in XML structured-document databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0172-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dunren+Che%22">Dunren Che</a></li><li><a href="http://link.springer.com/search?facet-author=%22Karl+Aberer%22">Karl Aberer</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li></ol>
          <input type="checkbox" id="36457"/>
          <label for="36457">Abstract</label>
          <div>While the information published in the form of XML-compliant documents keeps fast mounting up, efficient and effective query processing and optimization for XML have now become more important than ever. This article reports our recent advances in XML structured-document query optimization. In this article, we elaborate on a novel approach and the techniques developed for XML query optimization. Our approach performs heuristic-based algebraic transformations on XPath queries, represented as PAT algebraic expressions, to achieve query optimization. This article first presents a comprehensive set of general equivalences with regard to XML documents and XML queries. Based on these equivalences, we developed a large set of deterministic algebraic transformation rules for XML query optimization. Our approach is unique, in that it performs exclusively deterministic transformations on queries for fast optimization. The deterministic nature of the proposed approach straightforwardly renders high optimization efficiency and simplicity in implementation. Our approach is a logical-level one, which is independent of any particular storage model. Therefore, the optimizers developed based on our approach can be easily adapted to a broad range of XML data/information servers to achieve fast query optimization. Experimental study confirms the validity and effectiveness of the proposed approach.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (June 2006)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0145-1">Dynamic buffer management with extensible replacement policies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0145-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chong+Leng+Goh%22">Chong Leng Goh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yanfeng+Shu%22">Yanfeng Shu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhiyong+Huang%22">Zhiyong Huang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li></ol>
          <input type="checkbox" id="60815"/>
          <label for="60815">Abstract</label>
          <div>The objective of extensible DBMSs is to ease the construction of specialized DBMSs for nontraditional applications. Although much work has been done in providing various levels of extensibility (e.g., extensibility of data types and operators, query language extensibility, and query optimizer extensibility), there has been very limited research in providing extensibility at the buffer management level. Supporting extensibility at the buffer management level is important as it can contribute significantly to overall system performance. This paper addresses the problem of supporting extensibility of buffer replacement policies. The main contribution is the proposal of a framework for modeling buffer replacement policies. This work is novel in two aspects. First, by providing a uniform and generic specification of buffer replacement policies, the proposed framework unifies existing work in this area. Second, our work introduces a new level of extensibility. None of the existing extensible DBMSs, to our knowledge, provides extensibility at the buffer management level. The proposed framework provides a basis for the construction of an extensible buffer manager as part of a 100% Java-based storage manager. We conducted an extensive performance study to investigate the performance of the proposed framework. The experimental results demonstrate that the proposed framework is indeed feasible for existing DBMSs and improves system performance significantly without costing significant overhead.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0147-z">The CQL continuous query language: semantic foundations and query execution</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0147-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Arvind+Arasu%22">Arvind Arasu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shivnath+Babu%22">Shivnath Babu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jennifer+Widom%22">Jennifer Widom</a></li></ol>
          <input type="checkbox" id="24673"/>
          <label for="24673">Abstract</label>
          <div>CQL, a continuous query language, is supported by the STREAM prototype data stream management system (DSMS) at Stanford. CQL is an expressive SQL-based declarative language for registering continuous queries against streams and stored relations. We begin by presenting an abstract semantics that relies only on “black-box” mappings among streams and relations. From these mappings we define a precise and general interpretation for continuous queries. CQL is an instantiation of our abstract semantics using SQL to map from relations to relations, window specifications derived from SQL-99 to map from streams to relations, and three new operators to map from relations to streams. Most of the CQL language is operational in the STREAM system. We present the structure of CQL's query execution plans as well as details of the most important components: operators, interoperator queues, synopses, and sharing of components among multiple operators and queries. Examples throughout the paper are drawn from the Linear Road benchmark recently proposed for DSMSs. We also curate a public repository of data stream applications that includes a wide variety of queries expressed in CQL. The relative ease of capturing these applications in CQL is one indicator that the language contains an appropriate set of constructs for data stream processing.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0151-3">Indexing spatiotemporal archives</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0151-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Marios+Hadjieleftheriou%22">Marios Hadjieleftheriou</a></li><li><a href="http://link.springer.com/search?facet-author=%22George+Kollios%22">George Kollios</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vassilis+J.+Tsotras%22">Vassilis J. Tsotras</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitrios+Gunopulos%22">Dimitrios Gunopulos</a></li></ol>
          <input type="checkbox" id="7003"/>
          <label for="7003">Abstract</label>
          <div>Spatiotemporal objects – that is, objects that evolve over time – appear in many applications. Due to the nature of such applications, storing the evolution of objects through time in order to answer historical queries (queries that refer to past states of the evolution) requires a very large specialized database, what is termed in this article a spatiotemporal archive. Efficient processing of historical queries on spatiotemporal archives requires equally sophisticated indexing schemes. Typical spatiotemporal indexing techniques represent the objects using minimum bounding regions (MBR) extended with a temporal dimension, which are then indexed using traditional multidimensional index structures. However, rough MBR approximations introduce excessive overlap between index nodes, which deteriorates query performance. This article introduces a robust indexing scheme for answering spatiotemporal queries more efficiently. A number of algorithms and heuristics are elaborated that can be used to preprocess a spatiotemporal archive in order to produce finer object approximations, which, in combination with a multiversion index structure, will greatly improve query performance in comparison to the straightforward approaches. The proposed techniques introduce a query efficiency vs. space tradeoff that can help tune a structure according to available resources. Empirical observations for estimating the necessary amount of additional storage space required for improving query performance by a given factor are also provided. Moreover, heuristics for applying the proposed ideas in an online setting are discussed. Finally, a thorough experimental evaluation is conducted to show the merits of the proposed techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0152-x">Modeling and querying moving objects in networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0152-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ralf+Hartmut+G%C3%BCting%22">Ralf Hartmut Güting</a></li><li><a href="http://link.springer.com/search?facet-author=%22Victor+Teixeira+de+Almeida%22">Victor Teixeira de Almeida</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zhiming+Ding%22">Zhiming Ding</a></li></ol>
          <input type="checkbox" id="42594"/>
          <label for="42594">Abstract</label>
          <div>Moving objects databases have become an important research issue in recent years. For modeling and querying moving objects, there exists a comprehensive framework of abstract data types to describe objects moving freely in the 2D plane, providing data types such as moving point or moving region. However, in many applications people or vehicles move along transportation networks. It makes a lot of sense to model the network explicitly and to describe movements relative to the network rather than unconstrained space, because then it is much easier to formulate in queries relationships between moving objects and the network. Moreover, such models can be better supported in indexing and query processing. In this paper, we extend the ADT approach by modeling networks explicitly and providing data types for static and moving network positions and regions. In a highway network, example entities corresponding to these data types are motels, construction areas, cars, and traffic jams. The network model is not too simplistic; it allows one to distinguish simple roads and divided highways and to describe the possible traversals of junctions precisely. The new types and operations are integrated seamlessly into the ADT framework to achieve a relatively simple, consistent and powerful overall model and query language for constrained and unconstrained movement.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 2006)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0144-2">Indexing Multidimensional Time-Series</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0144-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Michail+Vlachos%22">Michail Vlachos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marios+Hadjieleftheriou%22">Marios Hadjieleftheriou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitrios+Gunopulos%22">Dimitrios Gunopulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eamonn+Keogh%22">Eamonn Keogh</a></li></ol>
          <input type="checkbox" id="3270"/>
          <label for="3270">Abstract</label>
          <div>While most time series data mining research has concentrated on providing solutions for a single distance function, in this work we motivate the need for an index structure that can support multiple distance measures. Our specific area of interest is the efficient retrieval and analysis of similar trajectories. Trajectory datasets are very common in environmental applications, mobility experiments, and video surveillance and are especially important for the discovery of certain biological patterns. Our primary similarity measure is based on the longest common subsequence (LCSS) model that offers enhanced robustness, particularly for noisy data, which are encountered very often in real-world applications. However, our index is able to accommodate other distance measures as well, including the ubiquitous Euclidean distance and the increasingly popular dynamic time warping (DTW). While other researchers have advocated one or other of these similarity measures, a major contribution of our work is the ability to support all these measures without the need to restructure the index. Our framework guarantees no false dismissals and can also be tailored to provide much faster response time at the expense of slightly reduced precision/recall. The experimental results demonstrate that our index can help speed up the computation of expensive similarity measures such as the LCSS and the DTW.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0146-0">Grid-partition index: a hybrid method for nearest-neighbor queries in wireless location-based services</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0146-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Baihua+Zheng%22">Baihua Zheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jianliang+Xu%22">Jianliang Xu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wang-Chien+Lee%22">Wang-Chien Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dik+Lun+Lee%22">Dik Lun Lee</a></li></ol>
          <input type="checkbox" id="62998"/>
          <label for="62998">Abstract</label>
          <div>Traditional nearest-neighbor (NN) search is based on two basic indexing approaches: object-based indexing and solution-based indexing. The former is constructed based on the locations of data objects: using some distance heuristics on object locations. The latter is built on a precomputed solution space. Thus, NN queries can be reduced to and processed as simple point queries in this solution space. Both approaches exhibit some disadvantages, especially when employed for wireless data broadcast in mobile computing environments. In this paper, we introduce a new index method, called the grid-partition index, to support NN search in both on-demand access and periodic broadcast modes of mobile computing. The grid-partition index is constructed based on the Voronoi diagram, i.e., the solution space of NN queries. However, it has two distinctive characteristics. First, it divides the solution space into grid cells such that a query point can be efficiently mapped into a grid cell around which the nearest object is located. This significantly reduces the search space. Second, the grid-partition index stores the objects that are potential NNs of any query falling within the cell. The storage of objects, instead of the Voronoi cells, makes the grid-partition index a hybrid of the solution-based and object-based approaches. As a result, it achieves a much more compact representation than the pure solution-based approach and avoids backtracked traversals required in the typical object-based approach, thus realizing the advantages of both approaches. We develop an incremental construction algorithm to address the issue of object update. In addition, we present a cost model to approximate the search cost of different grid partitioning schemes. The performances of the grid-partition index and existing indexes are evaluated using both synthetic and real data. The results show that, overall, the grid-partition index significantly outperforms object-based indexes and solution-based indexes. Furthermore, we extend the grid-partition index to support continuous-nearest-neighbor search. Both algorithms and experimental results are presented.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0148-y">On a confidence gain measure for association rule discovery and scoring</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0148-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Raz+Tamir%22">Raz Tamir</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yehuda+Singer%22">Yehuda Singer</a></li></ol>
          <input type="checkbox" id="16645"/>
          <label for="16645">Abstract</label>
          <div>This article presents a new interestingness measure for association rules called confidence gain (CG). Focus is given to extraction of human associations rather than associations between market products. There are two main differences between the two (human and market associations). The first difference is the strong asymmetry of human associations (e.g., the association “shampoo” → “hair” is much stronger than “hair” → “shampoo”), where in market products asymmetry is less intuitive and less evident. The second is the background knowledge humans employ when presented with a stimulus (input phrase). CG calculates the local confidence of a given term compared to its average confidence throughout a given database. CG is found to outperform several association measures since it captures both the asymmetric notion of an association (as in the confidence measure) while adding the comparison to an expected confidence (as in the lift measure). The use of average confidence introduces the “background knowledge” notion into the CG measure. Various experiments have shown that CG and local confidence gain (a low-complexity version of CG) successfully generate association rules when compared to human free associations. The experiments include a large-scale “free sssociation Turing test” where human free associations were compared to associations generated by the CG and other association measures. Rules discovered by CG were found to be significantly better than those discovered by other measures. CG can be used for many purposes, such as personalization, sense disambiguation, query expansion, and improving classification performance of small item sets within large databases. Although CG was found to be useful for Internet data retrieval, results can be easily used over any type of database.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0150-4">Integrating document and data retrieval based on XML</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0150-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jan-Marco+Bremer%22">Jan-Marco Bremer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Gertz%22">Michael Gertz</a></li></ol>
          <input type="checkbox" id="75006"/>
          <label for="75006">Abstract</label>
          <div>For querying structured and semistructured data, data retrieval and document retrieval are two valuable and complementary techniques that have not yet been fully integrated. In this paper, we introduce integrated information retrieval (IIR), an XML-based retrieval approach that closes this gap. We introduce the syntax and semantics of an extension of the XQuery language called XQuery/IR. The extended language realizes IIR and thereby allows users to formulate new kinds of queries by nesting ranked document retrieval and precise data retrieval queries. Furthermore, we detail index structures and efficient query processing approaches for implementing XQuery/IR. Based on a new identification scheme for nodes in node-labeled tree structures, the extended index structures require only a fraction of the space of comparable index structures that only support data retrieval.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0149-x">Online summarization of dynamic time series data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0149-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Umit+Y.+Ogras%22">Umit Y. Ogras</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hakan+Ferhatosmanoglu%22">Hakan Ferhatosmanoglu</a></li></ol>
          <input type="checkbox" id="37721"/>
          <label for="37721">Abstract</label>
          <div>Managing large-scale time series databases has attracted significant attention in the database community recently. Related fundamental problems such as dimensionality reduction, transformation, pattern mining, and similarity search have been studied extensively. Although the time series data are dynamic by nature, as in data streams, current solutions to these fundamental problems have been mostly for the static time series databases. In this paper, we first propose a framework to online summary generation for large-scale and dynamic time series data, such as data streams. Then, we propose online transform-based summarization techniques over data streams that can be updated in constant time and space. We present both the exact and approximate versions of the proposed techniques and provide error bounds for the approximate case. One of our main contributions in this paper is the extensive performance analysis. Our experiments carefully evaluate the quality of the online summaries for point, range, and k–nn queries using real-life dynamic data sets of substantial size.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 14 (March 2005 - November 2005)</h1>
          <ol><li>
          <h2>Issue 4 (November 2005)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0179-z">Special issue: Best papers of VLDB 2004</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0179-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Donald+Kossmann%22">Donald Kossmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ren%C3%A9e+J.+Miller%22">Renée J. Miller</a></li></ol>
          <input type="checkbox" id="81135"/>
          <label for="81135">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0160-x">Adaptive website recommendations with AWESOME</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0160-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Andreas+Thor%22">Andreas Thor</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Golovin%22">Nick Golovin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Erhard+Rahm%22">Erhard Rahm</a></li></ol>
          <input type="checkbox" id="60909"/>
          <label for="60909">Abstract</label>
          <div>Recommendations are crucial for the success of large websites. While there are many ways to determine recommendations, the relative quality of these recommenders depends on many factors and is largely unknown. We present the architecture and implementation of AWESOME (Adaptive website recommendations), a data warehouse-based recommendation system. It allows the coordinated use of a large number of recommenders to automatically generate website recommendations. Recommendations are dynamically selected by efficient rule-based approaches utilizing continuously measured user feedback on presented recommendations. AWESOME supports a completely automatic generation and optimization of selection rules to minimize website administration overhead and quickly adapt to changing situations. We propose a classification of recommenders and use AWESOME to comparatively evaluate the relative quality of several recommenders for a sample website. Furthermore, we propose and evaluate several rule-based schemes for dynamically selecting the most promising recommendations. In particular, we investigate two-step selection approaches that first determine the most promising recommenders and then apply their recommendations for the current situation. We also evaluate one-step schemes that try to directly determine the most promising recommendations.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0156-6">An annotation management system for relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0156-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Deepavali+Bhagwat%22">Deepavali Bhagwat</a></li><li><a href="http://link.springer.com/search?facet-author=%22Laura+Chiticariu%22">Laura Chiticariu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wang-Chiew+Tan%22">Wang-Chiew Tan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gaurav+Vijayvargiya%22">Gaurav Vijayvargiya</a></li></ol>
          <input type="checkbox" id="80039"/>
          <label for="80039">Abstract</label>
          <div>We present an annotation management system for relational databases. In this system, every piece of data in a relation is assumed to have zero or more annotations associated with it and annotations are propagated along, from the source to the output, as data is being transformed through a query. Such an annotation management system could be used for understanding the provenance (aka lineage) of data, who has seen or edited a piece of data or the quality of data, which are useful functionalities for applications that deal with integration of scientific and biological data. We present an extension, pSQL, of a fragment of SQL that has three different types of annotation propagation schemes, each useful for different purposes. The default scheme propagates annotations according to where data is copied from. The default-all scheme propagates annotations according to where data is copied from among all equivalent formulations of a given query. The custom scheme allows a user to specify how annotations should propagate. We present a storage scheme for the annotations and describe algorithms for translating a pSQL query under each propagation scheme into one or more SQL queries that would correctly retrieve the relevant annotations according to the specified propagation scheme. For the default-all scheme, we also show how we generate finitely many queries that can simulate the annotation propagation behavior of the set of all equivalent queries, which is possibly infinite. The algorithms are implemented and the feasibility of the system is demonstrated by a set of experiments that we have conducted.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0157-5">Algebraic manipulation of scientific datasets</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0157-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bill+Howe%22">Bill Howe</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Maier%22">David Maier</a></li></ol>
          <input type="checkbox" id="65100"/>
          <label for="65100">Abstract</label>
          <div>We investigate algebraic processing strategies for large numeric datasets equipped with a (possibly irregular) grid structure. Such datasets arise, for example, in computational simulations, observation networks, medical imaging, and 2-D and 3-D rendering. Existing approaches for manipulating these datasets are incomplete: The performance of SQL queries for manipulating large numeric datasets is not competitive with specialized tools. Database extensions for processing multidimensional discrete data can only model regular, rectilinear grids. Visualization software libraries are designed to process arbitrary gridded datasets efficiently, but no algebra has been developed to simplify their use and afford optimization. Further, these libraries are data dependent – physical changes to data representation or organization break user programs. In this paper, we present an algebra of gridfields for manipulating arbitrary gridded datasets, algebraic optimization techniques, and an implementation backed by experimental results. We compare our techniques to those of Geographic Information Systems (GIS) and visualization software libraries, using real examples from an Environmental Observation and Forecasting System. We find that our approach can express optimized plans inaccessible to other techniques, resulting in improved performance with reduced programming effort.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0159-3">Model-based approximate querying in sensor networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0159-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Amol+Deshpande%22">Amol Deshpande</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carlos+Guestrin%22">Carlos Guestrin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Samuel+R.+Madden%22">Samuel R. Madden</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joseph+M.+Hellerstein%22">Joseph M. Hellerstein</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wei+Hong%22">Wei Hong</a></li></ol>
          <input type="checkbox" id="85961"/>
          <label for="85961">Abstract</label>
          <div>Declarative queries are proving to be an attractive paradigm for interacting with networks of wireless sensors. The metaphor that “the sensornet is a database” is problematic, however, because sensors do not exhaustively represent the data in the real world. In order to map the raw sensor readings onto physical reality, a model of that reality is required to complement the readings. In this article, we enrich interactive sensor querying with statistical modeling techniques. We demonstrate that such models can help provide answers that are both more meaningful, and, by introducing approximations with probabilistic confidences, significantly more efficient to compute in both time and energy. Utilizing the combination of a model and live data acquisition raises the challenging optimization problem of selecting the best sensor readings to acquire, balancing the increase in the confidence of our answer against the communication and data acquisition costs in the network. We describe an exponential time algorithm for finding the optimal solution to this optimization problem, and a polynomial-time heuristic for identifying solutions that perform well in practice. We evaluate our approach on several real-world sensor-network datasets, taking into account the real measured data and communication quality, demonstrating that our model-based approach provides a high-fidelity representation of the real phenomena and leads to significant performance gains versus traditional data acquisition techniques.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (September 2005)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0165-5">Special issue on data management, analysis, and mining for the life sciences</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0165-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Terry+Gaasterland%22">Terry Gaasterland</a></li><li><a href="http://link.springer.com/search?facet-author=%22H.+V.+Jagadish%22">H. V. Jagadish</a></li><li><a href="http://link.springer.com/search?facet-author=%22Louiqa+Raschid%22">Louiqa Raschid</a></li></ol>
          <input type="checkbox" id="46590"/>
          <label for="46590">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0154-8">Practical methods for constructing suffix trees</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0154-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yuanyuan+Tian%22">Yuanyuan Tian</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sandeep+Tata%22">Sandeep Tata</a></li><li><a href="http://link.springer.com/search?facet-author=%22Richard+A.+Hankins%22">Richard A. Hankins</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jignesh+M.+Patel%22">Jignesh M. Patel</a></li></ol>
          <input type="checkbox" id="76099"/>
          <label for="76099">Abstract</label>
          <div>Sequence datasets are ubiquitous in modern life-science applications, and querying sequences is a common and critical operation in many of these applications. The suffix tree is a versatile data structure that can be used to evaluate a wide variety of queries on sequence datasets, including evaluating exact and approximate string matches, and finding repeat patterns. However, methods for constructing suffix trees are often very time-consuming, especially for suffix trees that are large and do not fit in the available main memory. Even when the suffix tree fits in memory, it turns out that the processor cache behavior of theoretically optimal suffix tree construction methods is poor, resulting in poor performance. Currently, there are a large number of algorithms for constructing suffix trees, but the practical tradeoffs in using these algorithms for different scenarios are not well characterized. In this paper, we explore suffix tree construction algorithms over a wide spectrum of data sources and sizes. First, we show that on modern processors, a cache-efficient algorithm with O(n 2) worst-case complexity outperforms popular linear time algorithms like Ukkonen and McCreight, even for in-memory construction. For larger datasets, the disk I/O requirement quickly becomes the bottleneck in each algorithm's performance. To address this problem, we describe two approaches. First, we present a buffer management strategy for the O(n 2) algorithm. The resulting new algorithm, which we call “Top Down Disk-based” (TDD), scales to sizes much larger than have been previously described in literature. This approach far outperforms the best known disk-based construction methods. Second, we present a new disk-based suffix tree construction algorithm that is based on a sort-merge paradigm, and show that for constructing very large suffix trees with very little resources, this algorithm is more efficient than TDD.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0155-7">Sync your data: update propagation for heterogeneous protein databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0155-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kajal+T.+Claypool%22">Kajal T. Claypool</a></li><li><a href="http://link.springer.com/search?facet-author=%22Elke+A.+Rundensteiner%22">Elke A. Rundensteiner</a></li></ol>
          <input type="checkbox" id="58753"/>
          <label for="58753">Abstract</label>
          <div>The traditional model of bench (wet) chemistry in many life sciences domain is today actively complimented by computer-based discoveries utilizing the growing number of online data sources. A typical computer-based discovery scenario for many life scientists includes the creation of local caches of pertinent information from multiple online resources such as Swissprot [Nucleic Acid Res. 1(28), 45–48 (2000)], PIR [Nucleic Acids Res. 28(1), 41–44 (2000)], PDB [The Protein DataBank. Wiley, New York (2003)], to enable efficient data analysis. This local caching of data, however, exposes their research and eventual results to the problems of data staleness, that is, cached data may quickly be obsolete or incorrect, dependent on the updates that are made to the source data. This represents a significant challenge to the scientific community, forcing scientists to be continuously aware of the frequent changes made to public data sources, and more importantly aware of the potential effects on their own derived data sets during the course of their research. To address this significant challenge, in this paper we present an approach for handling update propagation between heterogeneous databases, guaranteeing data freshness for scientists irrespective of their choice of data source and its underlying data model or interface. We propose a middle-layer–based solution wherein first the change in the online data source is translated to a sequence of changes in the middle-layer; next each change in the middle-layer is propagated through an algebraic representation of the translation between the source and the target; and finally the net-change is translated to a set of changes that are then applied to the local cache. In this paper, we present our algebraic model that represents the mapping of the online resource to the local cache, as well as our adaptive propagation algorithm that can incrementally propagate both schema and data changes from the source to the cache in a data model independent manner. We present a case study based on a joint ongoing project with our collaborators in the Chemistry Department at UMass-Lowell to explicate our approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0153-9">Rule-based workflow management for bioinformatics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0153-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22John+S.+Conery%22">John S. Conery</a></li><li><a href="http://link.springer.com/search?facet-author=%22Julian+M.+Catchen%22">Julian M. Catchen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Lynch%22">Michael Lynch</a></li></ol>
          <input type="checkbox" id="17245"/>
          <label for="17245">Abstract</label>
          <div>We describe a data-centric software architecture for bioinformatics workflows and a rule-based workflow enactment system that uses declarative specifications of data dependences between steps to automatically order the execution of those steps. A data-centric view allows researchers to develop abstract descriptions of workflow products and provides mechanisms for describing workflow steps as objects. The rule-based approach supports an iterative design methodology for creating new workflows, where steps can be developed in small, incremental updates, and the object orientation allows workflow steps developed for one project to be reused in other projects.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-005-0158-4">Composing, optimizing, and executing plans for bioinformatics web services</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-005-0158-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Snehal+Thakkar%22">Snehal Thakkar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jos%C3%A9+Luis+Ambite%22">José Luis Ambite</a></li><li><a href="http://link.springer.com/search?facet-author=%22Craig+A.+Knoblock%22">Craig A. Knoblock</a></li></ol>
          <input type="checkbox" id="41565"/>
          <label for="41565">Abstract</label>
          <div>The emergence of a large number of bioinformatics datasets on the Internet has resulted in the need for flexible and efficient approaches to integrate information from multiple bioinformatics data sources and services. In this paper, we present our approach to automatically generate composition plans for web services, optimize the composition plans, and execute these plans efficiently. While data integration techniques have been applied to the bioinformatics domain, the focus has been on answering specific user queries. In contrast, we focus on automatically generating parameterized integration plans that can be hosted as web services that respond to a range of inputs. In addition, we present two novel techniques that improve the execution time of the generated plans by reducing the number of requests to the existing data sources and by executing the generated plan more efficiently. The first optimization technique, called tuple-level filtering, analyzes the source/service descriptions in order to automatically insert filtering conditions in the composition plans that result in fewer requests to the component web services. To ensure that the filtering conditions can be evaluated, this technique may include sensing operations in the integration plan. The savings due to filtering significantly exceed the cost of the sensing operations. The second optimization technique consists in mapping the integration plans into programs that can be executed by a dataflow-style, streaming execution engine. We use real-world bioinformatics web services to show experimentally that (1) our automatic composition techniques can efficiently generate parameterized plans that integrate data from large numbers of existing services and (2) our optimization techniques can significantly reduce the response time of the generated integration plans.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 2005)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0090-4">Selectivity estimators for multidimensional range queries over real attributes</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0090-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dimitrios+Gunopulos%22">Dimitrios Gunopulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22George+Kollios%22">George Kollios</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vassilis+J.+Tsotras%22">Vassilis J. Tsotras</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carlotta+Domeniconi%22">Carlotta Domeniconi</a></li></ol>
          <input type="checkbox" id="90493"/>
          <label for="90493">Abstract</label>
          <div>Estimating the selectivity of multidimensional range queries over real valued attributes has significant applications in data exploration and database query optimization. In this paper, we consider the following problem: given a table of d attributes whose domain is the real numbers and a query that specifies a range in each dimension, find a good approximation of the number of records in the table that satisfy the query. The simplest approach to tackle this problem is to assume that the attributes are independent. More accurate estimators try to capture the joint data distribution of the attributes. In databases, such estimators include the construction of multidimensional histograms, random sampling, or the wavelet transform. In statistics, kernel estimation techniques are being used. Many traditional approaches assume that attribute values come from discrete, finite domains, where different values have high frequencies. However, for many novel applications (as in temporal, spatial, and multimedia databases) attribute values come from the infinite domain of real numbers. Consequently, each value appears very infrequently, a characteristic that affects the behavior and effectiveness of the estimator. Moreover, real-life data exhibit attribute correlations that also affect the estimator. We present a new histogram technique that is designed to approximate the density of multidimensional datasets with real attributes. Our technique defines buckets of variable size and allows the buckets to overlap. The size of the cells is based on the local density of the data. The use of overlapping buckets allows a more compact approximation of the data distribution. We also show how to generalize kernel density estimators and how to apply them to the multidimensional query approximation problem. Finally, we compare the accuracy of the proposed techniques with existing techniques using real and synthetic datasets. The experimental results show that the proposed techniques behave more accurately in high dimensionalities than previous approaches.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0122-8">Views as first-class citizens in object-oriented databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0122-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Reda+Alhajj%22">Reda Alhajj</a></li><li><a href="http://link.springer.com/search?facet-author=%22Faruk+Polat%22">Faruk Polat</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cem+Y%C3%ADlmaz%22">Cem Yílmaz</a></li></ol>
          <input type="checkbox" id="71959"/>
          <label for="71959">Abstract</label>
          <div>Extensibility and dynamic schema evolution are among the attractive features that lead to the wide acceptance of the object-oriented paradigm. Not knowing all class hierarchy details should not prevent a user from introducing new classes when necessary. Naive or professional users may define new classes either by using class definition constructs or as views. However, improper placement of such classes leads to a flat hierarchy with many things duplicated. To overcome this problem, we automated the process in order to help the user find the most appropriate position with respect to her class in the hierarchy regardless of her knowledge of the hierarchy. The system must be responsible for the proper placement of new classes because only the system has complete knowledge of the details of the class hierarchy, especially in a dynamic environment where changes are very frequent. In other published work, we proved that to define a view it is enough to have the set of objects that qualify to be in a view in addition to having message expressions (possible paths) that lead to desired values within those objects. Here, we go further to map a view that is intended to be persistent into a class. Then we investigate the proper position of that class in the hierarchy. To achieve this, we consider current characteristics of a new class in order to derive its relationship with other existing classes in the hierarchy. Another advantage of the presented model is that views that generate new objects are still updatable simply because we based the creation of new objects on existing identities. In other words, an object participates inside view objects by its identity regardless of which particular values from that object are of interest to the view. Values are reachable via message expressions, not violating encapsulation. This way, actual values are present in only one place and can be updated.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0142-4">Optimizing spatial Min/Max aggregations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0142-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Donghui+Zhang%22">Donghui Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vassilis+J.+Tsotras%22">Vassilis J. Tsotras</a></li></ol>
          <input type="checkbox" id="32383"/>
          <label for="32383">Abstract</label>
          <div>Aggregate computation over a collection of spatial objects appears in many real-life applications. Aggregates are computed on values (weights) associated with spatial objects, for example, the temperature or rainfall over the area covered by the object. In this paper we concentrate on MIN/MAX aggregations: “given a query rectangle, find the minimum/maximum weight among all objects intersecting the query rectangle.” Traditionally such queries have been performed as range searches. Assuming that objects are indexed by a spatial access method (SAM), the MIN/MAX is computed while retrieving those objects intersecting the query interval. This requires effort proportional to the number of objects satisfying the query, which may be large. A better approach is to maintain aggregate information among the index nodes of the spatial access method; then various index paths can be eliminated during the range search. Yet another approach is to build a specialized index that maintains the aggregate incrementally. We propose four novel optimizations for improving the performance of MIN/MAX queries when an index structure (traditional or specialized) is present. Moreover, we introduce the MR-tree, an R-tree-like dynamic specialized index that incorporates all four optimizations. Our experiments show that the MR-tree offers drastic performance improvement over previous solutions. As a byproduct of this work we present an optimized version of the MSB-tree, an index that has been proposed for the MIN/MAX computation over 1D interval objects.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0127-3">Collaborative joins in a pervasive computing environment</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0127-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Filip+Perich%22">Filip Perich</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anupam+Joshi%22">Anupam Joshi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yelena+Yesha%22">Yelena Yesha</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tim+Finin%22">Tim Finin</a></li></ol>
          <input type="checkbox" id="57058"/>
          <label for="57058">Abstract</label>
          <div>We present a collaborative query processing protocol based on the principles of Contract Nets. The protocol is designed for pervasive computing environments where, in addition to operating on limited computing and battery resources, mobile devices cannot always rely on being able to access the wired infrastructure. Devices, therefore, need to collaborate with each other in order to obtain data otherwise inaccessible due to the nature of the environment. Furthermore, by intelligently using answers cached by peers, devices can reduce their computation cost. We show the effectiveness of our approach by evaluating performance of devices querying for data while moving in a citylike environment.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0123-7">Querying XML streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0123-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vanja+Josifovski%22">Vanja Josifovski</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marcus+Fontoura%22">Marcus Fontoura</a></li><li><a href="http://link.springer.com/search?facet-author=%22Attila+Barta%22">Attila Barta</a></li></ol>
          <input type="checkbox" id="23838"/>
          <label for="23838">Abstract</label>
          <div>Efficient querying of XML streams will be one of the fundamental features of next-generation information systems. In this paper we propose the TurboXPath path processor, which accepts a language equivalent to a subset of the for-let-where constructs of XQuery over a single document. TurboXPath can be extended to provide full XQuery support or used to augment federated database engines for efficient handling of queries over XML data streams produced by external sources. Internally, TurboXPath uses a tree-shaped path expression with multiple outputs to drive the execution. The result of a query execution is a sequence of tuples of XML fragments matching the output nodes. Based on a streamed execution model, TurboXPath scales up to large documents and has limited memory consumption for increased concurrency. Experimental evaluation of a prototype demonstrates performance gains compared to other state-of-the-art path processors.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0125-5">An effective and efficient algorithm for high-dimensional outlier detection</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0125-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Charu+C.+Aggarwal%22">Charu C. Aggarwal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li></ol>
          <input type="checkbox" id="9212"/>
          <label for="9212">Abstract</label>
          <div>The outlier detection problem has important applications in the field of fraud detection, network robustness analysis, and intrusion detection. Most such applications are most important for high-dimensional domains in which the data can contain hundreds of dimensions. Many recent algorithms have been proposed for outlier detection that use several concepts of proximity in order to find the outliers based on their relationship to the other points in the data. However, in high-dimensional space, the data are sparse and concepts using the notion of proximity fail to retain their effectiveness. In fact, the sparsity of high-dimensional data can be understood in a different way so as to imply that every point is an equally good outlier from the perspective of distance-based definitions. Consequently, for high-dimensional data, the notion of finding meaningful outliers becomes substantially more complex and nonobvious. In this paper, we discuss new techniques for outlier detection that find the outliers by studying the behavior of projections from the data set.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0124-6">Hash-based labeling techniques for storage scaling</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0124-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Shu-Yuen+D.+Yao%22">Shu-Yuen D. Yao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cyrus+Shahabi%22">Cyrus Shahabi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Per-%C3%85ke+Larson%22">Per-Åke Larson</a></li></ol>
          <input type="checkbox" id="48518"/>
          <label for="48518">Abstract</label>
          <div>Scalable storage architectures allow for the addition or removal of storage devices to increase storage capacity and bandwidth or retire older devices. Assuming random placement of data objects across multiple storage devices of a storage pool, our optimization objective is to redistribute a minimum number of objects after scaling the pool. In addition, a uniform distribution, and hence a balanced load, should be ensured after redistribution. Moreover, the redistributed objects should be retrieved efficiently during the normal mode of operation: in one I/O access and with low complexity computation. To achieve this, we propose an algorithm called random disk labeling (RDL), based on double hashing, where storage can be added or removed without any increase in complexity. We compare RDL with other proposed techniques and demonstrate its effectiveness through experimentation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0139-z">Indexing mobile objects using dual transformations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0139-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22George+Kollios%22">George Kollios</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Papadopoulos%22">Dimitris Papadopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitrios+Gunopulos%22">Dimitrios Gunopulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vassilis+J.+Tsotras%22">Vassilis J. Tsotras</a></li></ol>
          <input type="checkbox" id="43603"/>
          <label for="43603">Abstract</label>
          <div>With the recent advances in wireless networks, embedded systems, and GPS technology, databases that manage the location of moving objects have received increased interest. In this paper, we present indexing techniques for moving object databases. In particular, we propose methods to index moving objects in order to efficiently answer range queries about their current and future positions. This problem appears in real-life applications such as predicting future congestion areas in a highway system or allocating more bandwidth for areas where a high concentration of mobile phones is imminent. We address the problem in external memory and present dynamic solutions, both for the one-dimensional and the two-dimensional cases. Our approach transforms the problem into a dual space that is easier to index. Important in this dynamic environment is not only query performance but also the update processing, given the large number of moving objects that issue updates. We compare the dual-transformation approach with the TPR-tree, an efficient method for indexing moving objects that is based on time-parameterized index nodes. An experimental evaluation shows that the dual-transformation approach provides comparable query performance but has much faster update processing. Moreover, the dual method does not require establishing a predefined query horizon.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0140-6">Concurrency control and recovery for balanced B-link trees</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0140-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ibrahim+Jaluta%22">Ibrahim Jaluta</a></li><li><a href="http://link.springer.com/search?facet-author=%22Seppo+Sippu%22">Seppo Sippu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eljas+Soisalon-Soininen%22">Eljas Soisalon-Soininen</a></li></ol>
          <input type="checkbox" id="90459"/>
          <label for="90459">Abstract</label>
          <div>In this paper we present new concurrent and recoverable B-link-tree algorithms. Unlike previous algorithms, ours maintain the balance of the B-link tree at all times, so that a logarithmic time bound for a search or an update operation is guaranteed under arbitrary sequences of record insertions and deletions. A database transaction can contain any number of operations of the form “fetch the first (or next) matching record”, “insert a record”, or “delete a record”, where database records are identified by their primary keys. Repeatable-read-level isolation for transactions is guaranteed by key-range locking. The algorithms apply the write-ahead logging (WAL) protocol and the steal and no-force buffering policies for index and data pages. Record inserts and deletes on leaf pages of a B-link tree are logged using physiological redo-undo log records. Each structure modification such as a page split or merge is made an atomic action by keeping the pages involved in the modification latched for the (short) duration of the modification and the logging of that modification; at most two B-link-tree pages are kept X-latched at a time. Each structure modification brings the B-link tree into a structurally consistent and balanced state whenever the tree was structurally consistent and balanced initially. Each structure modification is logged using a single physiological redo-only log record. Thus, a structure modification will never be undone even if the transaction that gave rise to it eventually aborts. In restart recovery, the redo pass of our ARIES-based recovery protocol will always produce a structurally consistent and balanced B-link tree, on which the database updates by backward-rolling transactions can always be undone logically, when a physical (page-oriented) undo is no longer possible.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (March 2005)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0143-3">Editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0143-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li></ol>
          <input type="checkbox" id="59063"/>
          <label for="59063">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0111-3">Join operations in temporal databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0111-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dengfeng+Gao%22">Dengfeng Gao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Richard+T.+Snodgrass%22">Richard T. Snodgrass</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+D.+Soo%22">Michael D. Soo</a></li></ol>
          <input type="checkbox" id="10475"/>
          <label for="10475">Abstract</label>
          <div>Joins are arguably the most important relational operators. Poor implementations are tantamount to computing the Cartesian product of the input relations. In a temporal database, the problem is more acute for two reasons. First, conventional techniques are designed for the evaluation of joins with equality predicates rather than the inequality predicates prevalent in valid-time queries. Second, the presence of temporally varying data dramatically increases the size of a database. These factors indicate that specialized techniques are needed to efficiently evaluate temporal joins. We address this need for efficient join evaluation in temporal databases. Our purpose is twofold. We first survey all previously proposed temporal join operators. While many temporal join operators have been defined in previous work, this work has been done largely in isolation from competing proposals, with little, if any, comparison of the various operators. We then address evaluation algorithms, comparing the applicability of various algorithms to the temporal join operators and describing a performance study involving algorithms for one important operator, the temporal equijoin. Our focus, with respect to implementation, is on non-index-based join algorithms. Such algorithms do not rely on auxiliary access paths but may exploit sort orderings to achieve efficiency.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0113-1">Storing and querying XML data using denormalized relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0113-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Andrey+Balmin%22">Andrey Balmin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Papakonstantinou%22">Yannis Papakonstantinou</a></li></ol>
          <input type="checkbox" id="65471"/>
          <label for="65471">Abstract</label>
          <div>XML database systems emerge as a result of the acceptance of the XML data model. Recent works have followed the promising approach of building XML database management systems on underlying RDBMS’s. Achieving query processing performance reduces to two questions: (i) How should the XML data be decomposed into data that are stored in the RDBMS? (ii) How should the XML query be translated into an efficient plan that sends one or more SQL queries to the underlying RDBMS and combines the data into the XML result? We provide a formal framework for XML Schema-driven decompositions, which encompasses the decompositions proposed in prior work and extends them with decompositions that employ denormalized tables and binary-coded XML fragments. We provide corresponding query processing algorithms that translate the XML query conditions into conditions on the relational tables and assemble the decomposed data into the XML query result. Our key performance focus is the response time for delivering the first results of a query. The most effective of the described decompositions have been implemented in XCacheDB, an XML DBMS built on top of a commercial RDBMS, which serves as our experimental basis. We present experiments and analysis that point to a class of decompositions, called inlined decompositions, that improve query performance for full results and first results, without significant increase in the size of the database.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0115-z">A framework for modeling and evaluating automatic semantic reconciliation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0115-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Avigdor+Gal%22">Avigdor Gal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ateret+Anaby-Tavor%22">Ateret Anaby-Tavor</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alberto+Trombetta%22">Alberto Trombetta</a></li><li><a href="http://link.springer.com/search?facet-author=%22Danilo+Montesi%22">Danilo Montesi</a></li></ol>
          <input type="checkbox" id="54888"/>
          <label for="54888">Abstract</label>
          <div>The introduction of the Semantic Web vision and the shift toward machine understandable Web resources has unearthed the importance of automatic semantic reconciliation. Consequently, new tools for automating the process were proposed. In this work we present a formal model of semantic reconciliation and analyze in a systematic manner the properties of the process outcome, primarily the inherent uncertainty of the matching process and how it reflects on the resulting mappings. An important feature of this research is the identification and analysis of factors that impact the effectiveness of algorithms for automatic semantic reconciliation, leading, it is hoped, to the design of better algorithms by reducing the uncertainty of existing algorithms. Against this background we empirically study the aptitude of two algorithms to correctly match concepts. This research is both timely and practical in light of recent attempts to develop and utilize methods for automatic semantic reconciliation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0116-y">Schema mediation for large-scale semantic data sharing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0116-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alon+Y.+Halevy%22">Alon Y. Halevy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zachary+G.+Ives%22">Zachary G. Ives</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Suciu%22">Dan Suciu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Igor+Tatarinov%22">Igor Tatarinov</a></li></ol>
          <input type="checkbox" id="32427"/>
          <label for="32427">Abstract</label>
          <div>Intuitively, data management and data integration tools should be well suited for exchanging information in a semantically meaningful way. Unfortunately, they suffer from two significant problems: they typically require a common and comprehensive schema design before they can be used to store or share information, and they are difficult to extend because schema evolution is heavyweight and may break backward compatibility. As a result, many large-scale data sharing tasks are more easily facilitated by non-database-oriented tools that have little support for semantics. The goal of the peer data management system (PDMS) is to address this need: we propose the use of a decentralized, easily extensible data management architecture in which any user can contribute new data, schema information, or even mappings between other peers’ schemas. PDMSs represent a natural step beyond data integration systems, replacing their single logical schema with an interlinked collection of semantic mappings between peers’ individual schemas. This paper considers the problem of schema mediation in a PDMS. Our first contribution is a flexible language for mediating between peer schemas that extends known data integration formalisms to our more complex architecture. We precisely characterize the complexity of query answering for our language. Next, we describe a reformulation algorithm for our language that generalizes both global-as-view and local-as-view query answering algorithms. Then we describe several methods for optimizing the reformulation algorithm and an initial set of experiments studying its performance. Finally, we define and consider several global problems in managing semantic mappings in a PDMS.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0117-x">On automating Web services discovery</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0117-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Boualem+Benatallah%22">Boualem Benatallah</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohand-Said+Hacid%22">Mohand-Said Hacid</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alain+Leger%22">Alain Leger</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christophe+Rey%22">Christophe Rey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Farouk+Toumani%22">Farouk Toumani</a></li></ol>
          <input type="checkbox" id="68395"/>
          <label for="68395">Abstract</label>
          <div>One of the challenging problems that Web service technology faces is the ability to effectively discover services based on their capabilities. We present an approach to tackling this problem in the context of description logics (DLs). We formalize service discovery as a new instance of the problem of rewriting concepts using terminologies. We call this new instance the best covering problem. We provide a formalization of the best covering problem in the framework of DL-based ontologies and propose a hypergraph-based algorithm to effectively compute best covers of a given request. We propose a novel matchmaking algorithm that takes as input a service request (or query) Q and an ontology $\mathcal{T}$ of services and finds a set of services called a “best cover” of Q whose descriptions contain as much common information with Q as possible and as little extra information with respect to Q as possible. We have implemented the proposed discovery technique and used the developed prototype in the context of the Multilingual Knowledge Based European Electronic Marketplace (MKBEEM) project.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0118-9">Concept-based querying in mediator systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0118-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kai-Uwe+Sattler%22">Kai-Uwe Sattler</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ingolf+Geist%22">Ingolf Geist</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eike+Schallehn%22">Eike Schallehn</a></li></ol>
          <input type="checkbox" id="74996"/>
          <label for="74996">Abstract</label>
          <div>One approach to overcoming heterogeneity as a part of data integration in mediator systems is the use of metadata in the form of a vocabulary or ontology to represent domain knowledge explicitly. This requires including this meta level during query formulation and processing. In this paper, we address this problem in the context of a mediator that uses a concept-based integration model and an extension of the XQuery language called CQuery. This mediator has been developed as part of a project for integrating data about cultural assets. We describe the language extensions and their semantics as well as the rewriting and evaluation steps. Furthermore, we discuss aspects of caching and keyword-based search in support of an efficient query formulation and processing.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0119-8">Mediators over taxonomy-based information sources</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0119-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Tzitzikas%22">Yannis Tzitzikas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nicolas+Spyratos%22">Nicolas Spyratos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Panos+Constantopoulos%22">Panos Constantopoulos</a></li></ol>
          <input type="checkbox" id="54442"/>
          <label for="54442">Abstract</label>
          <div>We propose a mediator model for providing integrated and unified access to multiple taxonomy-based sources. Each source comprises a taxonomy and a database that indexes objects under the terms of the taxonomy. A mediator comprises a taxonomy and a set of relations between the mediator’s and the sources’ terms, called articulations. By combining different modes of query evaluation at the sources and the mediator and different types of query translation, a flexible, efficient scheme of mediator operation is obtained that can accommodate various application needs and levels of answer quality. We adopt a simple conceptual modeling approach (taxonomies and intertaxonomy mappings) and we illustrate its advantages in terms of ease of use, uniformity, scalability, and efficiency. These characteristics make this proposal appropriate for a large-scale network of sources and mediators.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 13 (January 2004 - December 2004)</h1>
          <ol><li>
          <h2>Issue 4 (December 2004)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0141-5">Guest Editorial to the special issue on data stream processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0141-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Johannes+Gehrke%22">Johannes Gehrke</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joseph+M.+Hellerstein%22">Joseph M. Hellerstein</a></li></ol>
          <input type="checkbox" id="36553"/>
          <label for="36553">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0134-4">Finding hot query patterns over an XQuery stream</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0134-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Liang+Huai+Yang%22">Liang Huai Yang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mong+Li+Lee%22">Mong Li Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wynne+Hsu%22">Wynne Hsu</a></li></ol>
          <input type="checkbox" id="3463"/>
          <label for="3463">Abstract</label>
          <div>Caching query results is one efficient approach to improving the performance of XML management systems. This entails the discovery of frequent XML queries issued by users. In this paper, we model user queries as a stream of XML query pattern trees and mine the frequent query patterns over the query stream. To facilitate the one-pass mining process, we devise a novel data structure called DTS to summarize the pattern trees seen so far. By grouping the incoming pattern trees into batches, we can dynamically mark the active portion of the current batch in DTS and limit the enumeration of candidate trees to only the currently active pattern trees. We also design another summary data structure called ECTree that provides for the incremental computation of the frequent tree patterns over the query stream. Based on the above two constructs, we present two mining algorithms called XQSMinerI and XQSMinerII. XQSMinerI is fast, but it tends to overestimate, while XQSMinerII adopts a filter-and-refine approach to minimize the amount of overestimation. Experimental results show that the proposed methods are both efficient and scalable and require only small memory footprints.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0132-6">Operator scheduling in data stream systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0132-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Brian+Babcock%22">Brian Babcock</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shivnath+Babu%22">Shivnath Babu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mayur+Datar%22">Mayur Datar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rajeev+Motwani%22">Rajeev Motwani</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dilys+Thomas%22">Dilys Thomas</a></li></ol>
          <input type="checkbox" id="56126"/>
          <label for="56126">Abstract</label>
          <div>In many applications involving continuous data streams, data arrival is bursty and data rate fluctuates over time. Systems that seek to give rapid or real-time query responses in such an environment must be prepared to deal gracefully with bursts in data arrival without compromising system performance. We discuss one strategy for processing bursty streams - adaptive, load-aware scheduling of query operators to minimize resource consumption during times of peak load. We show that the choice of an operator scheduling strategy can have significant impact on the runtime system memory usage as well as output latency. Our aim is to design a scheduling strategy that minimizes the maximum runtime system memory while maintaining the output latency within prespecified bounds. We first present Chain scheduling, an operator scheduling strategy for data stream systems that is near-optimal in minimizing runtime memory usage for any collection of single-stream queries involving selections, projections, and foreign-key joins with stored relations. Chain scheduling also performs well for queries with sliding-window joins over multiple streams and multiple queries of the above types. However, during bursts in input streams, when there is a buildup of unprocessed tuples, Chain scheduling may lead to high output latency. We study the online problem of minimizing maximum runtime memory, subject to a constraint on maximum latency. We present preliminary observations, negative results, and heuristics for this problem. A thorough experimental evaluation is provided where we demonstrate the potential benefits of Chain scheduling and its different variants, compare it with competing scheduling strategies, and validate our analytical conclusions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0135-3">Tracking set-expression cardinalities over continuous update streams</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0135-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sumit+Ganguly%22">Sumit Ganguly</a></li><li><a href="http://link.springer.com/search?facet-author=%22Minos+Garofalakis%22">Minos Garofalakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rajeev+Rastogi%22">Rajeev Rastogi</a></li></ol>
          <input type="checkbox" id="50762"/>
          <label for="50762">Abstract</label>
          <div>There is growing interest in algorithms for processing and querying continuous data streams (i.e., data seen only once in a fixed order) with limited memory resources. In its most general form, a data stream is actually an update stream, i.e., comprising data-item deletions as well as insertions. Such massive update streams arise naturally in several application domains (e.g., monitoring of large IP network installations or processing of retail-chain transactions). Estimating the cardinality of set expressions defined over several (possibly distributed) update streams is perhaps one of the most fundamental query classes of interest; as an example, such a query may ask “what is the number of distinct IP source addresses seen in passing packets from both router R 1 and R 2 but not router R 3?”. Earlier work only addressed very restricted forms of this problem, focusing solely on the special case of insert-only streams and specific operators (e.g., union). In this paper, we propose the first space-efficient algorithmic solution for estimating the cardinality of full-fledged set expressions over general update streams. Our estimation algorithms are probabilistic in nature and rely on a novel, hash-based synopsis data structure, termed ”2-level hash sketch”. We demonstrate how our 2-level hash sketch synopses can be used to provide low-error, high-confidence estimates for the cardinality of set expressions (including operators such as set union, intersection, and difference) over continuous update streams, using only space that is significantly sublinear in the sizes of the streaming input (multi-)sets. Furthermore, our estimators never require rescanning or resampling of past stream items, regardless of the number of deletions in the stream. We also present lower bounds for the problem, demonstrating that the space usage of our estimation algorithms is within small factors of the optimal. Finally, we propose an optimized, time-efficient stream synopsis (based on 2-level hash sketches) that provides similar, strong accuracy-space guarantees while requiring only guaranteed logarithmic maintenance time per update, thus making our methods applicable for truly rapid-rate data streams. Our results from an empirical study of our synopsis and estimation techniques verify the effectiveness of our approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0133-5">Retrospective on Aurora</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0133-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hari+Balakrishnan%22">Hari Balakrishnan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Magdalena+Balazinska%22">Magdalena Balazinska</a></li><li><a href="http://link.springer.com/search?facet-author=%22Don+Carney%22">Don Carney</a></li><li><a href="http://link.springer.com/search?facet-author=%22U%C4%9Fur+%C3%87etintemel%22">Uğur Çetintemel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mitch+Cherniack%22">Mitch Cherniack</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+Convey%22">Christian Convey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eddie+Galvez%22">Eddie Galvez</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jon+Salz%22">Jon Salz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Stonebraker%22">Michael Stonebraker</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nesime+Tatbul%22">Nesime Tatbul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Richard+Tibbetts%22">Richard Tibbetts</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stan+Zdonik%22">Stan Zdonik</a></li></ol>
          <input type="checkbox" id="21781"/>
          <label for="21781">Abstract</label>
          <div>This experience paper summarizes the key lessons we learned throughout the design and implementation of the Aurora stream-processing engine. For the past 2 years, we have built five stream-based applications using Aurora. We first describe in detail these applications and their implementation in Aurora. We then reflect on the design of Aurora based on this experience. Finally, we discuss our initial ideas on a follow-on project, called Borealis, whose goal is to eliminate the limitations of Aurora as well as to address new key challenges and applications in the stream-processing domain.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0138-0">Balancing energy efficiency and quality of aggregate data in sensor networks</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0138-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+A.+Sharaf%22">Mohamed A. Sharaf</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jonathan+Beaver%22">Jonathan Beaver</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alexandros+Labrinidis%22">Alexandros Labrinidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Panos+K.+Chrysanthis%22">Panos K. Chrysanthis</a></li></ol>
          <input type="checkbox" id="68427"/>
          <label for="68427">Abstract</label>
          <div>In-network aggregation has been proposed as one method for reducing energy consumption in sensor networks. In this paper, we explore two ideas related to further reducing energy consumption in the context of in-network aggregation. The first is by influencing the construction of the routing trees for sensor networks with the goal of reducing the size of transmitted data. To this end, we propose a group-aware network configuration method that “clusters” along the same path sensor nodes that belong to the same group. The second idea involves imposing a hierarchy of output filters on the sensor network with the goal of both reducing the size of transmitted data and minimizing the number of transmitted messages. More specifically, we propose a framework to use temporal coherency tolerances in conjunction with in-network aggregation to save energy at the sensor nodes while maintaining specified quality of data. These tolerances are based on user preferences or can be dictated by the network in cases where the network cannot support the current tolerance level. Our framework, called TiNA, works on top of existing in-network aggregation schemes. We evaluate experimentally our proposed schemes in the context of existing in-network aggregation schemes. We present experimental results measuring energy consumption, response time, and quality of data for Group-By queries. Overall, our schemes provide significant energy savings with respect to communication and a negligible drop in quality of data.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (September 2004)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0129-1">Best papers of VLDB 2003</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0129-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Johann-Christoph+Freytag%22">Johann-Christoph Freytag</a></li><li><a href="http://link.springer.com/search?facet-author=%22Serge+Abiteboul%22">Serge Abiteboul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mike+Carey%22">Mike Carey</a></li></ol>
          <input type="checkbox" id="56893"/>
          <label for="56893">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0128-2">Supporting top-k join queries in relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0128-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ihab+F.+Ilyas%22">Ihab F. Ilyas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Walid+G.+Aref%22">Walid G. Aref</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ahmed+K.+Elmagarmid%22">Ahmed K. Elmagarmid</a></li></ol>
          <input type="checkbox" id="20294"/>
          <label for="20294">Abstract</label>
          <div>Ranking queries, also known as top-k queries, produce results that are ordered on some computed score. Typically, these queries involve joins, where users are usually interested only in the top-k join results. Top-k queries are dominant in many emerging applications, e.g., multimedia retrieval by content, Web databases, data mining, middlewares, and most information retrieval applications. Current relational query processors do not handle ranking queries efficiently, especially when joins are involved. In this paper, we address supporting top-k join queries in relational query processors. We introduce a new rank-join algorithm that makes use of the individual orders of its inputs to produce join results ordered on a user-specified scoring function. The idea is to rank the join results progressively during the join operation. We introduce two physical query operators based on variants of ripple join that implement the rank-join algorithm. The operators are nonblocking and can be integrated into pipelined execution plans. We also propose an efficient heuristic designed to optimize a top-k join query by choosing the best join order. We address several practical issues and optimization heuristics to integrate the new join operators in practical query processors. We implement the new operators inside a prototype database engine based on PREDATOR. The experimental evaluation of our approach compares recent algorithms for joining ranked inputs and shows superior performance.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0130-8">Adaptive, unsupervised stream mining</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0130-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Spiros+Papadimitriou%22">Spiros Papadimitriou</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anthony+Brockwell%22">Anthony Brockwell</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christos+Faloutsos%22">Christos Faloutsos</a></li></ol>
          <input type="checkbox" id="34802"/>
          <label for="34802">Abstract</label>
          <div>Sensor devices and embedded processors are becoming widespread, especially in measurement/monitoring applications. Their limited resources (CPU, memory and/or communication bandwidth, and power) pose some interesting challenges. We need concise, expressive models to represent the important features of the data and that lend themselves to efficient estimation. In particular, under these severe constraints, we want models and estimation methods that (a) require little memory and a single pass over the data, (b) can adapt and handle arbitrary periodic components, and (c) can deal with various types of noise. We propose \ensuremath{\mathrm{AWSOM}} (Arbitrary Window Stream mOdeling Method), which allows sensors in remote or hostile environments to efficiently and effectively discover interesting patterns and trends. This can be done automatically, i.e., with no prior inspection of the data or any user intervention and expert tuning before or during data gathering. Our algorithms require limited resources and can thus be incorporated into sensors - possibly alongside a distributed query processing engine [10,6,27]. Updates are performed in constant time with respect to stream size using logarithmic space. Existing forecasting methods (SARIMA, GARCH, etc.) and “traditional” Fourier and wavelet analysis fall short on one or more of these requirements. To the best of our knowledge, \ensuremath{\mathrm{AWSOM}} is the first framework that combines all of the above characteristics. Experiments on real and synthetic datasets demonstrate that \ensuremath{\mathrm{AWSOM}} discovers meaningful patterns over long time periods. Thus, the patterns can also be used to make long-range forecasts, which are notoriously difficult to perform. In fact, \ensuremath{\mathrm{AWSOM}} outperforms manually set up autoregressive models, both in terms of long-term pattern detection and modeling and by at least 10 x in resource consumption.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0131-7">Exploring the tradeoff between performance and data freshness in database-driven Web servers</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0131-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alexandros+Labrinidis%22">Alexandros Labrinidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Roussopoulos%22">Nick Roussopoulos</a></li></ol>
          <input type="checkbox" id="46155"/>
          <label for="46155">Abstract</label>
          <div>Personalization, advertising, and the sheer volume of online data generate a staggering amount of dynamic Web content. In addition to Web caching, view materialization has been shown to accelerate the generation of dynamic Web content. View materialization is an attractive solution as it decouples the serving of access requests from the handling of updates. In the context of the Web, selecting which views to materialize must be decided online and needs to consider both performance and data freshness, which we refer to as the online view selection problem. In this paper, we define data freshness metrics, provide an adaptive algorithm for the online view selection problem that is based on user-specified data freshness requirements, and present experimental results. Furthermore, we examine alternative metrics for data freshness and extend our proposed algorithm to handle multiple users and alternative definitions of data freshness.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0126-4">Automatic integration of Web search interfaces with WISE-Integrator</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0126-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hai+He%22">Hai He</a></li><li><a href="http://link.springer.com/search?facet-author=%22Weiyi+Meng%22">Weiyi Meng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Clement+Yu%22">Clement Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zonghuan+Wu%22">Zonghuan Wu</a></li></ol>
          <input type="checkbox" id="385"/>
          <label for="385">Abstract</label>
          <div>An increasing number of databases are becoming Web accessible through form-based search interfaces, and many of these sources are database-driven e-commerce sites. It is a daunting task for users to access numerous Web sites individually to get the desired information. Hence, providing a unified access to multiple e-commerce search engines selling similar products is of great importance in allowing users to search and compare products from multiple sites with ease. One key task for providing such a capability is to integrate the Web search interfaces of these e-commerce search engines so that user queries can be submitted against the integrated interface. Currently, integrating such search interfaces is carried out either manually or semiautomatically, which is inefficient and difficult to maintain. In this paper, we present WISE-Integrator - a tool that performs automatic integration of Web Interfaces of Search Engines. WISE-Integrator explores a rich set of special metainformation that exists in Web search interfaces and uses the information to identify matching attributes from different search interfaces for integration. It also resolves domain differences of matching attributes. In this paper, we also discuss how to automatically extract information from search interfaces that is needed by WISE-Integrator to perform automatic interface integration. Our experimental results, based on 143 real-world search interfaces in four different domains, indicate that WISE-Integrator can achieve high attribute matching accuracy and can produce high-quality integrated search interfaces without human interactions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0136-2">Preserving mapping consistency under schema changes</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0136-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Velegrakis%22">Yannis Velegrakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ren%C3%A9e+J.+Miller%22">Renée J. Miller</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lucian+Popa%22">Lucian Popa</a></li></ol>
          <input type="checkbox" id="6049"/>
          <label for="6049">Abstract</label>
          <div>In dynamic environments like the Web, data sources may change not only their data but also their schemas, their semantics, and their query capabilities. When a mapping is left inconsistent by a schema change, it has to be detected and updated. We present a novel framework and a tool (ToMAS) for automatically adapting (rewriting) mappings as schemas evolve. Our approach considers not only local changes to a schema but also changes that may affect and transform many components of a schema. Our algorithm detects mappings affected by structural or constraint changes and generates all the rewritings that are consistent with the semantics of the changed schemas. Our approach explicitly models mapping choices made by a user and maintains these choices, whenever possible, as the schemas and mappings evolve. When there is more than one candidate rewriting, the algorithm may rank them based on how close they are to the semantics of the existing mappings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0137-1">The BEA streaming XQuery processor</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0137-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniela+Florescu%22">Daniela Florescu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chris+Hillery%22">Chris Hillery</a></li><li><a href="http://link.springer.com/search?facet-author=%22Donald+Kossmann%22">Donald Kossmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Paul+Lucas%22">Paul Lucas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Fabio+Riccardi%22">Fabio Riccardi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Till+Westmann%22">Till Westmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Carey%22">Michael J. Carey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arvind+Sundararajan%22">Arvind Sundararajan</a></li></ol>
          <input type="checkbox" id="74797"/>
          <label for="74797">Abstract</label>
          <div>This paper describes the design, implementation, and performance characteristics of a commercial XQuery processing engine, the BEA streaming XQuery processor. This XQuery engine was designed to provide high performance for message-processing applications, i.e., for transforming XML data streams. The engine is a central component of the 8.1 release of BEA’s WebLogic Integration (WLI) product. The BEA XQuery engine is fully compliant with the August 2002 draft of the W3C XML Query Language specification and we are currently porting it to the latest version of the XQuery language (July 2004). A goal of this paper is to describe how a fully compliant yet efficient XQuery engine has been built from a few relatively simple components and well-understood technologies.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (May 2004)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0121-9">Querying high-dimensional data in single-dimensional space</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0121-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Cui+Yu%22">Cui Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22St%C3%A9phane+Bressan%22">Stéphane Bressan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li></ol>
          <input type="checkbox" id="91624"/>
          <label for="91624">Abstract</label>
          <div>In this paper, we propose a new tunable index scheme, called iMinMax( $\theta$ ), that maps points in high-dimensional spaces to single-dimensional values determined by their maximum or minimum values among all dimensions. By varying the tuning “knob”, $\theta$ , we can obtain different families of iMinMax structures that are optimized for different distributions of data sets. The transformed data can then be indexed using existing single-dimensional indexing structures such as the B + -trees. Queries in the high-dimensional space have to be transformed into queries in the single-dimensional space and evaluated there. We present efficient algorithms for evaluating window queries as range queries on the single-dimensional space. We conducted an extensive performance study to evaluate the effectiveness of the proposed schemes. Our results show that iMinMax( $\theta$ ) outperforms existing techniques, including the Pyramid scheme and VA-file, by a wide margin. We then describe how iMinMax could be used in approximate K-nearest neighbor (KNN) search, and we present a comparative study against the recently proposed iDistance, a specialized KNN indexing method.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-004-0120-x">ViSWeb - the Visual Semantic Web: unifying human and machine knowledge representations with Object-Process Methodology</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-004-0120-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dov+Dori%22">Dov Dori</a></li></ol>
          <input type="checkbox" id="94917"/>
          <label for="94917">Abstract</label>
          <div>The Visual Semantic Web (ViSWeb) is a new paradigm for enhancing the current Semantic Web technology. Based on Object-Process Methodology (OPM), which enables modeling of systems in a single graphic and textual model, ViSWeb provides for representation of knowledge over the Web in a unified way that caters to human perceptions while also being machine processable. The advantages of the ViSWeb approach include equivalent graphic-text knowledge representation, visual navigability, semantic sentence interpretation, specification of system dynamics, and complexity management. Arguing against the claim that humans and machines need to look at different knowledge representation formats, the principles and basics of various graphic and textual knowledge representations are presented and examined as candidates for ViSWeb foundation. Since OPM is shown to be most adequate for the task, ViSWeb is developed as an OPM-based layer on top of XML/RDF/OWL to express knowledge visually and in natural language. Both the graphic and the textual representations are strictly equivalent. Being intuitive yet formal, they are not only understandable to humans but are also amenable to computer processing. The ability to use such bimodal knowledge representation is potentially a major step forward in the evolution of the Semantic Web.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0112-2">Evaluating holistic aggregators efficiently for very large datasets</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0112-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Lixin+Fu%22">Lixin Fu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sanguthevar+Rajasekaran%22">Sanguthevar Rajasekaran</a></li></ol>
          <input type="checkbox" id="89659"/>
          <label for="89659">Abstract</label>
          <div>In data warehousing applications, numerous OLAP queries involve the processing of holistic aggregators such as computing the “top n,” median, quantiles, etc. In this paper, we present a novel approach called dynamic bucketing to efficiently evaluate these aggregators. We partition data into equiwidth buckets and further partition dense buckets into subbuckets as needed by allocating and reclaiming memory space. The bucketing process dynamically adapts to the input order and distribution of input datasets. The histograms of the buckets and subbuckets are stored in our new data structure called structure trees. A recent selection algorithm based on regular sampling is generalized and its analysis extended. We have also compared our new algorithms with this generalized algorithm and several other recent algorithms. Experimental results show that our new algorithms significantly outperform prior ones not only in the runtime but also in accuracy.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0110-4">Evolutionary techniques for updating query cost models in a dynamic multidatabase environment</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0110-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Amira+Rahal%22">Amira Rahal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qiang+Zhu%22">Qiang Zhu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Per-%C3%85ke+Larson%22">Per-Åke Larson</a></li></ol>
          <input type="checkbox" id="22755"/>
          <label for="22755">Abstract</label>
          <div>Deriving local cost models for query optimization in a dynamic multidatabase system (MDBS) is a challenging issue. In this paper, we study how to evolve a query cost model to capture a slowly-changing dynamic MDBS environment so that the cost model is kept up-to-date all the time. Two novel evolutionary techniques, i.e., the shifting method and the block-moving method, are proposed. The former updates a cost model by taking up-to-date information from a new sample query into consideration at each step, while the latter considers a block (batch) of new sample queries at each step. The relevant issues, including derivation of recurrence updating formulas, development of efficient algorithms, analysis and comparison of complexities, and design of an integrated scheme to apply the two methods adaptively, are studied. Our theoretical and experimental results demonstrate that the proposed techniques are quite promising in maintaining accurate cost models efficiently for a slowly changing dynamic MDBS environment. Besides the application to MDBSs, the proposed techniques can also be applied to the automatic maintenance of cost models in self-managing database systems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0108-y">Amit - the situation manager</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0108-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Asaf+Adi%22">Asaf Adi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Opher+Etzion%22">Opher Etzion</a></li></ol>
          <input type="checkbox" id="83154"/>
          <label for="83154">Abstract</label>
          <div>This paper presents the “situation manager”, a tool that includes both a language and an efficient runtime execution mechanism aimed at reducing the complexity of active applications. This tool follows the observation that in many cases there is a gap between current tools that enable one to react to a single event (following the ECA: event-condition-action paradigm) and the reality in which a single event may not require any reaction; however, the reaction should be given to patterns over the event history. The concept of situation presented in this paper extends the concept of composite event in its expressive power, flexibility, and usability. This paper motivates the work, surveys other efforts in this area, and discusses both the language and the execution model.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 2004)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0091-3">Multidimensional data modeling for location-based services</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0091-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Augustas+Kligys%22">Augustas Kligys</a></li><li><a href="http://link.springer.com/search?facet-author=%22Torben+Bach+Pedersen%22">Torben Bach Pedersen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Igor+Timko%22">Igor Timko</a></li></ol>
          <input type="checkbox" id="6117"/>
          <label for="6117">Abstract</label>
          <div>With the recent and continuing advances in areas such as wireless communications and positioning technologies, mobile, location-based services are becoming possible. Such services deliver location-dependent content to their users. More specifically, these services may capture the movements and requests of their users in multidimensional databases, i.e., data warehouses, and content delivery may be based on the results of complex queries on these data warehouses. Such queries aggregate detailed data in order to find useful patterns, e.g., in the interaction of a particular user with the services. The application of multidimensional technology in this context poses a range of new challenges. The specific challenge addressed here concerns the provision of an appropriate multidimensional data model. In particular, the paper extends an existing multidimensional data model and algebraic query language to accommodate spatial values that exhibit partial containment relationships instead of the total containment relationships normally assumed in multidimensional data models. Partial containment introduces imprecision in aggregation paths. The paper proposes a method for evaluating the imprecision of such paths. The paper also offers transformations of dimension hierarchies with partial containment relationships to simple hierarchies, to which existing precomputation techniques are applicable.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0086-0">Parallel multisource view maintenance</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0086-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Xin+Zhang%22">Xin Zhang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lingli+Ding%22">Lingli Ding</a></li><li><a href="http://link.springer.com/search?facet-author=%22Elke+A.+Rundensteiner%22">Elke A. Rundensteiner</a></li></ol>
          <input type="checkbox" id="17499"/>
          <label for="17499">Abstract</label>
          <div>In a distributed environment, materialized views are used to integrate data from different information sources and then store them in some centralized location. In order to maintain such materialized views, maintenance queries need to be sent to information sources by the data warehouse management system. Due to the independence of the information sources and the data warehouse, concurrency issues are raised between the maintenance queries and the local update transactions at each information source. Recent solutions such as ECA and Strobe tackle such concurrent maintenance, however with the requirement of quiescence of the information sources. SWEEP and POSSE overcome this limitation by decomposing the global maintenance query into smaller subqueries to be sent to every information source and then performing conflict correction locally at the data warehouse. Note that all these previous approaches handle the data updates one at a time. Hence either some of the information sources or the data warehouse is likely to be idle during most of the maintenance process. In this paper, we propose that a set of updates should be maintained in parallel by several concurrent maintenance processes so that both the information sources as well as the warehouse would be utilized more fully throughout the maintenance process. This parallelism should then improve the overall maintenance performance. For this we have developed a parallel view maintenance algorithm, called PVM, that substantially improves upon the performance of previous maintenance approaches by handling a set of data updates at the same time. The parallel handling of a set of updates is orthogonal to the particular maintenance algorithm applied to the handling of each individual update. In order to perform parallel view maintenance, we have identified two critical issues that must be overcome: (1) detecting maintenance-concurrent data updates in a parallel mode and (2) correcting the problem that the data warehouse commit order may not correspond to the data warehouse update processing order due to parallel maintenance handling. In this work, we provide solutions to both issues. For the former, we insert a middle-layer timestamp assignment module for detecting maintenance-concurrent data updates without requiring any global clock synchronization. For the latter, we introduce the negative counter concept to solve the problem of variant orders of committing effects of data updates to the data warehouse. We provide a proof of the correctness of PVM that guarantees that our strategy indeed generates the correct final data warehouse state. We have implemented both SWEEP and PVM in our EVE data warehousing system. Our performance study demonstrates that a manyfold performance improvement is achieved by PVM over SWEEP.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0099-8">Algorithms and applications for answering ranked queries using ranked views</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0099-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vagelis+Hristidis%22">Vagelis Hristidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Papakonstantinou%22">Yannis Papakonstantinou</a></li></ol>
          <input type="checkbox" id="83376"/>
          <label for="83376">Abstract</label>
          <div>Ranked queries return the top objects of a database according to a preference function. We present and evaluate (experimentally and theoretically) a core algorithm that answers ranked queries in an efficient pipelined manner using materialized ranked views. We use and extend the core algorithm in the described PREFER and MERGE systems. PREFER precomputes a set of materialized views that provide guaranteed query performance. We present an algorithm that selects a near optimal set of views under space constraints. We also describe multiple optimizations and implementation aspects of the downloadable version of PREFER. Then we discuss MERGE, which operates at a metabroker and answers ranked queries by retrieving a minimal number of objects from sources that offer ranked queries. A speculative version of the pipelining algorithm is described.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0105-1">Retrieval effectiveness of an ontology-based model for information selection</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0105-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Latifur+Khan%22">Latifur Khan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dennis+McLeod%22">Dennis McLeod</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eduard+Hovy%22">Eduard Hovy</a></li></ol>
          <input type="checkbox" id="15784"/>
          <label for="15784">Abstract</label>
          <div>Technology in the field of digital media generates huge amounts of nontextual information, audio, video, and images, along with more familiar textual information. The potential for exchange and retrieval of information is vast and daunting. The key problem in achieving efficient and user-friendly retrieval is the development of a search mechanism to guarantee delivery of minimal irrelevant information (high precision) while insuring relevant information is not overlooked (high recall). The traditional solution employs keyword-based search. The only documents retrieved are those containing user-specified keywords. But many documents convey desired semantic information without containing these keywords. This limitation is frequently addressed through query expansion mechanisms based on the statistical co-occurrence of terms. Recall is increased, but at the expense of deteriorating precision. One can overcome this problem by indexing documents according to context and meaning rather than keywords, although this requires a method of converting words to meanings and the creation of a meaning-based index structure. We have solved the problem of an index structure through the design and implementation of a concept-based model using domain-dependent ontologies. An ontology is a collection of concepts and their interrelationships that provide an abstract view of an application domain. With regard to converting words to meaning, the key issue is to identify appropriate concepts that both describe and identify documents as well as language employed in user requests. This paper describes an automatic mechanism for selecting these concepts. An important novelty is a scalable disambiguation algorithm that prunes irrelevant concepts and allows relevant ones to associate with documents and participate in query generation. We also propose an automatic query expansion mechanism that deals with user requests expressed in natural language. This mechanism generates database queries with appropriate and relevant expansion through knowledge encoded in ontology form. Focusing on audio data, we have constructed a demonstration prototype. We have experimentally and analytically shown that our model, compared to keyword search, achieves a significantly higher degree of precision and recall. The techniques employed can be applied to the problem of information selection in all media types.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0114-0">Rule-based spatiotemporal query processing for video databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0114-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mehmet+Emin+D%C3%B6nderler%22">Mehmet Emin Dönderler</a></li><li><a href="http://link.springer.com/search?facet-author=%22%C3%96zg%C3%BCr+Ulusoy%22">Özgür Ulusoy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ugur+G%C3%BCd%C3%BCkbay%22">Ugur Güdükbay</a></li></ol>
          <input type="checkbox" id="42397"/>
          <label for="42397">Abstract</label>
          <div>In our earlier work, we proposed an architecture for a Web-based video database management system (VDBMS) providing an integrated support for spatiotemporal and semantic queries. In this paper, we focus on the task of spatiotemporal query processing and also propose an SQL-like video query language that has the capability to handle a broad range of spatiotemporal queries. The language is rule-based in that it allows users to express spatial conditions in terms of Prolog-type predicates. Spatiotemporal query processing is carried out in three main stages: query recognition, query decomposition, and query execution.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 12 (May 2003 - November 2003)</h1>
          <ol><li>
          <h2>Issue 4 (November 2003)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0109-x">Guest editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0109-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vijay+Atluri%22">Vijay Atluri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anupam+Joshi%22">Anupam Joshi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yelena+Yesha%22">Yelena Yesha</a></li></ol>
          <input type="checkbox" id="89128"/>
          <label for="89128">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0102-4">Managing multiple and distributed ontologies on the Semantic Web</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0102-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22A.+Maedche%22">A. Maedche</a></li><li><a href="http://link.springer.com/search?facet-author=%22B.+Motik%22">B. Motik</a></li><li><a href="http://link.springer.com/search?facet-author=%22L.+Stojanovic%22">L. Stojanovic</a></li></ol>
          <input type="checkbox" id="80277"/>
          <label for="80277">Abstract</label>
          <div>In traditional software systems, significant attention is devoted to keeping modules well separated and coherent with respect to functionality, thus ensuring that changes in the system are localized to a handful of modules. Reuse is seen as the key method in reaching that goal. Ontology-based systems on the Semantic Web are just a special class of software systems, so the same principles apply. In this article, we present an integrated framework for managing multiple and distributed ontologies on the Semant ic Web. It is based on the representation model for ontologies, trading off between expressivity and tractability. In our framework, we provide features for reusing existing ontologies and for evolving them while retaining the consistency. The approach is implemented within KAON, the Karlsruhe Ontology and Semantic Web tool suite.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0104-2">Learning to match ontologies on the Semantic Web</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0104-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22AnHai+Doan%22">AnHai Doan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jayant+Madhavan%22">Jayant Madhavan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Robin+Dhamankar%22">Robin Dhamankar</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pedro+Domingos%22">Pedro Domingos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Halevy%22">Alon Halevy</a></li></ol>
          <input type="checkbox" id="26268"/>
          <label for="26268">Abstract</label>
          <div>On the Semantic Web, data will inevitably come from many different ontologies, and information processing across ontologies is not possible without knowing the semantic mappings between them. Manually finding such mappings is tedious, error-prone, and clearly not possible on the Web scale. Hence the development of tools to assist in the ontology mapping process is crucial to the success of the Semantic Web. We describe GLUE, a system that employs machine learning techniques to find such mappings. Given two ontologies, for each concept in one ontology GLUE finds the most similar concept in the other ontology. We give well-founded probabilistic definitions to several practical similarity measures and show that GLUE can work with all of them. Another key feature of GLUE is that it uses multiple learning strategies, each of which exploits well a different type of information either in the data instances or in the taxonomic structure of the ontologies. To further improve matching accuracy, we extend GLUE to incorporate commonsense knowledge and domain constraints into the matching process. Our approach is thus distinguished in that it works with a variety of well-defined similarity notions and that it efficiently incorporates multiple types of knowledge. We describe a set of experiments on several real-world domains and show that GLUE proposes highly accurate semantic mappings. Finally, we extend GLUE to find complex mappings between ontologies and describe experiments that show the promise of the approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0100-6">THESUS: Organizing Web document collections based on link semantics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0100-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Maria+Halkidi%22">Maria Halkidi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Benjamin+Nguyen%22">Benjamin Nguyen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Iraklis+Varlamis%22">Iraklis Varlamis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michalis+Vazirgiannis%22">Michalis Vazirgiannis</a></li></ol>
          <input type="checkbox" id="94047"/>
          <label for="94047">Abstract</label>
          <div>The requirements for effective search and management of the WWW are stronger than ever. Currently Web documents are classified based on their content not taking into account the fact that these documents are connected to each other by links. We claim that a page’s classification is enriched by the detection of its incoming links’ semantics. This would enable effective browsing and enhance the validity of search results in the WWW context. Another aspect that is underaddressed and strictly related to the tasks of browsing and searching is the similarity of documents at the semantic level. The above observations lead us to the adoption of a hierarchy of concepts (ontology) and a thesaurus to exploit links and provide a better characterization of Web documents. The enhancement of document characterization makes operations such as clustering and labeling very interesting. To this end, we devised a system called THESUS. The system deals with an initial sets of Web documents, extracts keywords from all pages’ incoming links, and converts them to semantics by mapping them to a domain’s ontology. Then a clustering algorithm is applied to discover groups of Web documents. The effectiveness of the clustering process is based on the use of a novel similarity measure between documents characterized by sets of terms. Web documents are organized into thematic subsets based on their semantics. The subsets are then labeled, thereby enabling easier management (browsing, searching, querying) of the Web. In this article, we detail the process of this system and give an experimental analysis of its results.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0101-5">Composing Web services on the Semantic Web</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0101-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Brahim+Medjahed%22">Brahim Medjahed</a></li><li><a href="http://link.springer.com/search?facet-author=%22Athman+Bouguettaya%22">Athman Bouguettaya</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ahmed+K.+Elmagarmid%22">Ahmed K. Elmagarmid</a></li></ol>
          <input type="checkbox" id="695"/>
          <label for="695">Abstract</label>
          <div>Service composition is gaining momentum as the potential silver bullet for the envisioned Semantic Web. It purports to take the Web to unexplored efficiencies and provide a flexible approach for promoting all types of activities in tomorrow’s Web. Applications expected to heavily take advantage of Web service composition include B2B E-commerce and E-government. To date, enabling composite services has largely been an ad hoc, time-consuming, and error-prone process involving repetitive low-level programming. In this paper, we propose an ontology-based framework for the automatic composition of Web services. We present a technique to generate composite services from high-level declarative descriptions. We define formal safeguards for meaningful composition through the use of composability rules. These rules compare the syntactic and semantic features of Web services to determine whether two services are composable. We provide an implementation using an E-government application offering customized services to indigent citizens. Finally, we present an exhaustive performance experiment to assess the scalability of our approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0103-3">POESIA: An ontological workflow approach for composing Web services in agriculture</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0103-3.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Renato+Fileto%22">Renato Fileto</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ling+Liu%22">Ling Liu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Calton+Pu%22">Calton Pu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eduardo+Delgado+Assad%22">Eduardo Delgado Assad</a></li><li><a href="http://link.springer.com/search?facet-author=%22Claudia+Bauzer+Medeiros%22">Claudia Bauzer Medeiros</a></li></ol>
          <input type="checkbox" id="66341"/>
          <label for="66341">Abstract</label>
          <div>This paper describes the POESIA approach to systematic composition of Web services. This pragmatic approach is strongly centered in the use of domain-specific multidimensional ontologies. Inspired by applications needs and founded on ontologies, workflows, and activity models, POESIA provides well-defined operations (aggregation, specialization, and instantiation) to support the composition of Web services. POESIA complements current proposals for Web services definition and composition by providing a higher degree of abstraction with verifiable consistency properties. We illustrate the POESIA approach using a concrete application scenario in agroenvironmental planning.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (October 2003)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0084-7">Cost-driven vertical class partitioning for methods in object oriented databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0084-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chi-Wai+Fung%22">Chi-Wai Fung</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kamalakar+Karlapalem%22">Kamalakar Karlapalem</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qing+Li%22">Qing Li</a></li></ol>
          <input type="checkbox" id="97522"/>
          <label for="97522">Abstract</label>
          <div>In object-oriented databases (OODBs), a method encapsulated in a class typically accesses a few, but not all the instance variables defined in the class. It may thus be preferable to vertically partition the class for reducing irrelevant data (instance variables) accessed by the methods. Our prior work has shown that vertical class partitioning can result in a substantial decrease in the total number of disk accesses incurred for executing a set of applications, but coming up with an optimal vertical class partitioning scheme is a hard problem. In this paper, we present two algorithms for deriving optimal and near-optimal vertical class partitioning schemes. The cost-driven algorithm provides the optimal vertical class partitioning schemes by enumerating, exhaustively, all the schemes and calculating the number of disk accesses required to execute a given set of applications. For this, a cost model for executing a set of methods in an OODB system is developed. Since exhaustive enumeration is costly and only works for classes with a small number of instance variables, a hill-climbing heuristic algorithm (HCHA) is developed, which takes the solution provided by the affinity-based algorithm and improves it, thereby further reducing the total number of disk accesses incurred. We show that the HCHA algorithm provides a reasonable near-optimal vertical class partitioning scheme for executing a given set of applications.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0085-6">Computing complete answers to queries in the presence of limited access patterns</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0085-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chen+Li%22">Chen Li</a></li></ol>
          <input type="checkbox" id="32113"/>
          <label for="32113">Abstract</label>
          <div>In data applications such as information integration, there can be limited access patterns to relations, i.e., binding patterns require values to be specified for certain attributes in order to retrieve data from a relation. As a consequence, we cannot retrieve all tuples from these relations. In this article we study the problem of computing the complete answer to a query, i.e., the answer that could be computed if all the tuples could be retrieved. A query is stable if for any instance of the relations in the query, its complete answer can be computed using the access patterns permitted by the relations. We study the problem of testing stability of various classes of queries, including conjunctive queries, unions of conjunctive queries, and conjunctive queries with arithmetic comparisons. We give algorithms and complexity results for these classes of queries. We show that stability of datalog programs is undecidable, and give a sufficient condition for stability of datalog queries. Finally, we study data-dependent computability of the complete answer to a nonstable query, and propose a decision tree for guiding the process to compute the complete answer.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0088-y">Instance-based attribute identification in database integration</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0088-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Cecil+Eng+H.+Chua%22">Cecil Eng H. Chua</a></li><li><a href="http://link.springer.com/search?facet-author=%22Roger+H.+L.+Chiang%22">Roger H. L. Chiang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ee-Peng+Lim%22">Ee-Peng Lim</a></li></ol>
          <input type="checkbox" id="54975"/>
          <label for="54975">Abstract</label>
          <div>Most research on attribute identification in database integration has focused on integrating attributes using schema and summary information derived from the attribute values. No research has attempted to fully explore the use of attribute values to perform attribute identification. We propose an attribute identification method that employs schema and summary instance information as well as properties of attributes derived from their instances. Unlike other attribute identification methods that match only single attributes, our method matches attribute groups for integration. Because our attribute identification method fully explores data instances, it can identify corresponding attributes to be integrated even when schema information is misleading. Three experiments were performed to validate our attribute identification method. In the first experiment, the heuristic rules derived for attribute classification were evaluated on 119 attributes from nine public domain data sets. The second was a controlled experiment validating the robustness of the proposed attribute identification method by introducing erroneous data. The third experiment evaluated the proposed attribute identification method on five data sets extracted from online music stores. The results demonstrated the viability of the proposed method.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0106-0">A performance study of four index structures for set-valued attributes of low cardinality</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0106-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sven+Helmer%22">Sven Helmer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Guido+Moerkotte%22">Guido Moerkotte</a></li></ol>
          <input type="checkbox" id="56396"/>
          <label for="56396">Abstract</label>
          <div>The efficient retrieval of data items on set-valued attributes is an important research topic that has attracted little attention so far. We studied and modified four index structures (sequential signature files, signature trees, extendible signature hashing, and inverted files) for a fast retrieval of sets with low cardinality. We compared the index structures by implementing them and subjecting them to extensive experiments, investigating the influence of query set size, database size, domain size, and data distribution (synthetic and real). The results of the experiments clearly indicate that inverted files exhibit the best overall behavior of all tested index structures.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0107-z">Incremental computation and maintenance of temporal aggregates</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0107-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jun+Yang%22">Jun Yang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jennifer+Widom%22">Jennifer Widom</a></li></ol>
          <input type="checkbox" id="65254"/>
          <label for="65254">Abstract</label>
          <div>We consider the problems of computing aggregation queries in temporal databases and of maintaining materialized temporal aggregate views efficiently. The latter problem is particularly challenging since a single data update can cause aggregate results to change over the entire time line. We introduce a new index structure called the SB-tree, which incorporates features from both segment-trees and B-trees. SB-trees support fast lookup of aggregate results based on time and can be maintained efficiently when the data change. We extend the basic SB-tree index to handle cumulative (also called moving-window) aggregates, considering separatelycases when the window size is or is not fixed in advance. For materialized aggregate views in a temporal database or warehouse, we propose building and maintaining SB-tree indices instead of the views themselves.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (August 2003)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0092-2">Guest editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0092-2.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Philip+A.+Bernstein%22">Philip A. Bernstein</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Ioannidis%22">Yannis Ioannidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raghu+Ramakrishnan%22">Raghu Ramakrishnan</a></li></ol>
          <input type="checkbox" id="80801"/>
          <label for="80801">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0093-1">A case for fractured mirrors</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0093-1.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ravishankar+Ramamurthy%22">Ravishankar Ramamurthy</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+J.+DeWitt%22">David J. DeWitt</a></li><li><a href="http://link.springer.com/search?facet-author=%22Qi+Su%22">Qi Su</a></li></ol>
          <input type="checkbox" id="47240"/>
          <label for="47240">Abstract</label>
          <div>The decomposition storage model (DSM) vertically partitions all attributes of a table and has excellent I/O behavior when the number of attributes accessed by a query is small. It also has a better cache footprint than the standard storage model (NSM) used by most database systems. However, DSM incurs a high cost in reconstructing the original tuple from its partitions. We first revisit some of the performance problems associated with DSM and suggest a simple indexing strategy and compare different reconstruction algorithms. Then we propose a new mirroring scheme, termed fractured mirrors, using both NSM and DSM models. This scheme combines the best aspects of both models, along with the added benefit of mirroring to better serve an ad hoc query workload. A prototype system has been built using the Shore storage manager, and performance is evaluated using queries from the TPC-H workload.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0094-0">RE-tree: an efficient index structure for regular expressions</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0094-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chee-Yong+Chan%22">Chee-Yong Chan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Minos+Garofalakis%22">Minos Garofalakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rajeev+Rastogi%22">Rajeev Rastogi</a></li></ol>
          <input type="checkbox" id="4284"/>
          <label for="4284">Abstract</label>
          <div>Due to their expressive power, regular expressions (REs) are quickly becoming an integral part of language specifications for several important application scenarios. Many of these applications have to manage huge databases of RE specifications and need to provide an effective matching mechanism that, given an input string, quickly identifies the REs in the database that match it. In this paper, we propose the RE-tree, a novel index structure for large databases of RE specifications. Given an input query string, the RE-tree speeds up the retrieval of matching REs by focusing the search and comparing the input string with only a small fraction of REs in the database. Even though the RE-tree is similar in spirit to other tree-based structures that have been proposed for indexing multidimensional data, RE indexing is significantly more challenging since REs typically represent infinite sets of strings with no well-defined notion of spatial locality. To address these new challenges, our RE-tree index structure relies on novel measures for comparing the relative sizes of infinite regular languages. We also propose innovative solutions for the various RE-tree operations including the effective splitting of RE-tree nodes and computing a "tight" bounding RE for a collection of REs. Finally, we demonstrate how sampling-based approximation algorithms can be used to significantly speed up the performance of RE-tree operations. Preliminary experimental results with moderately large synthetic data sets indicate that the RE-tree is effective in pruning the search space and easily outperforms naive sequential search approaches.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0095-z">Aurora: a new model and architecture for data stream management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0095-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniel+J.+Abadi%22">Daniel J. Abadi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Don+Carney%22">Don Carney</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ugur+%C3%87etintemel%22">Ugur Çetintemel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mitch+Cherniack%22">Mitch Cherniack</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+Convey%22">Christian Convey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sangdon+Lee%22">Sangdon Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Stonebraker%22">Michael Stonebraker</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nesime+Tatbul%22">Nesime Tatbul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stan+Zdonik%22">Stan Zdonik</a></li></ol>
          <input type="checkbox" id="940"/>
          <label for="940">Abstract</label>
          <div>This paper describes the basic processing model and architecture of Aurora, a new system to manage data streams for monitoring applications. Monitoring applications differ substantially from conventional business data processing. The fact that a software system must process and react to continual inputs from many sources (e.g., sensors) rather than from human operators requires one to rethink the fundamental architecture of a DBMS for this application area. In this paper, we present Aurora, a new DBMS currently under construction at Brandeis University, Brown University, and M.I.T. We first provide an overview of the basic Aurora model and architecture and then describe in detail a stream-oriented set of operators.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0096-y">PSoup: a system for streaming queries over streaming data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0096-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sirish+Chandrasekaran%22">Sirish Chandrasekaran</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Franklin%22">Michael J. Franklin</a></li></ol>
          <input type="checkbox" id="51653"/>
          <label for="51653">Abstract</label>
          <div>Recent work on querying data streams has focused on systems where newly arriving data is processed and continuously streamed to the user in real time. In many emerging applications, however, ad hoc queries and/or intermittent connectivity also require the processing of data that arrives prior to query submission or during a period of disconnection. For such applications, we have developed PSoup, a system that combines the processing of ad hoc and continuous queries by treating data and queries symmetrically, allowing new queries to be applied to old data and new data to be applied to old queries. PSoup also supports intermittent connectivity by separating the computation of query results from the delivery of those results. PSoup builds on adaptive query-processing techniques developed in the Telegraph project at UC Berkeley. In this paper, we describe PSoup and present experiments that demonstrate the effectiveness of our approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0097-x">Watermarking relational data: framework, algorithms and analysis</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0097-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rakesh+Agrawal%22">Rakesh Agrawal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+J.+Haas%22">Peter J. Haas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jerry+Kiernan%22">Jerry Kiernan</a></li></ol>
          <input type="checkbox" id="89122"/>
          <label for="89122">Abstract</label>
          <div>We enunciate the need for watermarking database relations to deter data piracy, identify the characteristics of relational data that pose unique challenges for watermarking, and delineate desirable properties of a watermarking system for relational data. We then present an effective watermarking technique geared for relational data. This technique ensures that some bit positions of some of the attributes of some of the tuples contain specific values. The specific bit locations and values are algorithmically determined under the control of a secret key known only to the owner of the data. This bit pattern constitutes the watermark. Only if one has access to the secret key can the watermark be detected with high probability. Detecting the watermark requires access neither to the original data nor the watermark, and the watermark can be easily and efficiently maintained in the presence of insertions, updates, and deletions. Our analysis shows that the proposed technique is robust against various forms of malicious attacks as well as benign updates to the data. Using an implementation running on DB2, we also show that the algorithms perform well enough to be used in real-world applications.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0098-9">Fast and accurate text classification via multiple linear discriminant projections</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0098-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Soumen+Chakrabarti%22">Soumen Chakrabarti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shourya+Roy%22">Shourya Roy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mahesh+V.+Soundalgekar%22">Mahesh V. Soundalgekar</a></li></ol>
          <input type="checkbox" id="8278"/>
          <label for="8278">Abstract</label>
          <div>Support vector machines (SVMs) have shown superb performance for text classification tasks. They are accurate, robust, and quick to apply to test instances. Their only potential drawback is their training time and memory requirement. For n training instances held in memory, the best-known SVM implementations take time proportional to na, where a is typically between 1.8 and 2.1. SVMs have been trained on data sets with several thousand instances, but Web directories today contain millions of instances that are valuable for mapping billions of Web pages into Yahoo!-like directories. We present SIMPL, a nearly linear-time classification algorithm that mimics the strengths of SVMs while avoiding the training bottleneck. It uses Fisher's linear discriminant, a classical tool from statistical pattern recognition, to project training instances to a carefully selected low-dimensional subspace before inducing a decision tree on the projected instances. SIMPL uses efficient sequential scans and sorts and is comparable in speed and memory scalability to widely used naive Bayes (NB) classifiers, but it beats NB accuracy decisively. It not only approaches and sometimes exceeds SVM accuracy, but also beats the running time of a popular SVM implementation by orders of magnitude. While describing SIMPL, we make a detailed experimental comparison of SVM-generated discriminants with Fisher's discriminants, and we also report on an analysis of the cache performance of a popular SVM implementation. Our analysis shows that SIMPL has the potential to be the method of choice for practitioners who want the accuracy of SVMs and the simplicity and speed of naive Bayes classifiers.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (May 2003)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0089-x">New partnership with ACM and update on the journal</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0089-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li></ol>
          <input type="checkbox" id="99923"/>
          <label for="99923">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0071-z">Complex relationships and knowledge discovery support in the InfoQuilt system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0071-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22A.+Sheth%22">A. Sheth</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Thacker%22">S. Thacker</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Patel%22">S. Patel</a></li></ol>
          <input type="checkbox" id="50611"/>
          <label for="50611">Abstract</label>
          <div>Support for semantic content is becoming more common in Web-accessible information systems. We see this support emerging with the use of ontologies and machine-readable, annotated documents. The practice of domain modeling coupled with the extraction of domain-specific, contextually relevant metadata also supports the use of semantics. These advancements enable knowledge discovery approaches that define complex relationships between data that is autonomously collected and managed. The InfoQuilt (One of the incarnations of the InfoQuilt system, as applied to the geographic information as part of the NSF Digital Library II initiative is the ADEPT-UGA system [Ade]. This research was funded in part by National Science Foundation grant IIS-9817432.) system supports one such knowledge discovery approach. This paper presents (parts of) the InfoQuilt system with the focus on its use for modeling and utilizing complex semantic inter-domain relationships to enable human-assisted knowledge discovery over Web-accessible heterogeneous data. This includes the specification and execution of Information Scale (IScapes), a semantically rich information request and correlation mechanism.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0072-y">A Bayesian decision model for cost optimal record matching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0072-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22V.S.+Verykios%22">V.S. Verykios</a></li><li><a href="http://link.springer.com/search?facet-author=%22G.V.+Moustakides%22">G.V. Moustakides</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.G.+Elfeky%22">M.G. Elfeky</a></li></ol>
          <input type="checkbox" id="21810"/>
          <label for="21810">Abstract</label>
          <div>In an error-free system with perfectly clean data, the construction of a global view of the data consists of linking - in relational terms, joining - two or more tables on their key fields. Unfortunately, most of the time, these data are neither carefully controlled for quality nor necessarily defined commonly across different data sources. As a result, the creation of such a global data view resorts to approximate joins. In this paper, an optimal solution is proposed for the matching or the linking of database record pairs in the presence of inconsistencies, errors or missing values in the data. Existing models for record matching rely on decision rules that minimize the probability of error, that is the probability that a sample (a measurement vector) is assigned to the wrong class. In practice though, minimizing the probability of error is not the best criterion to design a decision rule because the misclassifications of different samples may have different consequences. In this paper we present a decision model that minimizes the cost of making a decision. In particular: (a) we present a decision rule: (b) we prove that this rule is optimal with respect to the cost of a decision: and (c) we compute the probabilities of the two types of errors (Type I and Type II) that incur when this rule is applied. We also present a closed form decision model for a certain class of record comparison pairs along with an example, and results from comparing the proposed cost-based model to the error-based model, for large record comparison spaces.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0083-8">Lineage tracing for general data warehouse transformations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0083-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Y.+Cui%22">Y. Cui</a></li><li><a href="http://link.springer.com/search?facet-author=%22J.+Widom%22">J. Widom</a></li></ol>
          <input type="checkbox" id="28146"/>
          <label for="28146">Abstract</label>
          <div>Data warehousing systems integrate information from operational data sources into a central repository to enable analysis and mining of the integrated information. During the integration process, source data typically undergoes a series of transformations, which may vary from simple algebraic operations or aggregations to complex “data cleansing” procedures. In a warehousing environment, the data lineage problem is that of tracing warehouse data items back to the original source items from which they were derived. We formally define the lineage tracing problem in the presence of general data warehouse transformations, and we present algorithms for lineage tracing in this environment. Our tracing procedures take advantage of known structure or properties of transformations when present, but also work in the absence of such information. Our results can be used as the basis for a lineage tracing tool in a general warehousing setting, and also can guide the design of data warehouses that enable efficient lineage tracing.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-003-0087-z">Business-to-business interactions: issues and enabling technologies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-003-0087-z.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22B.+Medjahed%22">B. Medjahed</a></li><li><a href="http://link.springer.com/search?facet-author=%22B.+Benatallah%22">B. Benatallah</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Bouguettaya%22">A. Bouguettaya</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.H.H.+Ngu%22">A.H.H. Ngu</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.K.+Elmagarmid%22">A.K. Elmagarmid</a></li></ol>
          <input type="checkbox" id="3171"/>
          <label for="3171">Abstract</label>
          <div>Business-to-Business (B2B) technologies pre-date the Web. They have existed for at least as long as the Internet. B2B applications were among the first to take advantage of advances in computer networking. The Electronic Data Interchange (EDI) business standard is an illustration of such an early adoption of the advances in computer networking. The ubiquity and the affordability of the Web has made it possible for the masses of businesses to automate their B2B interactions. However, several issues related to scale, content exchange, autonomy, heterogeneity, and other issues still need to be addressed. In this paper, we survey the main techniques, systems, products, and standards for B2B interactions. We propose a set of criteria for assessing the different B2B interaction techniques, standards, and products.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 11 (August 2002 - December 2002)</h1>
          <ol><li>
          <h2>Issue 4 (December 2002)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0082-9">Guest Editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0082-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alon+Y.+Halevy%22">Alon Y. Halevy</a></li></ol>
          <input type="checkbox" id="36954"/>
          <label for="36954">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0081-x">TIMBER: A native XML database</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0081-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22H.V.+Jagadish%22">H.V. Jagadish</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Al-Khalifa%22">S. Al-Khalifa</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Chapman%22">A. Chapman</a></li><li><a href="http://link.springer.com/search?facet-author=%22L.V.S.+Lakshmanan%22">L.V.S. Lakshmanan</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Nierman%22">A. Nierman</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Paparizos%22">S. Paparizos</a></li><li><a href="http://link.springer.com/search?facet-author=%22J.M.+Patel%22">J.M. Patel</a></li><li><a href="http://link.springer.com/search?facet-author=%22D.+Srivastava%22">D. Srivastava</a></li><li><a href="http://link.springer.com/search?facet-author=%22N.+Wiwatwattana%22">N. Wiwatwattana</a></li><li><a href="http://link.springer.com/search?facet-author=%22Y.+Wu%22">Y. Wu</a></li><li><a href="http://link.springer.com/search?facet-author=%22C.+Yu%22">C. Yu</a></li></ol>
          <input type="checkbox" id="50887"/>
          <label for="50887">Abstract</label>
          <div>This paper describes the overall design and architecture of the Timber XML database system currently being implemented at the University of Michigan. The system is based upon a bulk algebra for manipulating trees, and natively stores XML. New access methods have been developed to evaluate queries in the XML context, and new cost estimation and query optimization techniques have also been developed. We present performance numbers to support some of our design decisions. We believe that the key intellectual contribution of this system is a comprehensive set-at-a-time query processing ability in a native XML store, with all the standard components of relational query processing, including algebraic rewriting and a cost-based optimizer.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0080-y">Anatomy of a native XML base management system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0080-y.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22T.+Fiebig%22">T. Fiebig</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Helmer%22">S. Helmer</a></li><li><a href="http://link.springer.com/search?facet-author=%22C.-C.+Kanne%22">C.-C. Kanne</a></li><li><a href="http://link.springer.com/search?facet-author=%22G.+Moerkotte%22">G. Moerkotte</a></li><li><a href="http://link.springer.com/search?facet-author=%22J.+Neumann%22">J. Neumann</a></li><li><a href="http://link.springer.com/search?facet-author=%22R.+Schiele%22">R. Schiele</a></li><li><a href="http://link.springer.com/search?facet-author=%22T.+Westmann%22">T. Westmann</a></li></ol>
          <input type="checkbox" id="84555"/>
          <label for="84555">Abstract</label>
          <div>Several alternatives to manage large XML document collections exist, ranging from file systems over relational or other database systems to specifically tailored XML base management systems. In this paper we give a tour of Natix, a database management system designed from scratch for storing and processing XML data. Contrary to the common belief that management of XML data is just another application for traditional databases like relational systems, we illustrate how almost every component in a database system is affected in terms of adequacy and performance. We show how to design and optimize areas such as storage, transaction management - comprising recovery and multi-user synchronization - as well as query processing for XML.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0076-7">Tree pattern query minimization</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0076-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22S.+Amer-Yahia%22">S. Amer-Yahia</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Cho%22">S. Cho</a></li><li><a href="http://link.springer.com/search?facet-author=%22L.V.S.+Lakshmanan%22">L.V.S. Lakshmanan</a></li><li><a href="http://link.springer.com/search?facet-author=%22D.+Srivastava%22">D. Srivastava</a></li></ol>
          <input type="checkbox" id="87270"/>
          <label for="87270">Abstract</label>
          <div>Tree patterns form a natural basis to query tree-structured data such as XML and LDAP. To improve the efficiency of tree pattern matching, it is essential to quickly identify and eliminate redundant nodes in the pattern. In this paper, we study tree pattern minimization both in the absence and in the presence of integrity constraints (ICs) on the underlying tree-structured database. In the absence of ICs, we develop a polynomial-time query minimization algorithm called CIM, whose efficiency stems from two key properties: (i) a node cannot be redundant unless its children are; and (ii) the order of elimination of redundant nodes is immaterial. When ICs are considered for minimization, we develop a technique for query minimization based on three fundamental operations: augmentation (an adaptation of the well-known chase procedure), minimization (based on homomorphism techniques), and reduction. We show the surprising result that the algorithm, referred to as ACIM, obtained by first augmenting the tree pattern using ICs, and then applying CIM, always finds the unique minimal equivalent query. While ACIM is polynomial time, it can be expensive in practice because of its inherent non-locality. We then present a fast algorithm, CDM, that identifies and eliminates local redundancies due to ICs, based on propagating ”information labels” up the tree pattern. CDM can be applied prior to ACIM for improving the minimization efficiency. We complement our analytical results with an experimental study that shows the effectiveness of our tree pattern minimization techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0079-4">Efficient schemes for managing multiversionXML documents</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0079-4.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22S.-Y.+Chien%22">S.-Y. Chien</a></li><li><a href="http://link.springer.com/search?facet-author=%22V.J.+Tsotras%22">V.J. Tsotras</a></li><li><a href="http://link.springer.com/search?facet-author=%22C.+Zaniolo%22">C. Zaniolo</a></li></ol>
          <input type="checkbox" id="16252"/>
          <label for="16252">Abstract</label>
          <div>Multiversion support for XML documents is needed in many critical applications, such as software configuration control, cooperative authoring, web information warehouses, and ”e-permanence” of web documents. In this paper, we introduce efficient and robust techniques for: (i) storing and retrieving; (ii) viewing and exchanging; and (iii) querying multiversion XML documents. We first discuss the limitations of traditional version control methods, such as RCS and SCCS, and then propose novel techniques that overcome their limitations. Initially, we focus on the problem of managing secondary storage efficiently, and introduce an edit-based versioning scheme that enhances RCS with an effective clustering policy based on the concept of page-usefulness. The new scheme drastically improves version retrieval at the expense of a small (linear) space overhead. However, the edit-based approach falls short of achieving objectives (ii) and (iii). Therefore, we introduce and investigate a second scheme, which is reference-based and preserves the structure of the original document. In the reference-based approach, a multiversion document can be represented as yet another XML document, which can be easily exchanged and viewed on the web; furthermore, simple queries are also expressed and supported well under this representation. To achieve objective (i), we extend the page-usefulness clustering technique to the reference-based scheme. After characterizing the asymptotic behavior of the new techniques proposed, the paper presents the results of an experimental study evaluating and comparing their performance.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0077-6">Efficient filtering of XML documents with XPath expressions</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0077-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22C.-Y.+Chan%22">C.-Y. Chan</a></li><li><a href="http://link.springer.com/search?facet-author=%22P.+Felber%22">P. Felber</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Garofalakis%22">M. Garofalakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22R.+Rastogi%22">R. Rastogi</a></li></ol>
          <input type="checkbox" id="62635"/>
          <label for="62635">Abstract</label>
          <div>The publish/subscribe paradigm is a popular model for allowing publishers (i.e., data generators) to selectively disseminate data to a large number of widely dispersed subscribers (i.e., data consumers) who have registered their interest in specific information items. Early publish/subscribe systems have typically relied on simple subscription mechanisms, such as keyword or ”bag of words” matching, or simple comparison predicates on attribute values. The emergence of XML as a standard for information exchange on the Internet has led to an increased interest in using more expressive subscription mechanisms (e.g., based on XPath expressions) that exploit both the structure and the content of published XML documents. Given the increased complexity of these new data-filtering mechanisms, the problem of effectively identifying the subscription profiles that match an incoming XML document poses a difficult and important research challenge. In this paper, we propose a novel index structure, termed XTrie, that supports the efficient filtering of XML documents based on XPath expressions. Our XTrie index structure offers several novel features that, we believe, make it especially attractive for large-scale publish/subscribe systems. First, XTrie is designed to support effective filtering based on complex XPath expressions (as opposed to simple, single-path specifications). Second, our XTrie structure and algorithms are designed to support both ordered and unordered matching of XML data. Third, by indexing on sequences of elements organized in a trie structure and using a sophisticated matching algorithm, XTrie is able to both reduce the number of unnecessary index probes as well as avoid redundant matchings, thereby providing extremely efficient filtering. Our experimental results over a wide range of XML document and XPath expression workloads demonstrate that our XTrie index structure outperforms earlier approaches by wide margins.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0078-5">An XML query engine for network-bound data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0078-5.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Zachary+G.+Ives%22">Zachary G. Ives</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.Y.+Halevy%22">A.Y. Halevy</a></li><li><a href="http://link.springer.com/search?facet-author=%22D.S.+Weld%22">D.S. Weld</a></li></ol>
          <input type="checkbox" id="68329"/>
          <label for="68329">Abstract</label>
          <div>XML has become the lingua franca for data exchange and integration across administrative and enterprise boundaries. Nearly all data providers are adding XML import or export capabilities, and standard XML Schemas and DTDs are being promoted for all types of data sharing. The ubiquity of XML has removed one of the major obstacles to integrating data from widely disparate sources - namely, the heterogeneity of data formats. However, general-purpose integration of data across the wide are a also requires a query processor that can query data sources on demand, receive streamed XML data from them, and combine and restructure the data into new XML output - while providing good performance for both batch-oriented and ad hoc, interactive queries. This is the goal of the Tukwila data integration system, the first system that focuses on network-bound, dynamic XML data sources. In contrast to previous approaches, which must read, parse, and often store entire XML objects before querying them, Tukwila can return query results even as the data is streaming into the system. Tukwila is built with a new system architecture that extends adaptive query processing and relational-engine techniques into the XML realm, as facilitated by a pair of operators that incrementally evaluate a query's input path expressions as data is read. In this paper, we describe the Tukwila architecture and its novel aspects, and we experimentally demonstrate that Tukwila provides better overall query performance and faster initial answers than existing systems, and has excellent scalability.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (November 2002)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0075-8">Editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0075-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+Apers%22">Peter Apers</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stefano+Ceri%22">Stefano Ceri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Richard+Snodgrass%22">Richard Snodgrass</a></li></ol>
          <input type="checkbox" id="28675"/>
          <label for="28675">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0073-x">Energy-performance trade-offs for spatial access methods on memory-resident data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0073-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ning+An%22">Ning An</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sudhanva+Gurumurthi%22">Sudhanva Gurumurthi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anand+Sivasubramaniam%22">Anand Sivasubramaniam</a></li><li><a href="http://link.springer.com/search?facet-author=%22Narayanan+Vijaykrishnan%22">Narayanan Vijaykrishnan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mahmut+Kandemir%22">Mahmut Kandemir</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mary+Jane+Irwin%22">Mary Jane Irwin</a></li></ol>
          <input type="checkbox" id="456"/>
          <label for="456">Abstract</label>
          <div>The proliferation of mobile and pervasive computing devices has brought energy constraints into the limelight. Energy-conscious design is important at all levels of system architecture, and the software has a key role to play in conserving battery energy on these devices. With the increasing popularity of spatial database applications, and their anticipated deployment on mobile devices (such as road atlases and GPS-based applications), it is critical to examine the energy implications of spatial data storage and access methods for memory resident datasets. While there has been extensive prior research on spatial access methods on resource-rich environments, this is, perhaps, the first study to examine their suitability for resource-constrained environments. Using a detailed cycle-accurate energy estimation framework and four different datasets, this paper examines the pros and cons of three previously proposed spatial indexing alternatives from both the energy and performance angles. Specifically, the Quadtree, Packed R-tree, and Buddy-Tree structures are evaluated and compared with a brute-force approach that does not use an index. The results show that there are both performance and energy trade-offs between the indexing schemes for the different queries. The nature of the query also plays an important role in determining the energy-performance trade-offs. Further, technological trends and architectural enhancements are influencing factors on the relative behavior of the index structures. The work in the query has a bearing on how and where (on a mobile client or/and on a server) it should be performed for performance and energy savings. The results from this study will be beneficial for the design and implementation of embedded spatial databases, accelerating their deployment on numerous mobile devices.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0074-9">Data page layouts for relational databases on deep memory hierarchies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0074-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Anastassia+Ailamaki%22">Anastassia Ailamaki</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+J.+DeWitt%22">David J. DeWitt</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mark+D.+Hill%22">Mark D. Hill</a></li></ol>
          <input type="checkbox" id="4373"/>
          <label for="4373">Abstract</label>
          <div>Relational database systems have traditionally optimized for I/O performance and organized records sequentially on disk pages using the N-ary Storage Model (NSM) (a.k.a., slotted pages). Recent research, however, indicates that cache utilization and performance is becoming increasingly important on modern platforms. In this paper, we first demonstrate that in-page data placement is the key to high cache performance and that NSM exhibits low cache utilization on modern platforms. Next, we propose a new data organization model called PAX (Partition Attributes Across), that significantly improves cache performance by grouping together all values of each attribute within each page. Because PAX only affects layout inside the pages, it incurs no storage penalty and does not affect I/O behavior. According to our experimental results (which were obtained without using any indices on the participating relations), when compared to NSM: (a) PAX exhibits superior cache and memory bandwidth utilization, saving at least 75% of NSM's stall time due to data cache accesses; (b) range selection queries and updates on memory-resident relations execute 17–25% faster; and (c) TPC-H queries involving I/O execute 11–48% faster. Finally, we show that PAX performs well across different memory system designs.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0070-0">A formal perspective on the view selection problem</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0070-0.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rada+Chirkova%22">Rada Chirkova</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Y.+Halevy%22">Alon Y. Halevy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Suciu%22">Dan Suciu</a></li></ol>
          <input type="checkbox" id="98732"/>
          <label for="98732">Abstract</label>
          <div>The view selection problem is to choose a set of views to materialize over a database schema, such that the cost of evaluating a set of workload queries is minimized and such that the views fit into a prespecified storage constraint. The two main applications of the view selection problem are materializing views in a database to speed up query processing, and selecting views to materialize in a data warehouse to answer decision support queries. In addition, view selection is a core problem for intelligent data placement over a wide-area network for data integration applications and data management for ubiquitous computing. We describe several fundamental results concerning the view selection problem. We consider the problem for views and workloads that consist of equality-selection, project and join queries, and show that the complexity of the problem depends crucially on the quality of the estimates that a query optimizer has on the size of the views it is considering to materialize. When a query optimizer has good estimates of the sizes of the views, we show a somewhat surprising result, namely, that an optimal choice of views may involve a number of views that is exponential in the size of the database schema. On the other hand, when an optimizer uses standard estimation heuristics, we show that the number of necessary views and the expression size of each view are polynomially bounded.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0065-x">Views in a large-scale XML repository</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0065-x.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vincent+Aguilera%22">Vincent Aguilera</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sophie+Cluet%22">Sophie Cluet</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tova+Milo%22">Tova Milo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pierangelo+Veltri%22">Pierangelo Veltri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Vodislav%22">Dan Vodislav</a></li></ol>
          <input type="checkbox" id="92133"/>
          <label for="92133">Abstract</label>
          <div>We are interested in defining and querying views in a huge and highly heterogeneous XML repository (Web scale). In this context, view definitions are very large, involving lots of sources, and there is no apparent limitation to their size. This raises interesting problems that we address in the paper: (i) how to distribute views over several machines without having a negative impact on the query translation process; (ii) how to quickly select the relevant part of a view given a query; (iii) how to minimize the cost of communicating potentially large queries to the machines where they will be evaluated. The solution that we propose is based on a simple view definition language that allows for automatic generation of views. The language maps paths in the view abstract DTD to paths in the concrete source DTDs. It enables a distributed implementation of the view system that is scalable both in terms of data and load. In particular, the query translation algorithm is shown to have a good (linear) complexity.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780200064">Database indexing for large DNA and protein sequence collections</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780200064.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ela+Hunt%22">Ela Hunt</a></li><li><a href="http://link.springer.com/search?facet-author=%22Malcolm+P.+Atkinson%22">Malcolm P. Atkinson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Robert+W.+Irving%22">Robert W. Irving</a></li></ol>
          <input type="checkbox" id="18424"/>
          <label for="18424">Abstract</label>
          <div>Our aim is to develop new database technologies for the approximate matching of unstructured string data using indexes. We explore the potential of the suffix tree data structure in this context. We present a new method of building suffix trees, allowing us to build trees in excess of RAM size, which has hitherto not been possible. We show that this method performs in practice as well as the O(n) method of Ukkonen [70]. Using this method we build indexes for 200 Mb of protein and 300 Mbp of DNA, whose disk-image exceeds the available RAM. We show experimentally that suffix trees can be effectively used in approximate string matching with biological data. For a range of query lengths and error bounds the suffix tree reduces the size of the unoptimised O(mn) dynamic programming calculation required in the evaluation of string similarity, and the gain from indexing increases with index size. In the indexes we built this reduction is significant, and less than 0.3% of the expected matrix is evaluated. We detail the requirements for further database and algorithmic research to support efficient use of large suffix indexes in biological applications.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (October 2002)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0066-9">Spatial indexing of high-dimensional data based on relative approximation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0066-9.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yasushi+Sakurai%22">Yasushi Sakurai</a></li><li><a href="http://link.springer.com/search?facet-author=%22Masatoshi+Yoshikawa%22">Masatoshi Yoshikawa</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shunsuke+Uemura%22">Shunsuke Uemura</a></li><li><a href="http://link.springer.com/search?facet-author=%22Haruhiko+Kojima%22">Haruhiko Kojima</a></li></ol>
          <input type="checkbox" id="20411"/>
          <label for="20411">Abstract</label>
          <div>We propose a novel index structure, the A-tree (approximation tree), for similarity searches in high-dimensional data. The basic idea of the A-tree is the introduction of virtual bounding rectangles (VBRs) which contain and approximate MBRs or data objects. VBRs can be represented quite compactly and thus affect the tree configuration both quantitatively and qualitatively. First, since tree nodes can contain a large number of VBR entries, fanout becomes large, which increases search speed. More importantly, we have a free hand in arranging MBRs and VBRs in the tree nodes. Each A-tree node contains an MBR and its children VBRs. Therefore, by fetching an A-tree node, we can obtain information on the exact position of a parent MBR and the approximate position of its children. We have performed experiments using both synthetic and real data sets. For the real data sets, the A-tree outperforms the SR-tree and the VA-file in all dimensionalities up to 64 dimensions, which is the highest dimension in our experiments. Additionally, we propose a cost model for the A-tree. We verify the validity of the cost model for synthetic and real data sets.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0067-8">Speeding up construction of PMR quadtree-based spatial indexes</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0067-8.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gisli+R.+Hjaltason%22">Gisli R. Hjaltason</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hanan+Samet%22">Hanan Samet</a></li></ol>
          <input type="checkbox" id="7537"/>
          <label for="7537">Abstract</label>
          <div>Spatial indexes, such as those based on the quadtree, are important in spatial databases for efficient execution of queries involving spatial constraints, especially when the queries involve spatial joins. In this paper we present a number of techniques for speeding up the construction of quadtree-based spatial indexes, specifically the PMR quadtree, which can index arbitrary spatial data. We assume a quadtree implementation using the “linear quadtree”, a disk-resident representation that stores objects contained in the leaf nodes of the quadtree in a linear index (e.g., a B-tree) ordered based on a space-filling curve. We present two complementary techniques: an improved insertion algorithm and a bulk-loading method. The bulk-loading method can be extended to handle bulk-insertions into an existing PMR quadtree. We make some analytical observations about the I/O cost and CPU cost of our PMR quadtree bulk-loading algorithm, and conduct an extensive empirical study of the techniques presented in the paper. Our techniques are found to yield significant speedup compared to traditional quadtree building methods, even when the size of a main memory buffer is very small compared to the size of the resulting quadtrees.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0068-7">Efficient similarity search for market basket data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0068-7.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alexandros+Nanopoulos%22">Alexandros Nanopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Manolopoulos%22">Yannis Manolopoulos</a></li></ol>
          <input type="checkbox" id="36090"/>
          <label for="36090">Abstract</label>
          <div>Several organizations have developed very large market basket databases for the maintenance of customer transactions. New applications, e.g., Web recommendation systems, present the requirement for processing similarity queries in market basket databases. In this paper, we propose a novel scheme for similarity search queries in basket data. We develop a new representation method, which, in contrast to existing approaches, is proven to provide correct results. New algorithms are proposed for the processing of similarity queries. Extensive experimental results, for a variety of factors, illustrate the superiority of the proposed scheme over the state-of-the-art method.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s00778-002-0069-6">A template model for multidimensional inter-transactional association rules</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs00778-002-0069-6.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ling+Feng%22">Ling Feng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+Xu+Yu%22">Jeffrey Xu Yu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hongjun+Lu%22">Hongjun Lu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiawei+Han%22">Jiawei Han</a></li></ol>
          <input type="checkbox" id="7236"/>
          <label for="7236">Abstract</label>
          <div>Multidimensional inter-transactional association rules extend the traditional association rules to describe more general associations among items with multiple properties across transactions. “After McDonald and Burger King open branches, KFC will open a branch two months later and one mile away” is an example of such rules. Since the number of potential inter-transactional association rules tends to be extremely large, mining inter-transactional associations poses more challenges on efficient processing than mining traditional intra-transactional associations. In order to make such association rule mining truly practical and computationally tractable, in this study we present a template model to help users declare the interesting multidimensional inter-transactional associations to be mined. With the guidance of templates, several optimization techniques, i.e., joining, converging, and speeding, are devised to speed up the discovery of inter-transactional association rules. We show, through a series of experiments on both synthetic and real-life data sets, that these optimization techniques can yield significant performance benefits.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (August 2002)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100058">Indexing of now-relative spatio-bitemporal data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100058.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Simonas+%C5%A0altenis%22">Simonas Šaltenis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li></ol>
          <input type="checkbox" id="26948"/>
          <label for="26948">Abstract</label>
          <div>Real-world entities are inherently spatially and temporally referenced, and database applications increasingly exploit databases that record the past, present, and anticipated future locations of entities, e.g., the residences of customers obtained by the geo-coding of addresses. Indices that efficiently support queries on the spatio-temporal extents of such entities are needed. However, past indexing research has progressed in largely separate spatial and temporal streams. Adding time dimensions to spatial indices, as if time were a spatial dimension, neither supports nor exploits the special properties of time. On the other hand, temporal indices are generally not amenable to extension with spatial dimensions. This paper proposes the first efficient and versatile index for a general class of spatio-temporal data: the discretely changing spatial aspect of an object may be a point or may have an extent; both transaction time and valid time are supported, and a generalized notion of the current time, now, is accommodated for both temporal dimensions. The index is based on the R $^*$ -tree and provides means of prioritizing space versus time, which enables it to adapt to spatially and temporally restrictive queries. Performance experiments are reported that evaluate pertinent aspects of the index.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100059">Efficient retrieval of similar shapes</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100059.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Davood+Rafiei%22">Davood Rafiei</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alberto+O.+Mendelzon%22">Alberto O. Mendelzon</a></li></ol>
          <input type="checkbox" id="6821"/>
          <label for="6821">Abstract</label>
          <div>We propose an indexing technique for the fast retrieval of objects in 2D images based on similarity between their boundary shapes. Our technique is robust in the presence of noise and supports several important notions of similarity including optimal matches irrespective of variations in orientation and/or position. Our method can also handle size-invariant matches using a normalization technique, although optimality is not guaranteed here. We implemented our method and performed experiments on real (hand-written digits) data. Our experimental results showed the superiority of our method compared to search based on sequential scanning, which is the only obvious competitor. The performance gain of our method increases with any increase in the number or the size of shapes.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780200060">Searching in metric spaces by spatial approximation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780200060.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gonzalo+Navarro%22">Gonzalo Navarro</a></li></ol>
          <input type="checkbox" id="88055"/>
          <label for="88055">Abstract</label>
          <div>We propose a new data structure to search in metric spaces. A metric space is formed by a collection of objects and a distance function defined among them which satisfies the triangle inequality. The goal is, given a set of objects and a query, retrieve those objects close enough to the query. The complexity measure is the number of distances computed to achieve this goal. Our data structure, called sa-tree (“spatial approximation tree”), is based on approaching the searched objects spatially, that is, getting closer and closer to them, rather than the classic divide-and-conquer approach of other data structures. We analyze our method and show that the number of distance evaluations to search among n objects is sublinear. We show experimentally that the sa-tree is the best existing technique when the metric space is hard to search or the query has low selectivity. These are the most important unsolved cases in real applications. As a practical advantage, our data structure is one of the few that does not need to tune parameters, which makes it appealing for use by non-experts.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780200061">Locating and accessing data repositories with WebSemantics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780200061.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22George+A.+Mihaila%22">George A. Mihaila</a></li><li><a href="http://link.springer.com/search?facet-author=%22Louiqa+Raschid%22">Louiqa Raschid</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anthony+Tomasic%22">Anthony Tomasic</a></li></ol>
          <input type="checkbox" id="32640"/>
          <label for="32640">Abstract</label>
          <div>Many collections of scientific data in particular disciplines are available today on the World Wide Web. Most of these data sources are compliant with some standard for interoperable access. In addition, sources may support a common semantics, i.e., a shared meaning for the data types and their domains. However, sharing data among a global community of users is still difficult because of the following reasons: (i) data providers need a mechanism for describing and publishing available sources of data; (ii) data administrators need a mechanism for discovering the location of published sources and obtaining metadata from these sources; and (iii) users need a mechanism for browsing and selecting sources. This paper describes a system, WebSemantics, that accomplishes the above tasks. We describe an architecture for the publication and discovery of scientific data sources, which is an extension of the World Wide Web architecture and protocols. We support catalogs containing metadata about data sources for some application domain. We define a language for discovering sources and querying their metadata. We then describe the WebSemantics prototype.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780200063">An authorization system for digital libraries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780200063.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22E.+Ferrari%22">E. Ferrari</a></li><li><a href="http://link.springer.com/search?facet-author=%22N.R.+Adam%22">N.R. Adam</a></li><li><a href="http://link.springer.com/search?facet-author=%22V.+Atluri%22">V. Atluri</a></li><li><a href="http://link.springer.com/search?facet-author=%22E.+Bertino%22">E. Bertino</a></li><li><a href="http://link.springer.com/search?facet-author=%22U.+Capuozzo%22">U. Capuozzo</a></li></ol>
          <input type="checkbox" id="12316"/>
          <label for="12316">Abstract</label>
          <div>Digital Libraries (DLs) introduce several challenging requirements with respect to the formulation, specification, and enforcement of adequate data protection policies. Unlike conventional database environments, a DL environment typically is characterized by a dynamic subject population, often making accesses from remote locations, and by an extraordinarily large amount of multimedia information, stored in a variety of formats. Moreover, in a DL environment, access policies are often specified based on subject qualifications and characteristics, rather than subject identity. Traditional authorization models are not adequate to meet access control requirements of DLs. In this paper, we present a Digital Library Authorization System (DLAS). DLAS employs a content-based authorization model, called a Digital Library Authorization Model (DLAM) which was proposed in previous work [1].</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780200062">Query processing techniques for arrays</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780200062.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Arunprasad+P.+Marathe%22">Arunprasad P. Marathe</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kenneth+Salem%22">Kenneth Salem</a></li></ol>
          <input type="checkbox" id="62564"/>
          <label for="62564">Abstract</label>
          <div>Arrays are a common and important class of data. At present, database systems do not provide adequate array support: arrays can neither be easily defined nor conveniently manipulated. Further, array manipulations are not optimized. This paper describes a language called the Array Manipulation Language (AML), for expressing array manipulations, and a collection of optimization techniques for AML expressions. In the AML framework for array manipulation, arbitrary externally-defined functions can be applied to arrays in a structured manner. AML can be adapted to different application domains by choosing appropriate external function definitions. This paper concentrates on arrays occurring in databases of digital images such as satellite or medical images. AML queries can be treated declaratively and subjected to rewrite optimizations. Rewriting minimizes the number of applications of potentially costly external functions required to compute a query result. AML queries can also be optimized for space. Query results are generated a piece at a time by pipelined execution plans, and the amount of memory required by a plan depends on the order in which pieces are generated. An optimizer can consider generating the pieces of the query result in a variety of orders, and can efficiently choose orders that require less space. An AML-based prototype array database system called ArrayDB has been built, and it is used to show the effectiveness of these optimization techniques.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 10 (August 2001 - December 2001)</h1>
          <ol><li>
          <h2>Issue 4 (December 2001)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100050">Semantic integrity support in SQL:1999 and commercial (object-)relational database management systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100050.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Can+T%C3%BCrker%22">Can Türker</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Gertz%22">Michael Gertz</a></li></ol>
          <input type="checkbox" id="9433"/>
          <label for="9433">Abstract</label>
          <div>The correctness of the data managed by database systems is vital to any application that utilizes data for business, research, and decision-making purposes. To guard databases against erroneous data not reflecting real-world data or business rules, semantic integrity constraints can be specified during database design. Current commercial database management systems provide various means to implement mechanisms to enforce semantic integrity constraints at database run-time. In this paper, we give an overview of the semantic integrity support in the most recent SQL-standard SQL:1999, and we show to what extent the different concepts and language constructs proposed in this standard can be found in major commercial (object-)relational database management systems. In addition, we discuss general design guidelines that point out how the semantic integrity features provided by these systems should be utilized in order to implement an effective integrity enforcing subsystem for a database.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100054">Answering queries using views: A survey</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100054.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alon+Y.+Halevy%22">Alon Y. Halevy</a></li></ol>
          <input type="checkbox" id="30393"/>
          <label for="30393">Abstract</label>
          <div>The problem of answering queries using views is to find efficient methods of answering a query using a set of previously defined materialized views over the database, rather than accessing the database relations. The problem has recently received significant attention because of its relevance to a wide variety of data management problems. In query optimization, finding a rewriting of a query using a set of materialized views can yield a more efficient query execution plan. To support the separation of the logical and physical views of data, a storage schema can be described using views over the logical schema. As a result, finding a query execution plan that accesses the storage amounts to solving the problem of answering queries using views. Finally, the problem arises in data integration systems, where data sources can be described as precomputed views over a mediated schema. This article surveys the state of the art on the problem of answering queries using views, and synthesizes the disparate works into a coherent framework. We describe the different applications of the problem, the algorithms proposed to solve it and the relevant theoretical results.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100055">Monotonic complements for independent data warehouses</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100055.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22D.+Laurent%22">D. Laurent</a></li><li><a href="http://link.springer.com/search?facet-author=%22J.+Lechtenb%C3%B6rger%22">J. Lechtenbörger</a></li><li><a href="http://link.springer.com/search?facet-author=%22N.+Spyratos%22">N. Spyratos</a></li><li><a href="http://link.springer.com/search?facet-author=%22G.+Vossen%22">G. Vossen</a></li></ol>
          <input type="checkbox" id="45985"/>
          <label for="45985">Abstract</label>
          <div>Views over databases have regained attention in the context of data warehouses, which are seen as materialized views. In this setting, efficient view maintenance is an important issue, for which the notion of self-maintainability has been identified as desirable. In this paper, we extend the concept of self-maintainability to (query and update) independence within a formal framework, where independence with respect to arbitrary given sets of queries and updates over the sources can be guaranteed. To this end we establish an intuitively appealing connection between warehouse independence and view complements. Moreover, we study special kinds of complements, namely monotonic complements, and show how to compute minimal ones in the presence of keys and foreign keys in the underlying databases. Taking advantage of these complements, an algorithmic approach is proposed for the specification of independent warehouses with respect to given sets of queries and updates.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100056">Global transaction support for workflow management systems: from formal specification to practical implementation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100056.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Paul+Grefen%22">Paul Grefen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jochem+Vonk%22">Jochem Vonk</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+Apers%22">Peter Apers</a></li></ol>
          <input type="checkbox" id="74412"/>
          <label for="74412">Abstract</label>
          <div>In this paper, we present an approach to global transaction management in workflow environments. The transaction mechanism is based on the well-known notion of compensation, but extended to deal with both arbitrary process structures to allow cycles in processes and safepoints to allow partial compensation of processes. We present a formal specification of the transaction model and transaction management algorithms in set and graph theory, providing clear, unambiguous transaction semantics. The specification is straightforwardly mapped to a modular architecture, the implementation of which is first applied in a testing environment, then in the prototype of a commercial workflow management system. The modular nature of the resulting system allows easy distribution using middleware technology. The path from abstract semantics specification to concrete, real-world implementation of a workflow transaction mechanism is thus covered in a complete and coherent fashion. As such, this paper provides a complete framework for the application of well-founded transactional workflows.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100057">A survey of approaches to automatic schema matching</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100057.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Erhard+Rahm%22">Erhard Rahm</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+A.+Bernstein%22">Philip A. Bernstein</a></li></ol>
          <input type="checkbox" id="43974"/>
          <label for="43974">Abstract</label>
          <div>Schema matching is a basic problem in many database application domains, such as data integration, E-business, data warehousing, and semantic query processing. In current implementations, schema matching is typically performed manually, which has significant limitations. On the other hand, previous research papers have proposed many techniques to achieve a partial automation of the match operation for specific application domains. We present a taxonomy that covers many of these existing approaches, and we describe the approaches in some detail. In particular, we distinguish between schema-level and instance-level, element-level and structure-level, and language-based and constraint-based matchers. Based on our classification we review some previous match implementations thereby indicating which part of the solution space they cover. We intend our taxonomy and review of past work to be useful when comparing different approaches to schema matching, when developing a new match algorithm, and when implementing a schema matching component.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2-3 (September 2001)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100053">Guest editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100053.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Amr+El+Abbadi%22">Amr El Abbadi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gunter+Schlageter%22">Gunter Schlageter</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyu-Young+Whang%22">Kyu-Young Whang</a></li></ol>
          <input type="checkbox" id="35879"/>
          <label for="35879">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100047">PicoDBMS: Scaling down database techniques for the smartcard</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100047.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Philippe+Pucheral%22">Philippe Pucheral</a></li><li><a href="http://link.springer.com/search?facet-author=%22Luc+Bouganim%22">Luc Bouganim</a></li><li><a href="http://link.springer.com/search?facet-author=%22Patrick+Valduriez%22">Patrick Valduriez</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christophe+Bobineau%22">Christophe Bobineau</a></li></ol>
          <input type="checkbox" id="99130"/>
          <label for="99130">Abstract</label>
          <div>Smartcards are the most secure portable computing device today. They have been used successfully in applications involving money, and proprietary and personal data (such as banking, healthcare, insurance, etc.). As smartcards get more powerful (with 32-bit CPU and more than 1 MB of stable memory in the next versions) and become multi-application, the need for database management arises. However, smartcards have severe hardware limitations (very slow write, very little RAM, constrained stable memory, no autonomy, etc.) which make traditional database technology irrelevant. The major problem is scaling down database techniques so they perform well under these limitations. In this paper, we give an in-depth analysis of this problem and propose a PicoDBMS solution based on highly compact data structures, query execution without RAM, and specific techniques for atomicity and durability. We show the effectiveness of our techniques through performance evaluation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100052">Efficiently publishing relational data as XML documents</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100052.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jayavel+Shanmugasundaram%22">Jayavel Shanmugasundaram</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eugene+Shekita%22">Eugene Shekita</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rimon+Barr%22">Rimon Barr</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Carey%22">Michael Carey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bruce+Lindsay%22">Bruce Lindsay</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hamid+Pirahesh%22">Hamid Pirahesh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Berthold+Reinwald%22">Berthold Reinwald</a></li></ol>
          <input type="checkbox" id="82083"/>
          <label for="82083">Abstract</label>
          <div>XML is rapidly emerging as a standard for exchanging business data on the World Wide Web. For the foreseeable future, however, most business data will continue to be stored in relational database systems. Consequently, if XML is to fulfill its potential, some mechanism is needed to publish relational data as XML documents. Towards that goal, one of the major challenges is finding a way to efficiently structure and tag data from one or more tables as a hierarchical XML document. Different alternatives are possible depending on when this processing takes place and how much of it is done inside the relational engine. In this paper, we characterize and study the performance of these alternatives. Among other things, we explore the use of new scalar and aggregate functions in SQL for constructing complex XML documents directly in the relational engine. We also explore different execution plans for generating the content of an XML document. The results of an experimental study show that constructing XML documents inside the relational engine can have a significant performance benefit. Our results also show the superiority of having the relational engine use what we call an “outer union plan” to generate the content of an XML document.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100042">Approximate query mapping: Accounting for translation closeness</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100042.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kevin+Chen-Chuan+Chang%22">Kevin Chen-Chuan Chang</a></li><li><a href="http://link.springer.com/search?facet-author=%22H%C3%A9ctor+Garc%C3%ADa-Molina%22">Héctor García-Molina</a></li></ol>
          <input type="checkbox" id="69586"/>
          <label for="69586">Abstract</label>
          <div>In this paper we present a mechanism for approximately translating Boolean query constraints across heterogeneous information sources. Achieving the best translation is challenging because sources support different constraints for formulating queries, and often these constraints cannot be precisely translated. For instance, a query [score>8] might be “perfectly” translated as [rating>0.8] at some site, but can only be approximated as [grade=A] at another. Unlike other work, our general framework adopts a customizable “closeness” metric for the translation that combines both precision and recall. Our results show that for query translation we need to handle interdependencies among both query conjuncts as well as disjuncts. As the basis, we identify the essential requirements of a rule system for users to encode the mappings for atomic semantic units. Our algorithm then translates complex queries by rewriting them in terms of the semantic units. We show that, under practical assumptions, our algorithm generates the best approximate translations with respect to the closeness metric of choice. We also present a case study to show how our technique may be applied in practice.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100048">MiniCon: A scalable algorithm for answering queries using views</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100048.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rachel+Pottinger%22">Rachel Pottinger</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Halevy%22">Alon Halevy</a></li></ol>
          <input type="checkbox" id="67952"/>
          <label for="67952">Abstract</label>
          <div>The problem of answering queries using views is to find efficient methods of answering a query using a set of previously materialized views over the database, rather than accessing the database relations. The problem has received significant attention because of its relevance to a wide variety of data management problems, such as data integration, query optimization, and the maintenance of physical data independence. To date, the performance of proposed algorithms has received very little attention, and in particular, their scale up in the presence of a large number of views is unknown. We first analyze two previous algorithms, the bucket algorithm and the inverse-rules, and show their deficiencies. We then describe the MiniCon, a novel algorithm for finding the maximally-contained rewriting of a conjunctive query using a set of conjunctive views. We present the first experimental study of algorithms for answering queries using views. The study shows that the MiniCon scales up well and significantly outperforms the previous algorithms. We describe an extension of the MiniCon to handle comparison predicates, and show its performance experimentally. Finally, we describe how the MiniCon can be extended to the context of query optimization.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100049">Approximate query processing using wavelets</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100049.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kaushik+Chakrabarti%22">Kaushik Chakrabarti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Minos+Garofalakis%22">Minos Garofalakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rajeev+Rastogi%22">Rajeev Rastogi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyuseok+Shim%22">Kyuseok Shim</a></li></ol>
          <input type="checkbox" id="87527"/>
          <label for="87527">Abstract</label>
          <div>Approximate query processing has emerged as a cost-effective approach for dealing with the huge data volumes and stringent response-time requirements of today's decision support systems (DSS). Most work in this area, however, has so far been limited in its query processing scope, typically focusing on specific forms of aggregate queries. Furthermore, conventional approaches based on sampling or histograms appear to be inherently limited when it comes to approximating the results of complex queries over high-dimensional DSS data sets. In this paper, we propose the use of multi-dimensional wavelets as an effective tool for general-purpose approximate query processing in modern, high-dimensional applications. Our approach is based on building wavelet-coefficient synopses of the data and using these synopses to provide approximate answers to queries. We develop novel query processing algorithms that operate directly on the wavelet-coefficient synopses of relational tables, allowing us to process arbitrarily complex queries entirely in the wavelet-coefficient domain. This guarantees extremely fast response times since our approximate query execution engine can do the bulk of its processing over compact sets of wavelet coefficients, essentially postponing the expansion into relational tuples until the end-result of the query. We also propose a novel wavelet decomposition algorithm that can build these synopses in an I/O-efficient manner. Finally, we conduct an extensive experimental study with synthetic as well as real-life data sets to determine the effectiveness of our wavelet-based approach compared to sampling and histograms. Our results demonstrate that our techniques: (1) provide approximate answers of better quality than either sampling or histograms; (2) offer query execution-time speedups of more than two orders of magnitude; and (3) guarantee extremely fast synopsis construction times that scale linearly with the size of the data.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100046">User-cognizant multidimensional analysis</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100046.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sunita+Sarawagi%22">Sunita Sarawagi</a></li></ol>
          <input type="checkbox" id="56897"/>
          <label for="56897">Abstract</label>
          <div>Our goal is to enhance multidimensional database systems with a suite of advanced operators to automate data analysis tasks that are currently handled through manual exploration. In this paper, we present a key component of our system that characterizes the information content of a cell based on a user's prior familiarity with the cube and provides a context-sensitive exploration of the cube. There are three main modules of this component. A Tracker, that continuously tracks the parts of the cube that a user has visited. A Modeler, that pieces together the information in the visited parts to model the user's expected values in the unvisited parts. An Informer, that processes user's queries about the most informative unvisited parts of the cube. The mathematical basis for the expected value modeling is provided by the classical maximum entropy principle. Accordingly, the expected values are computed so as to agree with every value that is already visited while reducing assumptions about unvisited values to the minimum by maximizing their entropy. The most informative values are defined as those that bring the new expected values closest to the actual values. We believe and prove through experiments that such a user-in-the-loop exploration will enable much faster assimilation of all significant information in the data compared to existing manual explorations.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (August 2001)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100041">Guest editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100041.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Fabio+Casati%22">Fabio Casati</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ming-Chien+Shan%22">Ming-Chien Shan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitrios+Georgakopoulos%22">Dimitrios Georgakopoulos</a></li></ol>
          <input type="checkbox" id="93502"/>
          <label for="93502">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100044">Designing wrapper components for e-services in integrating heterogeneous systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100044.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Massimo+Mecella%22">Massimo Mecella</a></li><li><a href="http://link.springer.com/search?facet-author=%22Barbara+Pernici%22">Barbara Pernici</a></li></ol>
          <input type="checkbox" id="82394"/>
          <label for="82394">Abstract</label>
          <div>Component-based approaches are becoming more and more popular to support Internet-based application development. Different component modeling approaches, however, can be adopted, obtaining different abstraction levels (either conceptual or operational). In this paper we present a component-based architecture for the design of e-applications, and discuss the concept of wrapper components as building blocks for the development of e-services, where these services are based on legacy systems. We discuss their characteristics and their applicability in Internet-based application development.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100045">Integrating and customizing heterogeneous e-commerce applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100045.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Anat+Eyal%22">Anat Eyal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tova+Milo%22">Tova Milo</a></li></ol>
          <input type="checkbox" id="10707"/>
          <label for="10707">Abstract</label>
          <div>A broad spectrum of electronic commerce applications is currently available on the Web, providing services in almost any area one can think of. As the number and variety of such applications grow, more business opportunities emerge for providing new services based on the integration and customization of existing applications. (Web shopping malls and support for comparative shopping are just a couple of examples.) Unfortunately, the diversity of applications in each specific domain and the disparity of interfaces, application flows, actor roles in the business transaction, and data formats, renders the integration and manipulation of applications a rather difficult task. In this paper we present the Application Manifold system, aimed at simplifying the intricate task of integration and customization of e-commerce applications. The scope of the work in this paper is limited to web-enabled e-commerce applications. We do not support the integration/customization of proprietary/legacy applications. The wrapping of such applications as web services is complementary to our work. Based on the emerging Web data standard, XML, and application modeling standard, UML, the system offers a novel declarative specification language for describing the integration/customization task, supporting a modular approach where new applications can be added and integrated at will with minimal effort. Then, acting as an application generator, the system generates a full integrated/customized e-commerce application, with the declarativity of the specification allowing for the optimization and verification of the generated application. The integration here deals with the full profile of the given e-commerce applications: the various services offered by the applications, the activities and roles of the different actors participating in the application (e.g., customers, vendors), the application flow, as well as with the data involved in the process. This is in contrast to previous works on Web data integration that focused primarily on querying the data available in the applications, mostly ignoring the additional aspects mentioned above.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100039">Active rules for XML: A new paradigm for E-services</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100039.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Angela+Bonifati%22">Angela Bonifati</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stefano+Ceri%22">Stefano Ceri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stefano+Paraboschi%22">Stefano Paraboschi</a></li></ol>
          <input type="checkbox" id="75740"/>
          <label for="75740">Abstract</label>
          <div>XML is rapidly becoming one of the most widely adopted technologies for information exchange and representation. As the use of XML becomes more widespread, we foresee the development of active XML rules, i.e., rules explicitly designed for the management of XML information. In particular, we argue that active rules for XML offer a natural paradigm for the rapid development of innovative e-services. In the paper, we show how active rules can be specified in the context of XSLT, a pattern-based language for publishing XML documents (promoted by the W3C) which is receiving strong commercial support, and Lorel, a query language for XML documents that is quite popular in the research world. We demonstrate, through simple examples of active rules for XSLT and Lorel, that active rules can be effective for the implementation of e-commerce services. We also discuss the various issues that need to be considered in adapting the notion of relational triggers to the XML context.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100043">ObjectGlobe: Ubiquitous query processing on the Internet</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100043.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22R.+Braumandl%22">R. Braumandl</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Keidl%22">M. Keidl</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Kemper%22">A. Kemper</a></li><li><a href="http://link.springer.com/search?facet-author=%22D.+Kossmann%22">D. Kossmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Kreutz%22">A. Kreutz</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Seltzsam%22">S. Seltzsam</a></li><li><a href="http://link.springer.com/search?facet-author=%22K.+Stocker%22">K. Stocker</a></li></ol>
          <input type="checkbox" id="35386"/>
          <label for="35386">Abstract</label>
          <div>We present the design of ObjectGlobe, a distributed and open query processor for Internet data sources. Today, data is published on the Internet via Web servers which have, if at all, very localized query processing capabilities. The goal of the ObjectGlobe project is to establish an open marketplace in which data and query processing capabilities can be distributed and used by any kind of Internet application. Furthermore, ObjectGlobe integrates cycle providers (i.e., machines) which carry out query processing operators. The overall picture is to make it possible to execute a query with – in principle – unrelated query operators, cycle providers, and data sources. Such an infrastructure can serve as enabling technology for scalable e-commerce applications, e.g., B2B and B2C market places, to be able to integrate data and data processing operations of a large number of participants. One of the main challenges in the design of such an open system is to ensure privacy and security. We discuss the ObjectGlobe security requirements, show how basic components such as the optimizer and runtime system need to be extended, and present the results of performance experiments that assess the additional cost for secure distributed query processing. Another challenge is quality of service management so that users can constrain the costs and running times of their queries.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100051">An Internet-based negotiation server for e-commerce</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100051.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Stanley+Y.W.+Su%22">Stanley Y.W. Su</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chunbo+Huang%22">Chunbo Huang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joachim+Hammer%22">Joachim Hammer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yihua+Huang%22">Yihua Huang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Haifei+Li%22">Haifei Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Liu+Wang%22">Liu Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Youzhong+Liu%22">Youzhong Liu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Charnyote+Pluempitiwiriyawej%22">Charnyote Pluempitiwiriyawej</a></li><li><a href="http://link.springer.com/search?facet-author=%22Minsoo+Lee%22">Minsoo Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Herman+Lam%22">Herman Lam</a></li></ol>
          <input type="checkbox" id="75498"/>
          <label for="75498">Abstract</label>
          <div>This paper describes the design and implementation of a replicable, Internet-based negotiation server for conducting bargaining-type negotiations between enterprises involved in e-commerce and e-business. Enterprises can be buyers and sellers of products/services or participants of a complex supply chain engaged in purchasing, planning, and scheduling. Multiple copies of our server can be installed to complement the services of Web servers. Each enterprise can install or select a trusted negotiation server to represent his/her interests. Web-based GUI tools are used during the build-time registration process to specify the requirements, constraints, and rules that represent negotiation policies and strategies, preference scoring of different data conditions, and aggregation methods for deriving a global cost-benefit score for the item(s) under negotiation. The registration information is used by the negotiation servers to automatically conduct bargaining type negotiations on behalf of their clients. In this paper, we present the architecture of our implementation as well as a framework for automated negotiations, and describe a number of communication primitives which are used in the underlying negotiation protocol. A constraint satisfaction processor (CSP) is used to evaluate a negotiation proposal or counterproposal against the registered requirements and constraints of a client company. In case of a constraint violation, an event is posted to trigger the execution of negotiation strategic rules, which either automatically relax the violated constraint, ask for human intervention, invoke an application, or perform other remedial operations. An Event-Trigger-Rule (ETR) server is used to manage events, triggers, and rules. Negotiation strategic rules can be added or modified at run-time. A cost-benefit analysis component is used to perform quantitative analysis of alternatives. The use of negotiation servers to conduct automated negotiation has been demonstrated in the context of an integrated supply chain scenario.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100038">XML-enabled workflow management for e-services across heterogeneous platforms</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100038.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22German+Shegalov%22">German Shegalov</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Gillmann%22">Michael Gillmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="30854"/>
          <label for="30854">Abstract</label>
          <div>Advanced e-services require efficient, flexible, and easy-to-use workflow technology that integrates well with mainstream Internet technologies such as XML and Web servers. This paper discusses an XML-enabled architecture for distributed workflow management that is implemented in the latest version of our Mentor-lite prototype system. The key asset of this architecture is an XML mediator that handles the exchange of business and flow control data between workflow and business-object servers on the one hand and client activities on the other via XML messages over http. Our implementation of the mediator has made use of Oracle's XSQL servlet. The major benefit of the advocated architecture is that it provides seamless integration of client applications into e-service workflows with scalable efficiency and very little explicit coding, in contrast to an earlier, Java-based, version of our Mentor-lite prototype that required much more code and exhibited potential performance problems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100037">An architecture to support scalable online personalization on the Web</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100037.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Anindya+Datta%22">Anindya Datta</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kaushik+Dutta%22">Kaushik Dutta</a></li><li><a href="http://link.springer.com/search?facet-author=%22Debra+VanderMeer%22">Debra VanderMeer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Krithi+Ramamritham%22">Krithi Ramamritham</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shamkant+B.+Navathe%22">Shamkant B. Navathe</a></li></ol>
          <input type="checkbox" id="85390"/>
          <label for="85390">Abstract</label>
          <div>Online personalization is of great interest to e-companies. Virtually all personalization technologies are based on the idea of storing as much historical customer session data as possible, and then querying the data store as customers navigate through a web site. The holy grail of online personalization is an environment where fine-grained, detailed historical session data can be queried based on current online navigation patterns for use in formulating real-time responses. Unfortunately, as more consumers become e-shoppers, the user load and the amount of historical data continue to increase, causing scalability-related problems for almost all current personalization technologies. This paper chronicles the development of a real-time interaction management system through the integration of historical data and online visitation patterns of e-commerce site visitors. It describes the scientific underpinnings of the system as well as its architecture. Experimental evaluation of the system shows that the caching and storage techniques built into the system deliver performance that is orders of magnitude better than those derived from off-the-shelf database components.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 9 (March 2000 - April 2001)</h1>
          <ol><li>
          <h2>Issue 4 (April 2001)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100028">Combining multi-visual features for efficient indexing in a large image database</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100028.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Anne+H.H.+Ngu%22">Anne H.H. Ngu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Quan+Z.+Sheng%22">Quan Z. Sheng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Du+Q.+Huynh%22">Du Q. Huynh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ron+Lei%22">Ron Lei</a></li></ol>
          <input type="checkbox" id="19467"/>
          <label for="19467">Abstract</label>
          <div>The optimized distance-based access methods currently available for multidimensional indexing in multimedia databases have been developed based on two major assumptions: a suitable distance function is known a priori and the dimensionality of the image features is low. It is not trivial to define a distance function that best mimics human visual perception regarding image similarity measurements. Reducing high-dimensional features in images using the popular principle component analysis (PCA) might not always be possible due to the non-linear correlations that may be present in the feature vectors. We propose in this paper a fast and robust hybrid method for non-linear dimensions reduction of composite image features for indexing in large image database. This method incorporates both the PCA and non-linear neural network techniques to reduce the dimensions of feature vectors so that an optimized access method can be applied. To incorporate human visual perception into our system, we also conducted experiments that involved a number of subjects classifying images into different classes for neural network training. We demonstrate that not only can our neural network system reduce the dimensions of the feature vectors, but that the reduced dimensional feature vectors can also be mapped to an optimized access method for fast and accurate indexing.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100033">HMAP– A temporal data model managing intervals with different granularities and indeterminacy from natural language sentences</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100033.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Carlo+Combi%22">Carlo Combi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Giuseppe+Pozzi%22">Giuseppe Pozzi</a></li></ol>
          <input type="checkbox" id="81021"/>
          <label for="81021">Abstract</label>
          <div>The granularity of given temporal information is the level of abstraction at which information is expressed. Different units of measure allow one to represent different granularities. Indeterminacy is often present in temporal information given at different granularities: temporal indeterminacy is related to incomplete knowledge of when the considered fact happened. Focusing on temporal databases, different granularities and indeterminacy have to be considered in expressing valid time, i.e., the time at which the information is true in the modeled reality. In this paper, we propose HMAP (The term is the transliteration of an ancient Greek poetical word meaning “day”.), a temporal data model extending the capability of defining valid times with different granularity and/or with indeterminacy. In HMAP, absolute intervals are explicitly represented by their start,end, and duration: in this way, we can represent valid times as “in December 1998 for five hours”, “from July 1995, for 15 days”, “from March 1997 to October 15, 1997, between 6 and 6:30 p.m.”. HMAP is based on a three-valued logic, for managing uncertainty in temporal relationships. Formulas involving different temporal relationships between intervals, instants, and durations can be defined, allowing one to query the database with different granularities, not necessarily related to that of data. In this paper, we also discuss the complexity of algorithms, allowing us to evaluate HMAP formulas, and show that the formulas can be expressed as constraint networks falling into the class of simple temporal problems, which can be solved in polynomial time.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100040">Supporting efficient multimedia database exploration</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100040.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wen-Syan+Li%22">Wen-Syan Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22K.Sel%C3%A7uk+Candan%22">K.Selçuk Candan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyoji+Hirata%22">Kyoji Hirata</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yoshinori+Hara%22">Yoshinori Hara</a></li></ol>
          <input type="checkbox" id="34359"/>
          <label for="34359">Abstract</label>
          <div>Due to the fuzziness of query specification and media matching, multimedia retrieval is conducted by way of exploration. It is essential to provide feedback so that users can visualize query reformulation alternatives and database content distribution. Since media matching is an expensive task, another issue is how to efficiently support exploration so that the system is not overloaded by perpetual query reformulation. In this paper, we present a uniform framework to represent statistical information of both semantics and visual metadata for images in the databases. We propose the concept of query verification, which evaluates queries using statistics, and provides users with feedback, including the strictness and reformulation alternatives of each query condition as well as estimated numbers of matches. With query verification, the system increases the efficiency of the multimedia database exploration for both users and the system. Such statistical information is also utilized to support progressive query processing and query relaxation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100035">A graph-theoretic model for optimizing queries involving methods</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100035.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chiang+Lee%22">Chiang Lee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chi-Sheng+Shih%22">Chi-Sheng Shih</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yaw-Huei+Chen%22">Yaw-Huei Chen</a></li></ol>
          <input type="checkbox" id="78949"/>
          <label for="78949">Abstract</label>
          <div>Traditional algorithms for optimizing the execution order of joins are no more valid when selections and projections involve methods and become very expensive operations. Selections and projections could be even more costly than joins such that they are pulled above joins, rather than pushed down in a query tree. In this paper, we take a fundamental look at how to approach query optimization from a top-down design perspective, rather than trying to force one model to fit into another. We present a graph model which is designed to characterize execution plans. Each edge and each vertex of the graph is assigned a weight to model execution plans. We also design algorithms that use these weights to optimize the execution order of operations. A cost model of these algorithms is developed. Experiments are conducted on the basis of this cost model. The results show that our algorithms are superior to similar work proposed in the literature.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780100036">Indexing very high-dimensional sparse and quasi-sparse vectors for similarity searches</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780100036.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Changzhou+Wang%22">Changzhou Wang</a></li><li><a href="http://link.springer.com/search?facet-author=%22X.+Sean+Wang%22">X. Sean Wang</a></li></ol>
          <input type="checkbox" id="37608"/>
          <label for="37608">Abstract</label>
          <div>Similarity queries on complex objects are usually translated into searches among their feature vectors. This paper studies indexing techniques for very high-dimensional (e.g., in hundreds) vectors that are sparse or quasi-sparse, i.e., vectors each having only a small number (e.g., ten) of non-zero or significant values. Based on the R-tree, the paper introduces the xS-tree that uses lossy compression of bounding regions to guarantee a reasonable minimum fan-out within the allocated storage space for each node. In addition, the paper studies the performance and scalability of the xS-tree via experiments.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (December 2000)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780000034">Guest editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780000034.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Malcolm+P.+Atkinson%22">Malcolm P. Atkinson</a></li></ol>
          <input type="checkbox" id="97697"/>
          <label for="97697">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780000027">Context-based prefetch – an optimization for implementing objects on relations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780000027.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Philip+A.+Bernstein%22">Philip A. Bernstein</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shankar+Pal%22">Shankar Pal</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Shutt%22">David Shutt</a></li></ol>
          <input type="checkbox" id="89567"/>
          <label for="89567">Abstract</label>
          <div>When implementing persistent objects on a relational database, a major performance issue is prefetching data to minimize the number of round-trips to the database. This is especially hard with navigational applications, since future accesses are unpredictable. We propose the use of the context in which an object is loaded as a predictor of future accesses, where a context can be a stored collection of relationships, a query result, or a complex object. When an object O's state is loaded, similar state for other objects in O's context is prefetched. We present a design for maintaining context and for using it to guide prefetch. We give performance measurements of its implementation in Microsoft Repository, showing up to a 70% reduction in running time. We describe several variations of the optimization: selectively applying the technique based on application and database characteristics, using application-supplied performance hints, using concurrent database queries to support asynchronous prefetch, prefetching across relationship paths, and delayed prefetch to save database round-trips.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780000030">Exploiting early sorting and early partitioning for decision support query processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780000030.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22J.+Claussen%22">J. Claussen</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Kemper%22">A. Kemper</a></li><li><a href="http://link.springer.com/search?facet-author=%22D.+Kossmann%22">D. Kossmann</a></li><li><a href="http://link.springer.com/search?facet-author=%22C.+Wiesner%22">C. Wiesner</a></li></ol>
          <input type="checkbox" id="94695"/>
          <label for="94695">Abstract</label>
          <div>Decision support queries typically involve several joins, a grouping with aggregation, and/or sorting of the result tuples. We propose two new classes of query evaluation algorithms that can be used to speed up the execution of such queries. The algorithms are based on (1) early sorting and (2) early partitioning– or a combination of both. The idea is to push the sorting and/or the partitioning to the leaves, i.e., the base relations, of the query evaluation plans (QEPs) and thereby avoid sorting or partitioning large intermediate results generated by the joins. Both early sorting and early partitioning are used in combination with hash-based algorithms for evaluating the join(s) and the grouping. To enable early sorting, the sort order generated at an early stage of the QEP is retained through an arbitrary number of so-called order-preserving hash joins. To make early partitioning applicable to a large class of decision support queries, we generalize the so-called hash teams proposed by Graefe et al. [GBC98]. Hash teams allow to perform several hash-based operations (join and grouping) on the same attribute in one pass without repartitioning intermediate results. Our generalization consists of indirectly partitioning the input data. Indirect partitioning means partitioning the input data on an attribute that is not directly needed for the next hash-based operation, and it involves the construction of bitmaps to approximate the partitioning for the attribute that is needed in the next hash-based operation. Our performance experiments show that such QEPs based on early sorting, early partitioning, or both in combination perform significantly better than conventional strategies for many common classes of decision support queries.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780000029">One-dimensional and multi-dimensional substring selectivity estimation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780000029.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22H.V.+Jagadish%22">H.V. Jagadish</a></li><li><a href="http://link.springer.com/search?facet-author=%22Olga+Kapitskaia%22">Olga Kapitskaia</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raymond+T.+Ng%22">Raymond T. Ng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Divesh+Srivastava%22">Divesh Srivastava</a></li></ol>
          <input type="checkbox" id="58046"/>
          <label for="58046">Abstract</label>
          <div>With the increasing importance of XML, LDAP directories, and text-based information sources on the Internet, there is an ever-greater need to evaluate queries involving (sub)string matching. In many cases, matches need to be on multiple attributes/dimensions, with correlations between the multiple dimensions. Effective query optimization in this context requires good selectivity estimates. In this paper, we use pruned count-suffix trees (PSTs) as the basic data structure for substring selectivity estimation. For the 1-D problem, we present a novel technique called MO (Maximal Overlap). We then develop and analyze two 1-D estimation algorithms, MOC and MOLC, based on MO and a constraint-based characterization of all possible completions of a given PST. For the k-D problem, we first generalize PSTs to multiple dimensions and develop a space- and time-efficient probabilistic algorithm to construct k-D PSTs directly. We then show how to extend MO to multiple dimensions. Finally, we demonstrate, both analytically and experimentally, that MO is both practical and substantially superior to competing algorithms.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780000031">Optimizing database architecture for the new bottleneck: memory access</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780000031.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Stefan+Manegold%22">Stefan Manegold</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+A.+Boncz%22">Peter A. Boncz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Martin+L.+Kersten%22">Martin L. Kersten</a></li></ol>
          <input type="checkbox" id="66546"/>
          <label for="66546">Abstract</label>
          <div>In the past decade, advances in the speed of commodity CPUs have far out-paced advances in memory latency. Main-memory access is therefore increasingly a performance bottleneck for many computer applications, including database systems. In this article, we use a simple scan test to show the severe impact of this bottleneck. The insights gained are translated into guidelines for database architecture, in terms of both data structures and algorithms. We discuss how vertically fragmented data structures optimize cache performance on sequential data access. We then focus on equi-join, typically a random-access operation, and introduce radix algorithms for partitioned hash-join. The performance of these algorithms is quantified using a detailed analytical model that incorporates memory access cost. Experiments that validate this model were performed on the Monet database system. We obtained exact statistics on events such as TLB misses and L1 and L2 cache misses by using hardware performance counters found in modern CPUs. Using our cost model, we show how the carefully tuned memory access pattern of our radix algorithms makes them perform well, which is confirmed by experimental results.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780000032">Online dynamic reordering</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780000032.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vijayshankar+Raman%22">Vijayshankar Raman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bhaskaran+Raman%22">Bhaskaran Raman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joseph+M.+Hellerstein%22">Joseph M. Hellerstein</a></li></ol>
          <input type="checkbox" id="95560"/>
          <label for="95560">Abstract</label>
          <div>We present a pipelining, dynamically tunable reorder operator for providing user control during long running, data- intensive operations. Users can see partial results and accordingly direct the processing by specifying preferences for various data items; data of interest is prioritized for early processing. The reordering mechanism is efficient and non-blocking and can be used over arbitrary data streams from files and indexes, as well as continuous data feeds. We also investigate several policies for the reordering based on the performance goals of various typical applications. We present performance results for reordering in the context of an online aggregation implementation in Informix and in the context of sorting and scrolling in a large-scale spreadsheet. Our experiments demonstrate that for a variety of data distributions and applications, reordering is responsive to dynamic preference changes, imposes minimal overheads in overall completion time, and provides dramatic improvements in the quality of the feedback over time. Surprisingly, preliminary experiments indicate that online reordering can also be useful in traditional batch query processing, because it can serve as a form of pipelined, approximate sorting.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780000026">Progressive evaluation of nested aggregate queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780000026.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Cheng+Hian+Goh%22">Cheng Hian Goh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li></ol>
          <input type="checkbox" id="29119"/>
          <label for="29119">Abstract</label>
          <div>In many decision-making scenarios, decision makers require rapid feedback to their queries, which typically involve aggregates. The traditional blocking execution model can no longer meet the demands of these users. One promising approach in the literature, called online aggregation, evaluates an aggregation query progressively as follows: as soon as certain data have been evaluated, approximate answers are produced with their respective running confidence intervals; as more data are examined, the answers and their corresponding running confidence intervals are refined. In this paper, we extend this approach to handle nested queries with aggregates (i.e., at least one inner query block is an aggregate query) by providing users with (approximate) answers progressively as the inner aggregation query blocks are evaluated. We address the new issues pose by nested queries. In particular, the answer space begins with a superset of the final answers and is refined as the aggregates from the inner query blocks are refined. For the intermediary answers to be meaningful, they have to be interpreted with the aggregates from the inner queries. We also propose a multi-threaded model in evaluating such queries: each query block is assigned to a thread, and the threads can be evaluated concurrently and independently. The time slice across the threads is nondeterministic in the sense that the user controls the relative rate at which these subqueries are being evaluated. For enumerative nested queries, we propose a priority-based evaluation strategy to present answers that are certainly in the final answer space first, before presenting those whose validity may be affected as the inner query aggregates are refined. We implemented a prototype system using Java and evaluated our system. Results for nested queries with a level and multiple levels of nesting are reported. Our results show the effectiveness of the proposed mechanisms in providing progressive feedback that reduces the initial waiting time of users significantly without sacrificing the quality of the answers.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (July 2000)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/PL00010674">Checking the temporal integrity of interactive multimedia documents</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FPL00010674.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22I.+Mirbel%22">I. Mirbel</a></li><li><a href="http://link.springer.com/search?facet-author=%22B.+Pernici%22">B. Pernici</a></li><li><a href="http://link.springer.com/search?facet-author=%22T.+Sellis%22">T. Sellis</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Tserkezoglou%22">S. Tserkezoglou</a></li><li><a href="http://link.springer.com/search?facet-author=%22M.+Vazirgiannis%22">M. Vazirgiannis</a></li></ol>
          <input type="checkbox" id="99188"/>
          <label for="99188">Abstract</label>
          <div>Abstract. When authoring multimedia scenarios, and in particular scenarios with user interaction, where the sequence and time of occurrence of interactions is not predefined, it is difficult to guarantee the consistency of the resulting scenarios. As a consequence, the execution of the scenario may result in unexpected behavior or inconsistent use of media. The present paper proposes a methodology for checking the temporal integrity of interactive multimedia document (IMD) scenarios at authoring time at various levels. The IMD flow is mainly defined by the events occurring during the IMD session. Integrity checking consists of a set of discrete steps, during which we transform the scenario into temporal constraint networks representing the constraints linking the different possible events in the scenario. Temporal constraint verification techniques are applied to verify the integrity of the scenario, deriving a minimal network, showing possible temporal relationships between events given a set of constraints.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/PL00010673">View management in multimedia databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FPL00010673.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22K.+Sel%C3%A7uk+Candan%22">K. Selçuk Candan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eric+Lemar%22">Eric Lemar</a></li><li><a href="http://link.springer.com/search?facet-author=%22V.S.+Subrahmanian%22">V.S. Subrahmanian</a></li></ol>
          <input type="checkbox" id="83981"/>
          <label for="83981">Abstract</label>
          <div>Abstract. Though there has been extensive work on multimedia databases in the last few years, there is no prevailing notion of a multimedia view, nor there are techniques to create, manage, and maintain such views. Visualizing the results of a dynamic multimedia query or materializing a dynamic multimedia view corresponds to assembling and delivering an interactive multimedia presentation in accordance with the visualization specifications. In this paper, we suggest that a non-interactive multimedia presentation is a set of virtual objects with associated spatial and temporal presentation constraints. A virtual object is either an object, or the result of a query. As queries may have different answers at different points in time, scheduling the presentation of such objects is nontrivial. We then develop a probabilistic model of interactive multimedia presentations, extending the non-interactive model described earlier. We also develop a probabilistic model of interactive visualization where the probabilities reflect the user profiles, or the likelihood of certain user interactions. Based on this probabilistic model, we develop three utility-theoretic based types of prefetching algorithms that anticipate how users will interact with the presentation. These prefetching algorithms allow efficient visualization of the query results in accordance with the underlying specification. We have built a prototype system that incorporates these algorithms. We report on the results of experiments conducted on top of this implementation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/PL00010672">Dynamic vp-tree indexing for n-nearest neighbor search given pair-wise distances</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FPL00010672.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ada+Wai-chee+Fu%22">Ada Wai-chee Fu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Polly+Mei-shuen+Chan%22">Polly Mei-shuen Chan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yin-Ling+Cheung%22">Yin-Ling Cheung</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yiu+Sang+Moon%22">Yiu Sang Moon</a></li></ol>
          <input type="checkbox" id="8101"/>
          <label for="8101">Abstract</label>
          <div>Abstract. For some multimedia applications, it has been found that domain objects cannot be represented as feature vectors in a multidimensional space. Instead, pair-wise distances between data objects are the only input. To support content-based retrieval, one approach maps each object to a k-dimensional (k-d) point and tries to preserve the distances among the points. Then, existing spatial access index methods such as the R-trees and KD-trees can support fast searching on the resulting k-d points. However, information loss is inevitable with such an approach since the distances between data objects can only be preserved to a certain extent. Here we investigate the use of a distance-based indexing method. In particular, we apply the vantage point tree (vp-tree) method. There are two important problems for the vp-tree method that warrant further investigation, the n-nearest neighbors search and the updating mechanisms. We study an n-nearest neighbors search algorithm for the vp-tree, which is shown by experiments to scale up well with the size of the dataset and the desired number of nearest neighbors, n. Experiments also show that the searching in the vp-tree is more efficient than that for the $R^*$ -tree and the M-tree. Next, we propose solutions for the update problem for the vp-tree, and show by experiments that the algorithms are efficient and effective. Finally, we investigate the problem of selecting vantage-point, propose a few alternative methods, and study their impact on the number of distance computation.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (March 2000)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050079">Guest editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050079.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Paolo+Atzeni%22">Paolo Atzeni</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alberto+O.+Mendelzon%22">Alberto O. Mendelzon</a></li></ol>
          <input type="checkbox" id="86824"/>
          <label for="86824">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050080">Semantic caching of Web queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050080.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Boris+Chidlovskii%22">Boris Chidlovskii</a></li><li><a href="http://link.springer.com/search?facet-author=%22Uwe+M.+Borghoff%22">Uwe M. Borghoff</a></li></ol>
          <input type="checkbox" id="51177"/>
          <label for="51177">Abstract</label>
          <div>Abstract. In meta-searchers accessing distributed Web-based information repositories, performance is a major issue. Efficient query processing requires an appropriate caching mechanism. Unfortunately, standard page-based as well as tuple-based caching mechanisms designed for conventional databases are not efficient on the Web, where keyword-based querying is often the only way to retrieve data. In this work, we study the problem of semantic caching of Web queries and develop a caching mechanism for conjunctive Web queries based on signature files. Our algorithms cope with both relations of semantic containment and intersection between a query and the corresponding cache items. We also develop the cache replacement strategy to treat situations when cached items differ in size and contribution when providing partial query answers. We report results of experiments and show how the caching mechanism is realized in the Knowledge Broker system.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050081">Learning response time for WebSources using query feedback and application in query optimization</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050081.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jean-Robert+Gruser%22">Jean-Robert Gruser</a></li><li><a href="http://link.springer.com/search?facet-author=%22Louiqa+Raschid%22">Louiqa Raschid</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vladimir+Zadorozhny%22">Vladimir Zadorozhny</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tao+Zhan%22">Tao Zhan</a></li></ol>
          <input type="checkbox" id="94930"/>
          <label for="94930">Abstract</label>
          <div>Abstract. The rapid growth of the Internet and support for interoperability protocols has increased the number of Web accessible sources, WebSources. Current wrapper mediator architectures need to be extended with a wrapper cost model (WCM) for WebSources that can estimate the response time (delays) to access sources as well as other relevant statistics. In this paper, we present a Web prediction tool (WebPT), a tool that is based on learning using query feedback from WebSources. The WebPT uses dimensions time of day, day, and quantity of data, to learn response times from a particular WebSource, and to predict the expected response time (delay) for some query. Experiment data was collected from several sources, and those dimensions that were significant in estimating the response time were determined. We then trained the WebPT on the collected data, to use the three dimensions mentioned above, and to predict the response time, as well as a confidence in the prediction. We describe the WebPT learning algorithms, and report on the WebPT learning for WebSources. Our research shows that we can improve the quality of learning by tuning the WebPT features, e.g., training the WebPT using a logarithm of the input training data; including significant dimensions in the WebPT; or changing the ordering of dimensions. A comparison of the WebPT with more traditional neural network (NN) learning has been performed, and we briefly report on the comparison. We then demonstrate how the WebPT prediction of delay may be used by a scrambling enabled optimizer. A scrambling algorithm identifies some critical points of delay, where it makes a decision to scramble (modify) a plan, to attempt to hide the expected delay by computing some other part of the plan that is unaffected by the delay. We explore the space of real delay at a WebSource, versus the WebPT prediction of this delay, with respect to critical points of delay in specific plans. We identify those cases where WebPT overestimation or underestimation of the real delay results in a penalty in the scrambling enabled optimizer, and those cases where there is no penalty. Using the experimental data and WebPT learning, we test how good the WebPT is in minimizing these penalties.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050082">Declarative specification of Web sites with Strudel</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050082.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mary+Fern%C3%A1ndez%22">Mary Fernández</a></li><li><a href="http://link.springer.com/search?facet-author=%22Daniela+Florescu%22">Daniela Florescu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alon+Levy%22">Alon Levy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Suciu%22">Dan Suciu</a></li></ol>
          <input type="checkbox" id="36603"/>
          <label for="36603">Abstract</label>
          <div>Abstract. Strudel is a system for implementing data-intensive Web sites, which typically integrate information from multiple data sources and have complex structure. Strudel's key idea is separating the management of a Web site's data, the specification of its content and structure, and the visual representation of its pages. Strudel provides a declarative query language for specifying a site's content and structure, and a simple template language for specifying a site's HTML representation. This paper contains a comprehensive description of the Strudel system and details the benefits of declarative site specification. We describe our experiences using Strudel in a production application and describe three different, but complementary, systems that extend and improve upon Strudel's original ideas.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050083">Analysis of navigation behaviour in web sites integrating multiple information systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050083.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bettina+Berendt%22">Bettina Berendt</a></li><li><a href="http://link.springer.com/search?facet-author=%22Myra+Spiliopoulou%22">Myra Spiliopoulou</a></li></ol>
          <input type="checkbox" id="91989"/>
          <label for="91989">Abstract</label>
          <div>Abstract. The analysis of web usage has mostly focused on sites composed of conventional static pages. However, huge amounts of information available in the web come from databases or other data collections and are presented to the users in the form of dynamically generated pages. The query interfaces of such sites allow the specification of many search criteria. Their generated results support navigation to pages of results combining cross-linked data from many sources. For the analysis of visitor navigation behaviour in such web sites, we propose the web usage miner (WUM), which discovers navigation patterns subject to advanced statistical and structural constraints. Since our objective is the discovery of interesting navigation patterns, we do not focus on accesses to individual pages. Instead, we construct conceptual hierarchies that reflect the query capabilities used in the production of those pages. Our experiments with a real web site that integrates data from multiple databases, the German SchulWeb, demonstrate the appropriateness of WUM in discovering navigation patterns and show how those discoveries can help in assessing and improving the quality of the site.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050084">UnQL: a query language and algebra for semistructured data based on structural recursion</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050084.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+Buneman%22">Peter Buneman</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mary+Fernandez%22">Mary Fernandez</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dan+Suciu%22">Dan Suciu</a></li></ol>
          <input type="checkbox" id="40504"/>
          <label for="40504">Abstract</label>
          <div>Abstract. This paper presents structural recursion as the basis of the syntax and semantics of query languages for semistructured data and XML. We describe a simple and powerful query language based on pattern matching and show that it can be expressed using structural recursion, which is introduced as a top-down, recursive function, similar to the way XSL is defined on XML trees. On cyclic data, structural recursion can be defined in two equivalent ways: as a recursive function which evaluates the data top-down and remembers all its calls to avoid infinite loops, or as a bulk evaluation which processes the entire data in parallel using only traditional relational algebra operators. The latter makes it possible for optimization techniques in relational queries to be applied to structural recursion. We show that the composition of two structural recursion queries can be expressed as a single such query, and this is used as the basis of an optimization method for mediator systems. Several other formal properties are established: structural recursion can be expressed in first-order logic extended with transitive closure; its data complexity is PTIME; and over relational data it is a conservative extension of the relational calculus. The underlying data model is based on value equality, formally defined with bisimulation. Structural recursion is shown to be invariant with respect to value equality.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 8 (April 1999 - February 2000)</h1>
          <ol><li>
          <h2>Issue 3-4 (February 2000)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050001">Foreword by the VLDB '98 PC Chairmen</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050001.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22O.+Shmueli%22">O. Shmueli</a></li><li><a href="http://link.springer.com/search?facet-author=%22J.+Widom%22">J. Widom</a></li></ol>
          <input type="checkbox" id="25787"/>
          <label for="25787">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050002">Functional-join processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050002.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22R.+Braumandl%22">R. Braumandl</a></li><li><a href="http://link.springer.com/search?facet-author=%22J.+Claussen%22">J. Claussen</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Kemper%22">A. Kemper</a></li><li><a href="http://link.springer.com/search?facet-author=%22D.+Kossmann%22">D. Kossmann</a></li></ol>
          <input type="checkbox" id="86845"/>
          <label for="86845">Abstract</label>
          <div>Inter-object references are one of the key concepts of object-relational and object-oriented database systems. In this work, we investigate alternative techniques to implement inter-object references and make the best use of them in query processing, i.e., in evaluating functional joins. We will give a comprehensive overview and performance evaluation of all known techniques for simple (single-valued) as well as multi-valued functional joins. Furthermore, we will describe special order-preserving\/ functional-join techniques that are particularly attractive for decision support queries that require ordered results. While most of the presentation of this paper is focused on object-relational and object-oriented database systems, some of the results can also be applied to plain relational databases because index nested-loop joins\/ along key/foreign-key relationships, as they are frequently found in relational databases, are just one particular way to execute a functional join.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050003">Secure buffering in firm real-time database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050003.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Binto+George%22">Binto George</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jayant+R.+Haritsa%22">Jayant R. Haritsa</a></li></ol>
          <input type="checkbox" id="99739"/>
          <label for="99739">Abstract</label>
          <div>Many real-time database applications arise in electronic financial services, safety-critical installations and military systems where enforcing security is crucial to the success of the enterprise. We investigate here the performance implications, in terms of killed transactions, of guaranteeing multi-level secrecy in a real-time database system supporting applications with firm deadlines. In particular, we focus on the buffer management aspects of this issue. Our main contributions are the following. First, we identify the importance and difficulties of providing secure buffer management in the real-time database environment. Second, we present SABRE, a novel buffer management algorithm that provides covert-channel-free security. SABRE employs a fully dynamic one-copy allocation policy for efficient usage of buffer resources. It also incorporates several optimizations for reducing the overall number of killed transactions and for decreasing the unfairness in the distribution of killed transactions across security levels. Third, using a detailed simulation model, the real-time performance of SABRE is evaluated against unsecure conventional and real-time buffer management policies for a variety of security-classified transaction workloads and system configurations. Our experiments show that SABRE provides security with only a modest drop in real-time performance. Finally, we evaluate SABRE's performance when augmented with the GUARD adaptive admission control policy. Our experiments show that this combination provides close to ideal fairness for real-time applications that can tolerate covert-channel bandwidths of up to one bit per second (a limit specified in military standards).</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050004">The LHAM log-structured history data access method</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050004.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+Muth%22">Peter Muth</a></li><li><a href="http://link.springer.com/search?facet-author=%22Patrick+O%27Neil%22">Patrick O'Neil</a></li><li><a href="http://link.springer.com/search?facet-author=%22Achim+Pick%22">Achim Pick</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="45534"/>
          <label for="45534">Abstract</label>
          <div>Numerous applications such as stock market or medical information systems require that both historical and current data be logically integrated into a temporal database. The underlying access method must support different forms of “time-travel” queries, the migration of old record versions onto inexpensive archive media, and high insertion and update rates. This paper presents an access method for transaction-time temporal data, called the log-structured history data access method (LHAM) that meets these demands. The basic principle of LHAM is to partition the data into successive components based on the timestamps of the record versions. Components are assigned to different levels of a storage hierarchy, and incoming data is continuously migrated through the hierarchy. The paper discusses the LHAM concepts, including concurrency control and recovery, our full-fledged LHAM implementation, and experimental performance results based on this implementation. A detailed comparison with the TSB-tree, both analytically and based on experiments with real implementations, shows that LHAM is highly superior in terms of insert performance, while query performance is in almost all cases at least as good as for the TSB-tree; in many cases it is much better.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050005">Clustering categorical data: an approach based on dynamical systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050005.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22David+Gibson%22">David Gibson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jon+Kleinberg%22">Jon Kleinberg</a></li><li><a href="http://link.springer.com/search?facet-author=%22Prabhakar+Raghavan%22">Prabhakar Raghavan</a></li></ol>
          <input type="checkbox" id="6227"/>
          <label for="6227">Abstract</label>
          <div>We describe a novel approach for clustering collections of sets, and its application to the analysis and mining of categorical data. By “categorical data,” we mean tables with fields that cannot be naturally ordered by a metric – e.g., the names of producers of automobiles, or the names of products offered by a manufacturer. Our approach is based on an iterative method for assigning and propagating weights on the categorical values in a table; this facilitates a type of similarity measure arising from the co-occurrence of values in the dataset. Our techniques can be studied analytically in terms of certain types of non-linear dynamical systems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050006">Distance-based outliers: algorithms and applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050006.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Edwin+M.+Knorr%22">Edwin M. Knorr</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raymond+T.+Ng%22">Raymond T. Ng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vladimir+Tucakov%22">Vladimir Tucakov</a></li></ol>
          <input type="checkbox" id="43989"/>
          <label for="43989">Abstract</label>
          <div>This paper deals with finding outliers (exceptions) in large, multidimensional datasets. The identification of outliers can lead to the discovery of truly unexpected knowledge in areas such as electronic commerce, credit card fraud, and even the analysis of performance statistics of professional athletes. Existing methods that we have seen for finding outliers can only deal efficiently with two dimensions/attributes of a dataset. In this paper, we study the notion of DB (distance-based) outliers. Specifically, we show that (i) outlier detection can be done efficiently for large datasets, and for k-dimensional datasets with large values of k (e.g., $k \ge 5$ ); and (ii), outlier detection is a meaningful and important knowledge discovery task. First, we present two simple algorithms, both having a complexity of $O(k \: N^2)$ , k being the dimensionality and N being the number of objects in the dataset. These algorithms readily support datasets with many more than two attributes. Second, we present an optimized cell-based algorithm that has a complexity that is linear with respect to N, but exponential with respect to k. We provide experimental results indicating that this algorithm significantly outperforms the two simple algorithms for $k \leq 4$ . Third, for datasets that are mainly disk-resident, we present another version of the cell-based algorithm that guarantees at most three passes over a dataset. Again, experimental results show that this algorithm is by far the best for $k \leq 4$ . Finally, we discuss our work on three real-life applications, including one on spatio-temporal data (e.g., a video surveillance application), in order to confirm the relevance and broad applicability of DB outliers.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050007">Quantifiable data mining using ratio rules</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050007.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Flip+Korn%22">Flip Korn</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alexandros+Labrinidis%22">Alexandros Labrinidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Kotidis%22">Yannis Kotidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christos+Faloutsos%22">Christos Faloutsos</a></li></ol>
          <input type="checkbox" id="59036"/>
          <label for="59036">Abstract</label>
          <div>Association Rule Mining algorithms operate on a data matrix (e.g., customers $\times$ products) to derive association rules [AIS93b, SA96]. We propose a new paradigm, namely, Ratio Rules, which are quantifiable in that we can measure the “goodness” of a set of discovered rules. We also propose the “guessing error” as a measure of the “goodness”, that is, the root-mean-square error of the reconstructed values of the cells of the given matrix, when we pretend that they are unknown. Another contribution is a novel method to guess missing/hidden values from the Ratio Rules that our method derives. For example, if somebody bought $10 of milk and $3 of bread, our rules can “guess” the amount spent on butter. Thus, unlike association rules, Ratio Rules can perform a variety of important tasks such as forecasting, answering “what-if” scenarios, detecting outliers, and visualizing the data. Moreover, we show that we can compute Ratio Rules in a single pass over the data set with small memory requirements (a few small matrices), in contrast to association rule mining methods which require multiple passes and/or large memory. Experiments on several real data sets (e.g., basketball and baseball statistics, biological data) demonstrate that the proposed method: (a) leads to rules that make sense; (b) can find large itemsets in binary matrices, even in the presence of noise; and (c) consistently achieves a “guessing error” of up to 5 times less than using straightforward column averages.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050008">Effective timestamping in databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050008.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kristian+Torp%22">Kristian Torp</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen%22">Christian S. Jensen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Richard+T.+Snodgrass%22">Richard T. Snodgrass</a></li></ol>
          <input type="checkbox" id="55122"/>
          <label for="55122">Abstract</label>
          <div>Many existing database applications place various timestamps on their data, rendering temporal values such as dates and times prevalent in database tables. During the past two decades, several dozen temporal data models have appeared, all with timestamps being integral components. The models have used timestamps for encoding two specific temporal aspects of database facts, namely transaction time, when the facts are current in the database, and valid time, when the facts are true in the modeled reality. However, with few exceptions, the assignment of timestamp values has been considered only in the context of individual modification statements. This paper takes the next logical step: It considers the use of timestamping for capturing transaction and valid time in the context of transactions. The paper initially identifies and analyzes several problems with straightforward timestamping, then proceeds to propose a variety of techniques aimed at solving these problems. Timestamping the results of a transaction with the commit time of the transaction is a promising approach. The paper studies how this timestamping may be done using a spectrum of techniques. While many database facts are valid until now, the current time, this value is absent from the existing temporal types. Techniques that address this problem using different substitute values are presented. Using a stratum architecture, the performance of the different proposed techniques are studied. Although querying and modifying time-varying data is accompanied by a number of subtle problems, we present a comprehensive approach that provides application programmers with simple, consistent, and efficient support for modifying bitemporal databases in the context of user transactions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050009">WaveCluster: a wavelet-based clustering approach for spatial data in very large databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050009.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gholamhosein+Sheikholeslami%22">Gholamhosein Sheikholeslami</a></li><li><a href="http://link.springer.com/search?facet-author=%22Surojit+Chatterjee%22">Surojit Chatterjee</a></li><li><a href="http://link.springer.com/search?facet-author=%22Aidong+Zhang%22">Aidong Zhang</a></li></ol>
          <input type="checkbox" id="2069"/>
          <label for="2069">Abstract</label>
          <div>Many applications require the management of spatial data in a multidimensional feature space. Clustering large spatial databases is an important problem, which tries to find the densely populated regions in the feature space to be used in data mining, knowledge discovery, or efficient information retrieval. A good clustering approach should be efficient and detect clusters of arbitrary shape. It must be insensitive to the noise (outliers) and the order of input data. We propose WaveCluster, a novel clustering approach based on wavelet transforms, which satisfies all the above requirements. Using the multiresolution property of wavelet transforms, we can effectively identify arbitrarily shaped clusters at different degrees of detail. We also demonstrate that WaveCluster is highly efficient in terms of time complexity. Experimental results on very large datasets are presented, which show the efficiency and effectiveness of the proposed approach compared to the other recent clustering methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050010">Update propagation strategies to improve freshness in lazy master replicated databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050010.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Esther+Pacitti%22">Esther Pacitti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eric+Simon%22">Eric Simon</a></li></ol>
          <input type="checkbox" id="58942"/>
          <label for="58942">Abstract</label>
          <div>Many distributed database applications need to replicate data to improve data availability and query response time. The two-phase commit protocol guarantees mutual consistency of replicated data but does not provide good performance. Lazy replication has been used as an alternative solution in several types of applications such as on-line financial transactions and telecommunication systems. In this case, mutual consistency is relaxed and the concept of freshness is used to measure the deviation between replica copies. In this paper, we propose two update propagation strategies that improve freshness. Both of them use immediate propagation: updates to a primary copy are propagated towards a slave node as soon as they are detected at the master node without waiting for the commitment of the update transaction. Our performance study shows that our strategies can improve data freshness by up to five times compared with the deferred approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050011">Optimizing multiple dimensional queries simultaneously in multidimensional databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050011.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Weifa+Liang%22">Weifa Liang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Maria+E.+Orlowska%22">Maria E. Orlowska</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+X.+Yu%22">Jeffrey X. Yu</a></li></ol>
          <input type="checkbox" id="38577"/>
          <label for="38577">Abstract</label>
          <div>Some significant progress related to multidimensional data analysis has been achieved in the past few years, including the design of fast algorithms for computing datacubes, selecting some precomputed group-bys to materialize, and designing efficient storage structures for multidimensional data. However, little work has been carried out on multidimensional query optimization issues. Particularly the response time (or evaluation cost) for answering several related dimensional queries simultaneously is crucial to the OLAP applications. Recently, Zhao et al. first exploited this problem by presenting three heuristic algorithms. In this paper we first consider in detail two cases of the problem in which all the queries are either hash-based star joins or index-based star joins only. In the case of the hash-based star join, we devise a polynomial approximation algorithm which delivers a plan whose evaluation cost is $ O(n^{\epsilon }$) times the optimal, where n is the number of queries and $ \epsilon $ is a fixed constant with $0<\epsilon \leq 1$ . We also present an exponential algorithm which delivers a plan with the optimal evaluation cost. In the case of the index-based star join, we present a heuristic algorithm which delivers a plan whose evaluation cost is n times the optimal, and an exponential algorithm which delivers a plan with the optimal evaluation cost. We then consider a general case in which both hash-based star-join and index-based star-join queries are included. For this case, we give a possible improvement on the work of Zhao et al., based on an analysis of their solutions. We also develop another heuristic and an exact algorithm for the problem. We finally conduct a performance study by implementing our algorithms. The experimental results demonstrate that the solutions delivered for the restricted cases are always within two times of the optimal, which confirms our theoretical upper bounds. Actually these experiments produce much better results than our theoretical estimates. To the best of our knowledge, this is the only development of polynomial algorithms for the first two cases which are able to deliver plans with deterministic performance guarantees in terms of the qualities of the plans generated. The previous approaches including that of [ZDNS98] may generate a feasible plan for the problem in these two cases, but they do not provide any performance guarantee, i.e., the plans generated by their algorithms can be arbitrarily far from the optimal one.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (October 1999)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050075">Deadlock detection in distributed database systems: a new algorithm and a comparative performance analysis</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050075.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Natalija+Krivokapi%C4%87%22">Natalija Krivokapić</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alfons+Kemper%22">Alfons Kemper</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ehud+Gudes%22">Ehud Gudes</a></li></ol>
          <input type="checkbox" id="65555"/>
          <label for="65555">Abstract</label>
          <div>This paper attempts a comprehensive study of deadlock detection in distributed database systems. First, the two predominant deadlock models in these systems and the four different distributed deadlock detection approaches are discussed. Afterwards, a new deadlock detection algorithm is presented. The algorithm is based on dynamically creating deadlock detection agents (DDAs), each being responsible for detecting deadlocks in one connected component of the global wait-for-graph (WFG). The DDA scheme is a “self-tuning” system: after an initial warm-up phase, dedicated DDAs will be formed for “centers of locality”, i.e., parts of the system where many conflicts occur. A dynamic shift in locality of the distributed system will be responded to by automatically creating new DDAs while the obsolete ones terminate. In this paper, we also compare the most competitive representative of each class of algorithms suitable for distributed database systems based on a simulation model, and point out their relative strengths and weaknesses. The extensive experiments we carried out indicate that our newly proposed deadlock detection algorithm outperforms the other algorithms in the vast majority of configurations and workloads and, in contrast to all other algorithms, is very robust with respect to differing load and access profiles.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050076">MIL primitives for querying a fragmented world</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050076.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+A.+Boncz%22">Peter A. Boncz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Martin+L.+Kersten%22">Martin L. Kersten</a></li></ol>
          <input type="checkbox" id="61378"/>
          <label for="61378">Abstract</label>
          <div>In query-intensive database application areas, like decision support and data mining, systems that use vertical fragmentation have a significant performance advantage. In order to support relational or object oriented applications on top of such a fragmented data model, a flexible yet powerful intermediate language is needed. This problem has been successfully tackled in Monet, a modern extensible database kernel developed by our group. We focus on the design choices made in the Monet interpreter language (MIL), its algebraic query language, and outline how its concept of tactical optimization enhances and simplifies the optimization of complex queries. Finally, we summarize the experience gained in Monet by creating a highly efficient implementation of MIL.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050077">Semantic heterogeneity resolution in federated databases by metadata implantation and stepwise evolution</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050077.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Goksel+Aslan%22">Goksel Aslan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dennis+McLeod%22">Dennis McLeod</a></li></ol>
          <input type="checkbox" id="87535"/>
          <label for="87535">Abstract</label>
          <div>A key aspect of interoperation among data-intensive systems involves the mediation of metadata and ontologies across database boundaries. One way to achieve such mediation between a local database and a remote database is to fold remote metadata into the local metadata, thereby creating a common platform through which information sharing and exchange becomes possible. Schema implantation and semantic evolution, our approach to the metadata folding problem, is a partial database integration scheme in which remote and local (meta)data are integrated in a stepwise manner over time. We introduce metadata implantation and stepwise evolution techniques to interrelate database elements in different databases, and to resolve conflicts on the structure and semantics of database elements (classes, attributes, and individual instances). We employ a semantically rich canonical data model, and an incremental integration and semantic heterogeneity resolution scheme. In our approach, relationships between local and remote information units are determined whenever enough knowledge about their semantics is acquired. The metadata folding problem is solved by implanting remote database elements into the local database, a process that imports remote database elements into the local database environment, hypothesizes the relevance of local and remote classes, and customizes the organization of remote metadata. We have implemented a prototype system and demonstrated its use in an experimental neuroscience environment.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050078">Efficient support for interactive service in multi-resolution VOD systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050078.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kelvin+K.W.+Law%22">Kelvin K.W. Law</a></li><li><a href="http://link.springer.com/search?facet-author=%22John+C.S.+Lui%22">John C.S. Lui</a></li><li><a href="http://link.springer.com/search?facet-author=%22Leana+Golubchik%22">Leana Golubchik</a></li></ol>
          <input type="checkbox" id="46067"/>
          <label for="46067">Abstract</label>
          <div>Advances in high-speed networks and multimedia technologies have made it feasible to provide video-on-demand (VOD) services to users. However, it is still a challenging task to design a cost-effective VOD system that can support a large number of clients (who may have different quality of service (QoS) requirements) and, at the same time, provide different types of VCR functionalities. Although it has been recognized that VCR operations are important functionalities in providing VOD service, techniques proposed in the past for providing VCR operations may require additional system resources, such as extra disk I/O, additional buffer space, as well as network bandwidth. In this paper, we consider the design of a VOD storage server that has the following features: (1) provision of different levels of display resolutions to users who have different QoS requirements, (2) provision of different types of VCR functionalities, such as fast forward and rewind, without imposing additional demand on the system buffer space, I/O bandwidth, and network bandwidth, and (3) guarantees of the load-balancing property across all disks during normal and VCR display periods. The above-mentioned features are especially important because they simplify the design of the buffer space, I/O, and network resource allocation policies of the VOD storage system. The load-balancing property also ensures that no single disk will be the bottleneck of the system. In this paper, we propose data block placement, admission control, and I/O-scheduling algorithms, as well as determine the corresponding buffer space requirements of the proposed VOD storage system. We show that the proposed VOD system can provide VCR and multi-resolution services to the viewing clients and at the same time maintain the load-balancing property.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (April 1999)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050071">Fast joins using join indices</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050071.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Zhe+Li%22">Zhe Li</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kenneth+A.+Ross%22">Kenneth A. Ross</a></li></ol>
          <input type="checkbox" id="13344"/>
          <label for="13344">Abstract</label>
          <div>Two new algorithms, “Jive join” and “Slam join,” are proposed for computing the join of two relations using a join index. The algorithms are duals: Jive join range-partitions input relation tuple ids and then processes each partition, while Slam join forms ordered runs of input relation tuple ids and then merges the results. Both algorithms make a single sequential pass through each input relation, in addition to one pass through the join index and two passes through a temporary file, whose size is half that of the join index. Both algorithms require only that the number of blocks in main memory is of the order of the square root of the number of blocks in the smaller relation. By storing intermediate and final join results in a vertically partitioned fashion, our algorithms need to manipulate less data in memory at a given time than other algorithms. The algorithms are resistant to data skew and adaptive to memory fluctuations. Selection conditions can be incorporated into the algorithms. Using a detailed cost model, the algorithms are analyzed and compared with competing algorithms. For large input relations, our algorithms perform significantly better than Valduriez's algorithm, the TID join algorithm, and hash join algorithms. An experimental study is also conducted to validate the analytical results and to demonstrate the performance characteristics of each algorithm in practice.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050072">The intrinsic problems of structural heterogeneity and an approach to their solution</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050072.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Theo+H%C3%A4rder%22">Theo Härder</a></li><li><a href="http://link.springer.com/search?facet-author=%22G%C3%BCnter+Sauter%22">Günter Sauter</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joachim+Thomas%22">Joachim Thomas</a></li></ol>
          <input type="checkbox" id="69310"/>
          <label for="69310">Abstract</label>
          <div>This paper focuses on the problems that arise when integrating data from heterogeneous sources in a single, unified database view. At first, we give a detailed analysis of the kinds of structural heterogeneity that occur when unified views are derived from different database systems. We present the results in a multiple tier architecture which distinguishes different levels of heterogeneity and relates them to their underlying causes as well as to the mapping conflicts resulting from the view derivation process. As the second essential contribution, the paper presents our approach to a mapping language solving the identified conflicts. The main characteristics of the language are its descriptiveness, its capability to map between schemas written in the relational, object-oriented, ER, or EXPRESS data model, and its facilities for specifying user-defined update operations on the view that are to be propagated to the data sources. Finally, we briefly discuss how this mapping information is employed to convert queries formulated with respect to the integrated view, into database operations over the heterogeneous data sources.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050073">Constant time permutation: an efficient block allocation strategy for variable-bit-rate continuous media data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050073.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yueh-Min+Huang%22">Yueh-Min Huang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jen-Wen+Ding%22">Jen-Wen Ding</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shiao-Li+Tsao%22">Shiao-Li Tsao</a></li></ol>
          <input type="checkbox" id="5234"/>
          <label for="5234">Abstract</label>
          <div>To provide high accessibility of continuous-media (CM) data, CM servers generally stripe data across multiple disks. Currently, the most widely used striping scheme for CM data is round-robin permutation (RRP). Unfortunately, when RRP is applied to variable-bit-rate (VBR) CM data, load imbalance across multiple disks occurs, thereby reducing overall system performance. In this paper, the performance of a VBR CM server with RRP is analyzed. In addition, we propose an efficient striping scheme called constant time permutation (CTP), which takes the VBR characteristic into account and obtains a more balanced load than RRP. Analytic models of both RRP and CTP are presented, and the models are verified via trace-driven simulations. Analysis and simulation results show that CTP can substantially increase the number of clients supported, though it might introduce a few seconds/minutes of initial delay.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050074">OPT++ : an object-oriented implementation for extensible database query optimization</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050074.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Navin+Kabra%22">Navin Kabra</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+J.+DeWitt%22">David J. DeWitt</a></li></ol>
          <input type="checkbox" id="37062"/>
          <label for="37062">Abstract</label>
          <div>In this paper we describe the design and implementation of OPT++, a tool for extensible database query optimization that uses an object-oriented design to simplify the task of implementing, extending, and modifying an optimizer. Building an optimizer using OPT++ makes it easy to extend the query algebra (to add new query algebra operators and physical implementation algorithms to the system), easy to change the search space, and also to change the search strategy. Furthermore, OPT++ comes equipped with a number of search strategies that are available for use by an optimizer-implementor. OPT++ considerably simplifies both, the task of implementing an optimizer for a new database system, and the task of evaluating alternative optimization techniques and strategies to decide what techniques are best suited for that database system. We present the results of a series of performance studies. These results validate our design and show that, in spite of its flexibility, OPT++ can be used to build efficient optimizers.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 7 (February 1998 - December 1998)</h1>
          <ol><li>
          <h2>Issue 4 (December 1998)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050064">Introduction</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050064.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu%22">M. Tamer Özsu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stavros+Christodoulakis%22">Stavros Christodoulakis</a></li></ol>
          <input type="checkbox" id="84416"/>
          <label for="84416">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050065">On periodic resource scheduling for continuous-media databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050065.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Minos+N.+Garofalakis%22">Minos N. Garofalakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Banu+%C3%96zden%22">Banu Özden</a></li><li><a href="http://link.springer.com/search?facet-author=%22Avi+Silberschatz%22">Avi Silberschatz</a></li></ol>
          <input type="checkbox" id="34696"/>
          <label for="34696">Abstract</label>
          <div>The Enhanced Pay-Per-View (EPPV) model for providing continuous-media services associates with each continuous-media clip a display frequency that depends on the clip's popularity. The aim is to increase the number of clients that can be serviced concurrently beyond the capacity limitations of available resources, while guaranteeing a constraint on the response time. This is achieved by sharing periodic continuous-media streams among multiple clients. The EPPV model offers a number of advantages over other data-sharing schemes (e.g., batching), which make it more attractive to large-scale service providers. In this paper, we provide a comprehensive study of the resource-scheduling problems associated with supporting EPPV for continuous-media clips with (possibly) different display rates, frequencies, and lengths. Our main objective is to maximize the amount of disk bandwidth that is effectively scheduled under the given data layout and storage constraints. Our formulation gives rise to $\cal NP$ -hard combinatorial optimization problems that fall within the realm of hard real-time scheduling theory. Given the intractability of the problems, we propose novel heuristic solutions with polynomial-time complexity. We also present preliminary experimental results for the average case behavior of the proposed scheduling schemes and examine how they compare to each other under different workloads. A major contribution of our work is the introduction of a robust scheduling framework that, we believe, can provide solutions for a variety of realistic EPPV resource-scheduling scenarios, as well as any scheduling problem involving regular, periodic use of a shared resource. Based on this framework, we propose various interesting research directions for extending the results presented in this paper.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050066">Spatial and temporal content-based access to hypervideo databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050066.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Haitao+Jiang%22">Haitao Jiang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ahmed+K.+Elmagarmid%22">Ahmed K. Elmagarmid</a></li></ol>
          <input type="checkbox" id="84466"/>
          <label for="84466">Abstract</label>
          <div>Providing content-based video query, retrieval and browsing is the most important goal of a video database management system (VDBMS). Video data is unique not only in terms of its spatial and temporal characteristics, but also in the semantic associations manifested by the entities present in the video. This paper introduces a novel video data model called Logical Hypervideo Data Model. In addition to multilevel video abstractions, the model is capable of representing video entities that users are interested in (defined as hot objects) and their semantic associations with other logical video abstractions, including hot objects themselves. The semantic associations are modeled as video hyperlinks and video data with such property are called hypervideo. Video hyperlinks provide a flexible and effective way of browsing video data. Based on the proposed model, video queries can be specified with both temporal and spatial constraints, as well as with semantic descriptions of the video data. The characteristics of hot objects' spatial and temporal relations and efficient evaluation of them are also discussed. Some query examples are given to demonstrate the expressiveness of the video data model and query language. Finally, we describe a modular video database system architecture that our web-based prototype is based on.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050067">Optimal clip ordering for multi-clip queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050067.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Raymond+T.+Ng%22">Raymond T. Ng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Paul+Shum%22">Paul Shum</a></li></ol>
          <input type="checkbox" id="83650"/>
          <label for="83650">Abstract</label>
          <div>A multi-clip query requests multiple video clips be returned as the answer of the query. In many applications and situations, the order in which these clips are to be delivered does not matter that much to the user. This allows the system ample opportunities to optimize system throughput by using schedules that maximize the effect of piggybacking. In this paper, we study how to find such optimal schedules. In particular, we consider two optimization criteria: (i) one based on maximizing the number of piggybacked clips, and (ii) the other based on maximizing the impact on buffer space. We show that the optimal schedule under the first criterion is equivalent to a maximum matching in a suitably defined bipartite graph, and that under the second criterion, the optimal schedule is equivalent to a maximum matching in a suitably defined weighted bipartite graph. Our experimental results, which are based on realistic distributions, indicate that both kinds of optimal schedules can lead to a gain in throughput of over 300%. And yet the time taken to compute such an optimal schedule is negligible. Finally, we show how to deal with clips that are variable in length.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050068">Integrating symbolic images into a multimedia database system using classification and abstraction approaches</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050068.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Aya+Soffer%22">Aya Soffer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hanan+Samet%22">Hanan Samet</a></li></ol>
          <input type="checkbox" id="97057"/>
          <label for="97057">Abstract</label>
          <div>Symbolic images are composed of a finite set of symbols that have a semantic meaning. Examples of symbolic images include maps (where the semantic meaning of the symbols is given in the legend), engineering drawings, and floor plans. Two approaches for supporting queries on symbolic-image databases that are based on image content are studied. The classification approach preprocesses all symbolic images and attaches a semantic classification and an associated certainty factor to each object that it finds in the image. The abstraction approach describes each object in the symbolic image by using a vector consisting of the values of some of its features (e.g., shape, genus, etc.). The approaches differ in the way in which responses to queries are computed. In the classification approach, images are retrieved on the basis of whether or not they contain objects that have the same classification as the objects in the query. On the other hand, in the abstraction approach, retrieval is on the basis of similarity of feature vector values of these objects. Methods of integrating these two approaches into a relational multimedia database management system so that symbolic images can be stored and retrieved based on their content are described. Schema definitions and indices that support query specifications involving spatial as well as contextual constraints are presented. Spatial constraints may be based on both locational information (e.g., distance) and relational information (e.g., north of). Different strategies for image retrieval for a number of typical queries using these approaches are described. Estimated costs are derived for these strategies. Results are reported of a comparative study of the two approaches in terms of image insertion time, storage space, retrieval accuracy, and retrieval time.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050069">Approximate similarity retrieval with M-trees</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050069.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Pavel+Zezula%22">Pavel Zezula</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pasquale+Savino%22">Pasquale Savino</a></li><li><a href="http://link.springer.com/search?facet-author=%22Giuseppe+Amato%22">Giuseppe Amato</a></li><li><a href="http://link.springer.com/search?facet-author=%22Fausto+Rabitti%22">Fausto Rabitti</a></li></ol>
          <input type="checkbox" id="48212"/>
          <label for="48212">Abstract</label>
          <div>Motivated by the urgent need to improve the efficiency of similarity queries, approximate similarity retrieval is investigated in the environment of a metric tree index called the M-tree. Three different approximation techniques are proposed, which show how to forsake query precision for improved performance. Measures are defined that can quantify the improvements in performance efficiency and the quality of approximations. The proposed approximation techniques are then tested on various synthetic and real-life files. The evidence obtained from the experiments confirms our hypothesis that a high-quality approximated similarity search can be performed at a much lower cost than that needed to obtain the exact results. The proposed approximation techniques are scalable and appear to be independent of the metric used. Extensions of these techniques to the environments of other similarity search indexes are also discussed.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050070">Delivering presentations from multimedia servers</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050070.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nevzat+Hurkan+Balkir%22">Nevzat Hurkan Balkir</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gultekin+Ozsoyoglu%22">Gultekin Ozsoyoglu</a></li></ol>
          <input type="checkbox" id="92498"/>
          <label for="92498">Abstract</label>
          <div>Most multimedia servers reported in the literature are designed to serve multiple and independent video/audio streams. We think that, in future, multimedia servers will also serve complete presentations. Multimedia presentations provide unique opportunities to develop algorithms for buffer management and admission control, as execution-time consumption requirements of presentations are known a priori. In this paper, we examine presentations in three different domains (heavyweight, middleweight, and lightweight) and provide buffer management and admission control algorithms for the three domains. We propose two improvements (flattening and dynamic-adjustments) on the schedules created for the heavyweight presentations. Results from a simulation environment are presented.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (August 1998)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050058">Guest Editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050058.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Matthias+Jarke%22">Matthias Jarke</a></li></ol>
          <input type="checkbox" id="78239"/>
          <label for="78239">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050059">Enhanced abstract data types in object-relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050059.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Praveen+Seshadri%22">Praveen Seshadri</a></li></ol>
          <input type="checkbox" id="74814"/>
          <label for="74814">Abstract</label>
          <div>The explosion in complex multimedia content makes it crucial for database systems to support such data efficiently. This paper argues that the “blackbox” ADTs used in current object-relational systems inhibit their performance, thereby limiting their use in emerging applications. Instead, the next generation of object-relational database systems should be based on enhanced abstract data type (E-ADT) technology. An (E-ADT) can expose the semantics of its methods to the database system, thereby permitting advanced query optimizations. Fundamental architectural changes are required to build a database system with E-ADTs; the added functionality should not compromise the modularity of data types and the extensibility of the type system. The implementation issues have been explored through the development of E-ADTs in Predator. Initial performance results demonstrate an order of magnitude in performance improvements.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050060">Integrated document caching and prefetching in storage hierarchies based on Markov-chain predictions</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050060.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Achim+Kraiss%22">Achim Kraiss</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li></ol>
          <input type="checkbox" id="97991"/>
          <label for="97991">Abstract</label>
          <div>Large multimedia document archives may hold a major fraction of their data in tertiary storage libraries for cost reasons. This paper develops an integrated approach to the vertical data migration between the tertiary, secondary, and primary storage in that it reconciles speculative prefetching, to mask the high latency of the tertiary storage, with the replacement policy of the document caches at the secondary and primary storage level, and also considers the interaction of these policies with the tertiary and secondary storage request scheduling. The integrated migration policy is based on a continuous-time Markov chain model for predicting the expected number of accesses to a document within a specified time horizon. Prefetching is initiated only if that expectation is higher than those of the documents that need to be dropped from secondary storage to free up the necessary space. In addition, the possible resource contention at the tertiary and secondary storage is taken into account by dynamically assessing the response-time benefit of prefetching a document versus the penalty that it would incur on the response time of the pending document requests. The parameters of the continuous-time Markov chain model, the probabilities of co-accessing certain documents and the interaction times between successive accesses, are dynamically estimated and adjusted to evolving workload patterns by keeping online statistics. The integrated policy for vertical data migration has been implemented in a prototype system. The system makes profitable use of the Markov chain model also for the scheduling of volume exchanges in the tertiary storage library. Detailed simulation experiments with Web-server-like synthetic workloads indicate significant gains in terms of client response time. The experiments also show that the overhead of the statistical bookkeeping and the computations for the access predictions is affordable.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050061">Scalable feature selection, classification and signature generation for organizing large text databases into hierarchical topic taxonomies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050061.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Soumen+Chakrabarti%22">Soumen Chakrabarti</a></li><li><a href="http://link.springer.com/search?facet-author=%22Byron+Dom%22">Byron Dom</a></li><li><a href="http://link.springer.com/search?facet-author=%22Rakesh+Agrawal%22">Rakesh Agrawal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Prabhakar+Raghavan%22">Prabhakar Raghavan</a></li></ol>
          <input type="checkbox" id="95227"/>
          <label for="95227">Abstract</label>
          <div>We explore how to organize large text databases hierarchically by topic to aid better searching, browsing and filtering. Many corpora, such as internet directories, digital libraries, and patent databases are manually organized into topic hierarchies, also called taxonomies. Similar to indices for relational data, taxonomies make search and access more efficient. However, the exponential growth in the volume of on-line textual information makes it nearly impossible to maintain such taxonomic organization for large, fast-changing corpora by hand. We describe an automatic system that starts with a small sample of the corpus in which topics have been assigned by hand, and then updates the database with new documents as the corpus grows, assigning topics to these new documents with high speed and accuracy. To do this, we use techniques from statistical pattern recognition to efficiently separate the feature words, or discriminants, from thenoise words at each node of the taxonomy. Using these, we build a multilevel classifier. At each node, this classifier can ignore the large number of “noise” words in a document. Thus, the classifier has a small model size and is very fast. Owing to the use of context-sensitive features, the classifier is very accurate. As a by-product, we can compute for each document a set of terms that occur significantly more often in it than in the classes to which it belongs. We describe the design and implementation of our system, stressing how to exploit standard, efficient relational operations like sorts and joins. We report on experiences with the Reuters newswire benchmark, the US patent database, and web document samples from Yahoo!. We discuss applications where our system can improve searching and filtering capabilities.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050062">Garbage collection in object-oriented databases using transactional cyclic reference counting</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050062.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22P.+Roy%22">P. Roy</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Seshadri%22">S. Seshadri</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Silberschatz%22">A. Silberschatz</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Sudarshan%22">S. Sudarshan</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Ashwin%22">S. Ashwin</a></li></ol>
          <input type="checkbox" id="87516"/>
          <label for="87516">Abstract</label>
          <div>Garbage collection is important in object-oriented databases to free the programmer from explicitly deallocating memory. In this paper, we present a garbage collection algorithm, called Transactional Cyclic Reference Counting (TCRC), for object-oriented databases. The algorithm is based on a variant of a reference-counting algorithm proposed for functional programming languages The algorithm keeps track of auxiliary reference count information to detect and collect cyclic garbage. The algorithm works correctly in the presence of concurrently running transactions, and system failures. It does not obtain any long-term locks, thereby minimizing interference with transaction processing. It uses recovery subsystem logs to detect pointer updates; thus, existing code need not be rewritten. Finally, it exploits schema information, if available, to reduce costs. We have implemented the TCRC algorithm and present results of a performance study of the implementation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050063">Integrating reliable memory in databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050063.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wee+Teck+Ng%22">Wee Teck Ng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+M.+Chen%22">Peter M. Chen</a></li></ol>
          <input type="checkbox" id="64762"/>
          <label for="64762">Abstract</label>
          <div>Recent results in the Rio project at the University of Michigan show that it is possible to create an area of main memory that is as safe as disk from operating system crashes. This paper explores how to integrate the reliable memory provided by the Rio file cache into a database system. Prior studies have analyzed the performance benefits of reliable memory; we focus instead on how different designs affect reliability. We propose three designs for integrating reliable memory into databases: non-persistent database buffer cache, persistent database buffer cache, and persistent database buffer cache with protection. Non-persistent buffer caches use an I/O interface to reliable memory and require the fewest modifications to existing databases. However, they waste memory capacity and bandwidth due to double buffering. Persistent buffer caches use a memory interface to reliable memory by mapping it into the database address space. This places reliable memory under complete database control and eliminates double buffering, but it may expose the buffer cache to database errors. Our third design reduces this exposure by write protecting the buffer pages. Extensive fault tests show that mapping reliable memory into the database address space does not significantly hurt reliability. This is because wild stores rarely touch dirty, committed pages written by previous transactions. As a result, we believe that databases should use a memory interface to reliable memory.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (May 1998)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050054">Maintenance of implication integrity constraints under updates to constraints</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050054.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Naci+S.+Ishakbeyoglu%22">Naci S. Ishakbeyoglu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Z.+Meral+Ozsoyoglu%22">Z. Meral Ozsoyoglu</a></li></ol>
          <input type="checkbox" id="79822"/>
          <label for="79822">Abstract</label>
          <div>Semantic integrity constraints are used for enforcing the integrity of the database as well as for improving the efficiency of the database utilization. Although semantic integrity constraints are usually much more static as compared to the data itself, changes in the data semantics may necessitate corresponding changes in the constraint base. In this paper we address the problems related with maintaining a consistent and non-redundant set of constraints satisfied by the database in the case of updates to the constraint base. We consider implication constraints as semantic integrity constraints. The constraints are represented as conjunctions of inequalities. We present a methodology to determine whether a constraint is redundant or contradictory with respect to a set of constraints. The methodology is based on the partitioning of the constraint base which improves the efficiency of algorithms that check whether a constraint is redundant or contradictory with respect to a constraint base.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050055">Advanced data processing in KRISYS: modeling concepts, implementation techniques, and client/server issues</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050055.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Stefan+De%C3%9Floch%22">Stefan Deßloch</a></li><li><a href="http://link.springer.com/search?facet-author=%22Theo+H%C3%A4rder%22">Theo Härder</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nelson+Mattos%22">Nelson Mattos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bernhard+Mitschang%22">Bernhard Mitschang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joachim+Thomas%22">Joachim Thomas</a></li></ol>
          <input type="checkbox" id="28942"/>
          <label for="28942">Abstract</label>
          <div>The increasing power of modern computers is steadily opening up new application domains for advanced data processing such as engineering and knowledge-based applications. To meet their requirements, concepts for advanced data management have been investigated during the last decade, especially in the field of object orientation. Over the last couple of years, the database group at the University of Kaiserslautern has been developing such an advanced database system, the KRISYS prototype. In this article, we report on the results and experiences obtained in the course of this project. The primary objective for the first version of KRISYS was to provide semantic features, such as an expressive data model, a set-oriented query language, deductive as well as active capabilities. The first KRISYS prototype became completely operational in 1989. To evaluate its features and to stabilize its functionality, we started to develop several applications with the system. These experiences marked the starting point for an overall redesign of KRISYS. Major goals were to tune KRISYS and its query-processing facilities to a suitable client/server environment, as well as to provide elaborate mechanisms for consistency control comprising semantic integrity constraints, multi-user synchronization, and failure recovery. The essential aspects of the resulting client/server architecture are embodied by the client-side data management needed to effectively support advanced applications and to gain the required system performance for interactive work. The project stages of KRISYS properly reflect the essential developments that have taken place in the research on advanced database systems over the last years. Hence, the subsequent discussions will bring up a number of important aspects with regard to advanced data processing that are of significant general importance, as well as of general applicability to database systems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050056">A logical view of structured files</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050056.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Serge+Abiteboul%22">Serge Abiteboul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sophie+Cluet%22">Sophie Cluet</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tova+Milo%22">Tova Milo</a></li></ol>
          <input type="checkbox" id="79148"/>
          <label for="79148">Abstract</label>
          <div>Structured data stored in files can benefit from standard database technology. In particular, we show here how such data can be queried and updated using declarative database languages. We introduce the notion of structuring schema, which consists of a grammar annotated with database programs. Based on a structuring schema, a file can be viewed as a database structure, queried and updated as such. For queries, we show that almost standard database optimization techniques can be used to answer queries without having to construct the entire database. For updates, we study in depth the propagation to the file of an update specified on the database view of this file. The problem is not feasible in general and we present a number of negative results. The positive results consist of techniques that allow to propagate updates efficiently under some reasonable locality conditions on the structuring schemas.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050057">Fast image retrieval using color-spatial information</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050057.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian-Lee+Tan%22">Kian-Lee Tan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tat+Seng+Chua%22">Tat Seng Chua</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wynne+Hsu%22">Wynne Hsu</a></li></ol>
          <input type="checkbox" id="42793"/>
          <label for="42793">Abstract</label>
          <div>In this paper, we present an image retrieval system that employs both the color and spatial information of images to facilitate the retrieval process. The basic unit used in our technique is a single-colored cluster, which bounds a homogeneous region of that color in an image. Two clusters from two images are similar if they are of the same color and overlap in the image space. The number of clusters that can be extracted from an image can be very large, and it affects the accuracy of retrieval. We study the effect of the number of clusters on retrieval effectiveness to determine an appropriate value for “optimal'' performance. To facilitate efficient retrieval, we also propose a multi-tier indexing mechanism called the Sequenced Multi-Attribute Tree (SMAT). We implemented a two-tier SMAT, where the first layer is used to prune away clusters that are of different colors, while the second layer discriminates clusters of different spatial locality. We conducted an experimental study on an image database consisting of 12,000 images. Our results show the effectiveness of the proposed color-spatial approach, and the efficiency of the proposed indexing mechanism.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (February 1998)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050050">Optimizing relational queries in connection hypergraphs: nested queries, views, and binding propagations</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050050.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jia+Liang+Han%22">Jia Liang Han</a></li></ol>
          <input type="checkbox" id="9756"/>
          <label for="9756">Abstract</label>
          <div>We optimize relational queries using connection hypergraphs (CHGs). All operations including value-passing between SQL blocks can be set-oriented. By introducing partial evaluations, reordering operations can be achieved for nested queries. For a query using views, we merge CHGs for the views and the query into one CHG and then apply query optimization. Furthermore, we may simulate magic sets methods elegantly in a CHG. Sideways information-passing strategies (SIPS) in a CHG amount to partial evaluations of SIPS paths. We introduce the maximum SIPS strategy, which performs SIPS for all bindings and all SIPS paths for a query. The new method has several advantages. First, the maximum SIPS strategy can be more efficient than the previous SIPS based on simple heuristics. Second, it is conceptually simple and easy to implement. Third, the processing strategies may be incorporated with the search space for query execution plans, which is a proven optimization strategy introduced by System R. Fourth, it provides a general framework of query optimization and may potentially be used to optimize next-generation database systems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050051">A flexible and recoverable client/server database event notification system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050051.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Eric+N.+Hanson%22">Eric N. Hanson</a></li><li><a href="http://link.springer.com/search?facet-author=%22I.-Cheng+Chen%22">I.-Cheng Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Roxana+Dastur%22">Roxana Dastur</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kurt+Engel%22">Kurt Engel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vijay+Ramaswamy%22">Vijay Ramaswamy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wendy+Tan%22">Wendy Tan</a></li><li><a href="http://link.springer.com/search?facet-author=%22Chun+Xu%22">Chun Xu</a></li></ol>
          <input type="checkbox" id="1847"/>
          <label for="1847">Abstract</label>
          <div>A software architecture is presented that allows client application programs to interact with a DBMS server in a flexible and powerful way, using either direct, volatile messages, or messages sent via recoverable queues. Normal requests from clients to the server and replies from the server to clients can be transmitted using direct or recoverable messages. In addition, an application event notification mechanism is provided, whereby client applications running anywhere on the network can register for events, and when those events are raised, the clients are notified. A novel parameter passing mechanism allows a set of tuples to be included in an event notification. The event mechanism is particularly useful in an active DBMS, where events can be raised by triggers to signal running application programs.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050052">The OODB path-method generator (PMG) using access weights and precomputed access relevance</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050052.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ashish+Mehta%22">Ashish Mehta</a></li><li><a href="http://link.springer.com/search?facet-author=%22James+Geller%22">James Geller</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yehoshua+Perl%22">Yehoshua Perl</a></li><li><a href="http://link.springer.com/search?facet-author=%22Erich+Neuhold%22">Erich Neuhold</a></li></ol>
          <input type="checkbox" id="89950"/>
          <label for="89950">Abstract</label>
          <div>A path-method is used as a mechanism in object-oriented databases (OODBs) to retrieve or to update information relevant to one class that is not stored with that class but with some other class. A path-method is a method which traverses from one class through a chain of connections between classes and accesses information at another class. However, it is a difficult task for a casual user or even an application programmer to write path-methods to facilitate queries. This is because it might require comprehensive knowledge of many classes of the conceptual schema that are not directly involved in the query, and therefore may not even be included in a user's (incomplete) view about the contents of the database. We have developed a system, called path-method generator (PMG), which generates path-methods automatically according to a user's database-manipulating requests. The PMG offers the user one of the possible path-methods and the user verifies from his knowledge of the intended purpose of the request whether that path-method is the desired one. If the path method is rejected, then the user can utilize his now increased knowledge about the database to request (with additional parameters given) another offer from the PMG. The PMG is based on access weights attached to the connections between classes and precomputed access relevance between every pair of classes of the OODB. Specific rules for access weight assignment and algorithms for computing access relevance appeared in our previous papers [MGPF92, MGPF93, MGPF96]. In this paper, we present a variety of traversal algorithms based on access weights and precomputed access relevance. Experiments identify some of these algorithms as very successful in generating most desired path-methods. The PMG system utilizes these successful algorithms and is thus an efficient tool for aiding the user with the difficult task of querying and updating a large OODB.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050053">Data partitioning and load balancing in parallel disk systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050053.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+Scheuermann%22">Peter Scheuermann</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum%22">Gerhard Weikum</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+Zabback%22">Peter Zabback</a></li></ol>
          <input type="checkbox" id="41902"/>
          <label for="41902">Abstract</label>
          <div>Parallel disk systems provide opportunities for exploiting I/O parallelism in two possible ways, namely via inter-request and intra-request parallelism. In this paper, we discuss the main issues in performance tuning of such systems, namely striping and load balancing, and show their relationship to response time and throughput. We outline the main components of an intelligent, self-reliant file system that aims to optimize striping by taking into account the requirements of the applications, and performs load balancing by judicious file allocation and dynamic redistributions of the data when access patterns change. Our system uses simple but effective heuristics that incur only little overhead. We present performance experiments based on synthetic workloads and real-life traces.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 6 (February 1997 - November 1997)</h1>
          <ol><li>
          <h2>Issue 4 (November 1997)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050045">Query processing over object views of relational data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050045.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gustav+Fahl%22">Gustav Fahl</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tore+Risch%22">Tore Risch</a></li></ol>
          <input type="checkbox" id="17086"/>
          <label for="17086">Abstract</label>
          <div>This paper presents an approach to object view management for relational databases. Such a view mechanism makes it possible for users to transparently work with data in a relational database as if it was stored in an object-oriented (OO) database. A query against the object view is translated to one or several queries against the relational database. The results of these queries are then processed to form an answer to the initial query. The approach is not restricted to a ‘pure’ object view mechanism for the relational data, since the object view can also store its own data and methods. Therefore it must be possible to process queries that combine local data residing in the object view with data retrieved from the relational database. We discuss the key issues when object views of relational databases are developed, namely: how to map relational structures to sub-type/supertype hierarchies in the view, how to represent relational database access in OO query plans, how to provide the concept of object identity in the view, how to handle the fact that the extension of types in the view depends on the state of the relational database, and how to process and optimize queries against the object view. The results are based on experiences from a running prototype implementation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050046">EXACT: an extensible approach to active object-oriented databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050046.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Oscar+D%C3%ADaz%22">Oscar Díaz</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arturo+Jaime%22">Arturo Jaime</a></li></ol>
          <input type="checkbox" id="13954"/>
          <label for="13954">Abstract</label>
          <div>Active database management systems (DBMSs) are a fast-growing area of research, mainly due to the large number of applications which can benefit from this active dimension. These applications are far from being homogeneous, requiring different kinds of functionalities. However, most of the active DBMSs described in the literature only provide a fixed, hard-wired execution model to support the active dimension. In object-oriented DBMSs, event-condition-action rules have been propo sed for providing active behaviour. This paper presents EXACT, a rule manager for object-oriented DBMSs which provides a variety of options from which the designer can choose the one that best fits the semantics of the concept to be supported by rules. Due to the difficulty of foreseeing future requirements, special attention has been paid to making rule management easily extensible, so that the user can tailor it to suit specific applications. This has been borne out by an implementation in ADAM, an object -oriented DBMS. An example is shown of how the default mechanism can be easily extended to support new requirements.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050047">Structured document storage and refined declarative and navigational access mechanisms in HyperStorM</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050047.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Klemens+B%C3%B6hm%22">Klemens Böhm</a></li><li><a href="http://link.springer.com/search?facet-author=%22Karl+Aberer%22">Karl Aberer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Erich+J.+Neuhold%22">Erich J. Neuhold</a></li><li><a href="http://link.springer.com/search?facet-author=%22Xiaoya+Yang%22">Xiaoya Yang</a></li></ol>
          <input type="checkbox" id="74344"/>
          <label for="74344">Abstract</label>
          <div>The combination of SGML and database technology allows to refine both declarative and navigational access mechanisms for structured document collection: with regard to declarative access, the user can formulate complex information needs without knowing a query language, the respective document type definition (DTD) or the underlying modelling. Navigational access is eased by hyperlink-rendition mechanisms going beyond plain link-integrity checking. With our approach, the database-internal representation of documents is configurable. It allows for an efficient implementation of operations, because DTD knowledge is not needed for document structure recognition. We show how the number of method invocations and the cost of parsing can be significantly reduced.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050048">A configurable type hierarchy index for OODB</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050048.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Thomas+A.+Mueck%22">Thomas A. Mueck</a></li><li><a href="http://link.springer.com/search?facet-author=%22Martin+L.+Polaschek%22">Martin L. Polaschek</a></li></ol>
          <input type="checkbox" id="12511"/>
          <label for="12511">Abstract</label>
          <div>With respect to the specific requirements of advanced OODB applications, index data structures for type hierarchies in OODBMS have to provide efficient support for multiattribute queries and have to allow index optimization for a particular query profile. We describe the multikey type index and an efficient implementation of this indexing scheme. It meets both requirements: in addition to its multiattribute query capabilities it is designed as a mediator between two standard design alternatives, key-grouping and type-grouping. A prerequisite for the multikey type index is a linearization algorithm which maps type hierarchies to linearly ordered attribute domains in such a way that each subhierarchy is represented by an interval of this domain. The algorithm extends previous results with respect to multiple inheritance. The subsequent evaluation of our proposal focuses on storage space overhead as well as on the number of disk I/O operations needed for query execution. The analytical results for the multikey type index are compared to previously published figures for well-known single-key search structures. The comparison clearly shows the superiority of the multikey type index for a large class of query profiles.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050049">Using extended feature objects for partial similarity retrieval</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050049.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Stefan+Berchtold%22">Stefan Berchtold</a></li><li><a href="http://link.springer.com/search?facet-author=%22Daniel+A.+Keim%22">Daniel A. Keim</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hans-Peter+Kriegel%22">Hans-Peter Kriegel</a></li></ol>
          <input type="checkbox" id="74428"/>
          <label for="74428">Abstract</label>
          <div>In this paper, we introduce the concept of extended feature objects for similarity retrieval. Conventional approaches for similarity search in databases map each object in the database to a point in some high-dimensional feature space and define similarity as some distance measure in this space. For many similarity search problems, this feature-based approach is not sufficient. When retrieving partially similar polygons, for example, the search cannot be restricted to edge sequences, since similar polygon sections may start and end anywhere on the edges of the polygons. In general, inherently continuous problems such as the partial similarity search cannot be solved by using point objects in feature space. In our solution, we therefore introduce extended feature objects consisting of an infinite set of feature points. For an efficient storage and retrieval of the extended feature objects, we determine the minimal bounding boxes of the feature objects in multidimensional space and store these boxes using a spatial access structure. In our concrete polygon problem, sets of polygon sections are mapped to 2D feature objects in high-dimensional space which are then approximated by minimal bounding boxes and stored in an R $^*$ -tree. The selectivity of the index is improved by using an adaptive decomposition of very large feature objects and a dynamic joining of small feature objects. For the polygon problem, translation, rotation, and scaling invariance is achieved by using the Fourier-transformed curvature of the normalized polygon sections. In contrast to vertex-based algorithms, our algorithm guarantees that no false dismissals may occur and additionally provides fast search times for realistic database sizes. We evaluate our method using real polygon data of a supplier for the car manufacturing industry.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (August 1997)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050039">The impact of object technology on commercial transaction processing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050039.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Edward+E.+Cobb%22">Edward E. Cobb</a></li></ol>
          <input type="checkbox" id="13287"/>
          <label for="13287">Abstract</label>
          <div>Businesses today are searching for information solutions that enable them to compete in the global marketplace. To minimize risk, these solutions must build on existing investments, permit the best technology to be applied to the problem, and be manageable. Object technology, with its promise of improved productivity and quality in application development, delivers these characteristics but, to date, its deployment in commercial business applications has been limited. One possible reason is the absence of the transaction paradigm, widely used in commercial environments and essential for reliable business applications. For object technology to be a serious contender in the construction of these solutions requires: – technology for transactional objects. In December 1994, the Object Management Group adopted a specification for an object transaction service (OTS). The OTS specifies mechanisms for defining and manipulating transactions. Though derived from the X/Open distributed transaction processing model, OTS contains additional enhancements specifically designed for the object environment. Similar technology from Microsoft appeared at the end of 1995. – methodologies for building new business systems from existing parts. Business process re-engineering is forcing businesses to improve their operations which bring products to market. Workflow computing, when used in conjunction with “object wrappers” provides tools to both define and track execution of business processes which leverage existing applications and infrastructure. – an execution environment which satisfies the requirements of the operational needs of the business. Transaction processing (TP) monitor technology, though widely accepted for mainframe transaction processing, has yet to enjoy similar success in the client/server marketplace. Instead the database vendors, with their extensive tool suites, dominate. As object brokers mature they will require many of the functions of today's TP monitors. Marrying these two technologies can produce a robust execution environment which offers a superior alternative for building and deploying client/server applications.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050040">Heuristic and randomized optimization for the join ordering problem</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050040.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Michael+Steinbrunn%22">Michael Steinbrunn</a></li><li><a href="http://link.springer.com/search?facet-author=%22Guido+Moerkotte%22">Guido Moerkotte</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alfons+Kemper%22">Alfons Kemper</a></li></ol>
          <input type="checkbox" id="59375"/>
          <label for="59375">Abstract</label>
          <div>Recent developments in database technology, such as deductive database systems, have given rise to the demand for new, cost-effective optimization techniques for join expressions. In this paper many different algorithms that compute approximate solutions for optimizing join orders are studied since traditional dynamic programming techniques are not appropriate for complex problems. Two possible solution spaces, the space of left-deep and bushy processing trees, are evaluated from a statistical point of view. The result is that the common limitation to left-deep processing trees is only advisable for certain join graph types. Basically, optimizers from three classes are analysed: heuristic, randomized and genetic algorithms. Each one is extensively scrutinized with respect to its working principle and its fitness for the desired application. It turns out that randomized and genetic algorithms are well suited for optimizing join expressions. They generate solutions of high quality within a reasonable running time. The benefits of heuristic optimizers, namely the short running time, are often outweighed by merely moderate optimization performance.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050041">Synchronization and recovery in a client-server storage system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050041.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22E.+Panagos%22">E. Panagos</a></li><li><a href="http://link.springer.com/search?facet-author=%22A.+Biliris%22">A. Biliris</a></li></ol>
          <input type="checkbox" id="26853"/>
          <label for="26853">Abstract</label>
          <div>Client-server object-oriented database management systems differ significantly from traditional centralized systems in terms of their architecture and the applications they target. In this paper, we present the client-server architecture of the EOS storage manager and we describe the concurrency control and recovery mechanisms it employs. EOS offers a semi-optimistic locking scheme based on the multi-granularity two-version two-phase locking protocol. Under this scheme, multiple concurrent readers are allowed to access a data item while it is being updated by a single writer. Recovery is based on write-ahead redo-only logging. Log records are generated at the clients and they are shipped to the server during normal execution and at transaction commit. Transaction rollback is fast because there are no updates that have to be undone, and recovery from system crashes requires only one scan of the log for installing the changes made by transactions that committed before the crash. We also present a preliminary performance evaluation of the implementation of the above mechanisms.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050042">Concurrency and recovery for index trees</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050042.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22David+Lomet%22">David Lomet</a></li><li><a href="http://link.springer.com/search?facet-author=%22Betty+Salzberg%22">Betty Salzberg</a></li></ol>
          <input type="checkbox" id="55982"/>
          <label for="55982">Abstract</label>
          <div>Although many suggestions have been made for concurrency in B $^+$ -trees, few of these have considered recovery as well. We describe an approach which provides high concurrency while preserving well-formed trees across system crashes. Our approach works for a class of index trees that is a generalization of the B $^{\rm link}$ -tree. This class includes some multi-attribute indexes and temporal indexes. Structural changes in an index tree are decomposed into a sequence of atomic actions, each one leaving the tree well-formed and each working on a separate level of the tree. All atomic actions on levels of the tree above the leaf level are independent of database transactions, and so are of short duration. Incomplete structural changes are detected in normal operations and trigger completion.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050043">Seeking the truth about ad hoc join costs</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050043.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Laura+M.+Haas%22">Laura M. Haas</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Carey%22">Michael J. Carey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Miron+Livny%22">Miron Livny</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amit+Shukla%22">Amit Shukla</a></li></ol>
          <input type="checkbox" id="93249"/>
          <label for="93249">Abstract</label>
          <div>In this paper, we re-examine the results of prior work on methods for computing ad hoc joins. We develop a detailed cost model for predicting join algorithm performance, and we use the model to develop cost formulas for the major ad hoc join methods found in the relational database literature. We show that various pieces of “common wisdom” about join algorithm performance fail to hold up when analyzed carefully, and we use our detailed cost model to derive op timal buffer allocation schemes for each of the join methods examined here. We show that optimizing their buffer allocations can lead to large performance improvements, e.g., as much as a 400% improvement in some cases. We also validate our cost model's predictions by measuring an actual implementation of each join algorithm considered. The results of this work should be directly useful to implementors of relational query optimizers and query processing systems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050044">A database model for object dynamics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050044.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22M.P.+Papazoglou%22">M.P. Papazoglou</a></li><li><a href="http://link.springer.com/search?facet-author=%22B.J.+Kr%C3%A4mer%22">B.J. Krämer</a></li></ol>
          <input type="checkbox" id="46006"/>
          <label for="46006">Abstract</label>
          <div>Due to a technical error, some figures of the above paper were not reproduced satisfactorily. They are printed again below:</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (May 1997)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050034">A database model for object dynamics</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050034.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22M.P.+Papazoglou%22">M.P. Papazoglou</a></li><li><a href="http://link.springer.com/search?facet-author=%22B.J.+Kr%C3%A4mer%22">B.J. Krämer</a></li></ol>
          <input type="checkbox" id="29023"/>
          <label for="29023">Abstract</label>
          <div>To effectively model complex applications in which constantly changing situations can be represented, a database system must be able to support the runtime specification of structural and behavioral nuances for objects on an individual or group basis. This paper introduces the role mechanism as an extension of object-oriented databases to support unanticipated behavioral oscillations for objects that may attain many types and share a single object identity. A role refers to the ability to represent object dynamics by seamlessly integrating idiosyncratic behavior, possibly in response to external events, with pre-existing object behavior specified at instance creation time. In this manner, the same object can simultaneously be an instance of different classes which symbolize the different roles that this object assumes. The role concept and its underlying linguistic scheme simplify the design requirements of complex applications that need to create and manipulate dynamic objects.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050035">Graphical interaction with heterogeneous databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050035.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22T.+Catarci%22">T. Catarci</a></li><li><a href="http://link.springer.com/search?facet-author=%22G.+Santucci%22">G. Santucci</a></li><li><a href="http://link.springer.com/search?facet-author=%22J.+Cardiff%22">J. Cardiff</a></li></ol>
          <input type="checkbox" id="35544"/>
          <label for="35544">Abstract</label>
          <div>During the past few years our research efforts have been inspired by two different needs. On one hand, the number of non-expert users accessing databases is growing apace. On the other, information systems will no longer be characterized by a single centralized architecture, but rather by several heterogeneous component systems. In order to address such needs we have designed a new query system with both user-oriented and multidatabase features. The system's main components are an adaptive visual interface, providing the user with different and interchangeable interaction modalities, and a “translation layer”, which creates and offers to the user the illusion of a single homogeneous schema out of several heterogeneous components. Both components are founded on a common ground, i.e. a formally defined and semantically rich data model, the Graph Model, and a minimal set of Graphical Primitives, in terms of which general query operations may be visually expressed. The Graph Model has a visual syntax, so that graphical operations can be applied on its components without unnecessary mappings, and an object-based semantics. The aim of this paper is twofold. We first present an overall view of the system architecture and then give a comprehensive description of the lower part of the system itself. In particular, we show how schemata expressed in different data models can be translated in terms of Graph Model, possibly by exploiting reverse engineering techniques. Moreover, we show how mappings can be established between well-known query languages and the Graphical Primitives. Finally, we describe in detail how queries expressed by using the Graphical Primitives can be translated in terms of relational expressions so to be processed by actual DBMSs.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050036">On applying hash filters to improving the execution of multi-join queries</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050036.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ming-Syan+Chen%22">Ming-Syan Chen</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hui-I+Hsiao%22">Hui-I Hsiao</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu%22">Philip S. Yu</a></li></ol>
          <input type="checkbox" id="25405"/>
          <label for="25405">Abstract</label>
          <div>In this paper, we explore an approach of interleaving a bushy execution tree with hash filters to improve the execution of multi-join queries. Similar to semi-joins in distributed query processing, hash filters can be applied to eliminate non-matching tuples from joining relations before the execution of a join, thus reducing the join cost. Note that hash filters built in different execution stages of a bushy tree can have different costs and effects. The effect of hash filters is evaluat ed first. Then, an efficient scheme to determine an effective sequence of hash filters for a bushy execution tree is developed, where hash filters are built and applied based on the join sequence specified in the bushy tree so that not only is the reduction effect optimized but also the cost associated is minimized. Various schemes using hash filters are implemented and evaluated via simulation. It is experimentally shown that the application of hash filters is in general a very powerful means to improve th e execution of multi-join queries, and the improvement becomes more prominent as the number of relations in a query increases.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050037">Parametric query optimization</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050037.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yannis+E.+Ioannidis%22">Yannis E. Ioannidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Raymond+T.+Ng%22">Raymond T. Ng</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kyuseok+Shim%22">Kyuseok Shim</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+K.+Sellis%22">Timos K. Sellis</a></li></ol>
          <input type="checkbox" id="24096"/>
          <label for="24096">Abstract</label>
          <div>In most database systems, the values of many important run-time parameters of the system, the data, or the query are unknown at query optimization time. Parametric query optimization attempts to identify at compile time several execution plans, each one of which is optimal for a subset of all possible values of the run-time parameters. The goal is that at run time, when the actual parameter values are known, the appropriate plan should be identifiable with essentially no overhead. We present a general formulation of this problem and study it primarily for the buffer size parameter. We adopt randomized algorithms as the main approach to this style of optimization and enhance them with a sideways information passing feature that increases their effectiveness in the new task. Experimental results of these enhanced algorithms show that they optimize queries for large numbers of buffer sizes in the same time needed by their conventional versions for a single buffer size, without much sacrifice in the output quality and with essentially zero run-time overhead.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050038">Concurrency control in hierarchical multidatabase systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050038.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Sharad+Mehrotra%22">Sharad Mehrotra</a></li><li><a href="http://link.springer.com/search?facet-author=%22Henry+F.+Korth%22">Henry F. Korth</a></li><li><a href="http://link.springer.com/search?facet-author=%22Avi+Silberschatz%22">Avi Silberschatz</a></li></ol>
          <input type="checkbox" id="18438"/>
          <label for="18438">Abstract</label>
          <div>Over the past decade, significant research has been done towards developing transaction management algorithms for multidatabase systems. Most of this work assumes a monolithic architecture of the multidatabase system with a single software module that follows a single transaction management algorithm to ensure the consistency of data stored in the local databases. This monolithic architecture is not appropriate in a multidatabase environment where the system spans multiple different organizations that are distributed over various geographically distant locations. In this paper, we propose an alternative multidatabase transaction management architecture, where the system is hierarchical in nature. Hierarchical architecture has consequences on the design of transaction management algorithms. An implication of the architecture is that the transaction management algorithms followed by a multidatabase system must be composable– that is, it must be possible to incorporate individual multidatabase systems as elements in a larger multidatabase system. We present a hierarchical architecture for a multidatabase environment and develop techniques for concurrency control in such systems.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (February 1997)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050030">The hB $^\Pi$ -tree: a multi-attribute index supporting concurrency, recovery and node consolidation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050030.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Georgios+Evangelidis%22">Georgios Evangelidis</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Lomet%22">David Lomet</a></li><li><a href="http://link.springer.com/search?facet-author=%22Betty+Salzberg%22">Betty Salzberg</a></li></ol>
          <input type="checkbox" id="92900"/>
          <label for="92900">Abstract</label>
          <div>We propose a new multi-attribute index. Our approach combines the hB-tree, a multi-attribute index, and the $\Pi$ -tree, an abstract index which offers efficient concurrency and recovery methods. We call the resulting method the hB $^\Pi$ -tree. We describe several versions of the hB $^\Pi$ -tree, each using a different node-splitting and index-term-posting algorithm. We also describe a new node deletion algorithm. We have implemented all the versions of the hB $^\Pi$ -tree. Our performance results show that even the version that offers no performance guarantees, actually performs very well in terms of storage utilization, index size (fan-out), exact-match and range searching, under various data types and distributions. We have also shown that our index is fairly insensitive to increases in dimension. Thus, it is suitable for indexing high-dimensional applications. This property and the fact that all our versions of the hB $^\Pi$ -tree can use the $\Pi$ -tree concurrency and recovery algorithms make the hB $^\Pi$ -tree a promising candidate for inclusion in a general-purpose DBMS.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050031">Dictionary-based order-preserving string compression</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050031.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gennady+Antoshenkov%22">Gennady Antoshenkov</a></li></ol>
          <input type="checkbox" id="84110"/>
          <label for="84110">Abstract</label>
          <div>As no database exists without indexes, no index implementation exists without order-preserving key compression, in particular, without prefix and tail compression. However, despite the great potentials of making indexes smaller and faster, application of general compression methods to ordered data sets has advanced very little. This paper demonstrates that the fast dictionary-based methods can be applied to order-preserving compression almost with the same freedom as in the general case. The proposed new technology has the same speed and a compression rate only marginally lower than the traditional order-indifferent dictionary encoding. Procedures for encoding and generating the encode tables are described covering such order-related features as ordered data set restrictions, sensitivity and insensitivity to a character position, and one-symbol encoding of each frequent trailing character sequence. The experimental results presented demonstrate five-folded compression on real-life data sets and twelve-folded compression on Wisconsin benchmark text fields.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050032">Analysis of locking behavior in three real database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050032.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vigyan+Singhal%22">Vigyan Singhal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Alan+Jay+Smith%22">Alan Jay Smith</a></li></ol>
          <input type="checkbox" id="87779"/>
          <label for="87779">Abstract</label>
          <div>Concurrency control is essential to the correct functioning of a database due to the need for correct, reproducible results. For this reason, and because concurrency control is a well-formulated problem, there has developed an enormous body of literature studying the performance of concurrency control algorithms. Most of this literature uses either analytic modeling or random number-driven simulation, and explicitly or implicitly makes certain assumptions about the behavior of transactions and the patterns by which they set and unset locks. Because of the difficulty of collecting suitable measurements, there have been only a few studies which use trace-driven simulation, and still less study directed toward the characterization of concurrency control behavior of real workloads. In this paper, we present a study of three database workloads, all taken from IBM DB2 relational database systems running commercial applications in a production environment. This study considers topics such as frequency of locking and unlocking, deadlock and blocking, duration of locks, types of locks, correlations between applications of lock types, two-phase versus non-two-phase locking, when locks are held and released, etc. In each case, we evaluate the behavior of the workload relative to the assumptions commonly made in the research literature and discuss the extent to which those assumptions may or may not lead to erroneous conclusions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050033">Data placement in shared-nothing parallel database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050033.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Manish+Mehta%22">Manish Mehta</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+J.+DeWitt%22">David J. DeWitt</a></li></ol>
          <input type="checkbox" id="41450"/>
          <label for="41450">Abstract</label>
          <div>Data placement in shared-nothing database systems has been studied extensively in the past and various placement algorithms have been proposed. However, there is no consensus on the most efficient data placement algorithm and placement is still performed manually by a database administrator with periodic reorganization to correct mistakes. This paper presents the first comprehensive simulation study of data placement issues in a shared-nothing system. The results show that current hardware technology trends have significantly changed the performance tradeoffs considered in past studies. A simplistic data placement strategy based on the new results is developed and shown to perform well for a variety of workloads.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 5 (January 1996 - December 1996)</h1>
          <ol><li>
          <h2>Issue 4 (December 1996)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050026">Query processing and optimization in Oracle Rdb</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050026.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gennady+Antoshenkov%22">Gennady Antoshenkov</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+Ziauddin%22">Mohamed Ziauddin</a></li></ol>
          <input type="checkbox" id="50875"/>
          <label for="50875">Abstract</label>
          <div>This paper contains an overview of the technology used in the query processing and optimization component of Oracle Rdb, a relational database management system originally developed by Digital Equipment Corporation and now under development by Oracle Corporation. Oracle Rdb is a production system that supports the most demanding database applications, runs on multiple platforms and in a variety of environments.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050027">Building knowledge base management systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050027.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22John+Mylopoulos%22">John Mylopoulos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vinay+Chaudhri%22">Vinay Chaudhri</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Plexousakis%22">Dimitris Plexousakis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Adel+Shrufi%22">Adel Shrufi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Thodoros+Topologlou%22">Thodoros Topologlou</a></li></ol>
          <input type="checkbox" id="74493"/>
          <label for="74493">Abstract</label>
          <div>Advanced applications in fields such as CAD, software engineering, real-time process control, corporate repositories and digital libraries require the construction, efficient access and management of large, shared knowledge bases. Such knowledge bases cannot be built using existing tools such as expert system shells, because these do not scale up, nor can they be built in terms of existing database technology, because such technology does not support the rich representational structure and inference mechanisms required for knowledge-based systems. This paper proposes a generic architecture for a knowledge base management system intended for such applications. The architecture assumes an object-oriented knowledge representation language with an assertional sublanguage used to express constraints and rules. It also provides for general-purpose deductive inference and special-purpose temporal reasoning. Results reported in the paper address several knowledge base management issues. For storage management, a new method is proposed for generating a logical schema for a given knowledge base. Query processing algorithms are offered for semantic and physical query optimization, along with an enhanced cost model for query cost estimation. On concurrency control, the paper describes a novel concurrency control policy which takes advantage of knowledge base structure and is shown to outperform two-phase locking for highly structured knowledge bases and update-intensive transactions. Finally, algorithms for compilation and efficient processing of constraints and rules during knowledge base operations are described. The paper describes original results, including novel data structures and algorithms, as well as preliminary performance evaluation data. Based on these results, we conclude that knowledge base management systems which can accommodate large knowledge bases are feasible.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050028">An asymptotically optimal multiversion B-tree</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050028.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Bruno+Becker%22">Bruno Becker</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stephan+Gschwind%22">Stephan Gschwind</a></li><li><a href="http://link.springer.com/search?facet-author=%22Thomas+Ohler%22">Thomas Ohler</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bernhard+Seeger%22">Bernhard Seeger</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+Widmayer%22">Peter Widmayer</a></li></ol>
          <input type="checkbox" id="90924"/>
          <label for="90924">Abstract</label>
          <div>In a variety of applications, we need to keep track of the development of a data set over time. For maintaining and querying these multiversion data efficiently, external storage structures are an absolute necessity. We propose a multiversion B-tree that supports insertions and deletions of data items at the current version and range queries and exact match queries for any version, current or past. Our multiversion B-tree is asymptotically optimal in the sense that the time and space bounds are asymptotically the same as those of the (single-version) B-tree in the worst case. The technique we present for transforming a (single-version) B-tree into a multiversion B-tree is quite general: it applies to a number of hierarchical external access structures with certain properties directly, and it can be modified for others.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050029">Semantic and schematic similarities between database objects: a context-based approach</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050029.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vipul+Kashyap%22">Vipul Kashyap</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amit+Sheth%22">Amit Sheth</a></li></ol>
          <input type="checkbox" id="67772"/>
          <label for="67772">Abstract</label>
          <div>In a multidatabase system, schematic conflicts between two objects are usually of interest only when the objects have some semantic similarity. We use the concept of semantic proximity, which is essentially an abstraction/mapping between the domains of the two objects associated with the context of comparison. An explicit though partial context representation is proposed and the specificity relationship between contexts is defined. The contexts are organized as a meet semi-lattice and associated operations like the greatest lower bound are defined. The context of comparison and the type of abstractions used to relate the two objects form the basis of a semantic taxonomy. At the semantic level, the intensional description of database objects provided by the context is expressed using description logics. The terms used to construct the contexts are obtained from {\em domain-specific ontologies}. Schema correspondences are used to store mappings from the semantic level to the data level and are associated with the respective contexts. Inferences about database content at the federation level are modeled as changes in the context and the associated schema correspondences. We try to reconcile the dual (schematic and semantic) perspectives by enumerating possible semantic similarities between objects having schema and data conflicts, and modeling schema correspondences as the projection of semantic proximity with respect to (wrt) context.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (August 1996)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050022">A complete temporal relational algebra</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050022.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Debabrata+Dey%22">Debabrata Dey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Terence+M.+Barron%22">Terence M. Barron</a></li><li><a href="http://link.springer.com/search?facet-author=%22Veda+C.+Storey%22">Veda C. Storey</a></li></ol>
          <input type="checkbox" id="50015"/>
          <label for="50015">Abstract</label>
          <div>Various temporal extensions to the relational model have been proposed. All of these, however, deviate significantly from the original relational model. This paper presents a temporal extension of the relational algebra that is not significantly different from the original relational model, yet is at least as expressive as any of the previous approaches. This algebra employs multidimensional tuple time-stamping to capture the complete temporal behavior of data. The basic relational operations are redefined as consistent extensions of the existing operations in a manner that preserves the basic algebraic equivalences of the snapshot (i.e., conventional static) algebra. A new operation, namely temporal projection, is introduced. The complete update semantics are formally specified and aggregate functions are defined. The algebra is closed, and reduces to the snapshot algebra. It is also shown to be at least as expressive as the calculus-based temporal query language TQuel. In order to assess the algebra, it is evaluated using a set of twenty-six criteria proposed in the literature, and compared to existing temporal relational algebras. The proposed algebra appears to satisfy more criteria than any other existing algebra.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050023">The design and implementation of K: a high-level knowledge-base programming language of OSAM*.KBMS</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050023.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yuh-Ming+Shyy%22">Yuh-Ming Shyy</a></li><li><a href="http://link.springer.com/search?facet-author=%22Javier+Arroyo%22">Javier Arroyo</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stanley+Y.W.+Su%22">Stanley Y.W. Su</a></li><li><a href="http://link.springer.com/search?facet-author=%22Herman+Lam%22">Herman Lam</a></li></ol>
          <input type="checkbox" id="16221"/>
          <label for="16221">Abstract</label>
          <div>The OSAM*.KBMS is a knowledge-base management system, or the so-called next-generation database management system, for non-traditional data/knowledge-intensive applications. In order to define, query, and manipulate a knowledge base, as well as to write codes to implement any application system, we have developed an object-oriented knowledge-base programming language called K to serve as the high-level interface of OSAM*.KBMS. This paper presents the design of K, its implementation, and its supporting KBMS developed at the Database Systems Research and Development Center of the University of Florida.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050024">Access path support for referential integrity in SQL2</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050024.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Theo+H%C3%A4rder%22">Theo Härder</a></li><li><a href="http://link.springer.com/search?facet-author=%22Joachim+Reinert%22">Joachim Reinert</a></li></ol>
          <input type="checkbox" id="70504"/>
          <label for="70504">Abstract</label>
          <div>The relational model of data incorporates fundamental assertions for entity integrity and referential integrity. Recently, these so-called relational invariants were more precisely specified by the new SQL2 standard. Accordingly, they have to be guaranteed by a relational DBMS to its users and, therefore, all issues of semantics and implementation became very important. The specification of referential integrity embodies quite a number of complications including the MATCH clause and a collection of referential actions. In particular, $\hbox{{\tt MATCH PARTIAL}}$ turns out to be hard to understand and, if applied, difficult and expensive to maintain. In this paper, we identify the functional requirements for preserving referential integrity. At a level free of implementational considerations, the number and kinds of searches necessary for referential integrity maintenance are derived. Based on these findings, our investigation is focused on the question of how the functional requirements can be supported by implementation concepts in an efficient way. We determine the search cost for referential integrity maintenance (in terms of page references) for various possible access path structures. Our main result is that a combined access path structure is the most appropriatefor checking the regular MATCH option, whereas $\hbox{{\tt MATCH PARTIAL}}$ requires very expensive and complicated check procedures. If it cannot be avoided at all, the best support is achieved by a combination of multiple $\mbox{B}^*$ -trees.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050025">Index nesting – an efficient approach to indexing in object-oriented databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050025.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Beng+Chin+Ooi%22">Beng Chin Ooi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jiawei+Han%22">Jiawei Han</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hongjun+Lu%22">Hongjun Lu</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kian+Lee+Tan%22">Kian Lee Tan</a></li></ol>
          <input type="checkbox" id="8997"/>
          <label for="8997">Abstract</label>
          <div>In object-oriented database systems where the concept of the superclass-subclass is supported, an instance of a subclass is also an instance of its superclass. Consequently, the access scope of a query against a class in general includes the access scope of all its subclasses, unless specified otherwise. An index to support superclass-subclass relationship efficiently must provide efficient associative retrievals of objects from a single class or from several classes in a class hierarchy. This paper presents an efficient index called the hierarchical tree (the H-tree). For each class, an H-tree is maintained, allowing efficient search on a single class. These H-trees are appropriately linked to capture the superclass-subclass relationships, thus allowing efficient retrievals of instances from a class hierarchy. Both experimental and analytical results indicate that the H-tree is an efficient indexing structure.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 1996)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050018">The GMAP: a versatile tool for physical data independence</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050018.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Odysseas+G.+Tsatalos%22">Odysseas G. Tsatalos</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marvin+H.+Solomon%22">Marvin H. Solomon</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+E.+Ioannidis%22">Yannis E. Ioannidis</a></li></ol>
          <input type="checkbox" id="82536"/>
          <label for="82536">Abstract</label>
          <div>Physical data independence is touted as a central feature of modern database systems. It allows users to frame queries in terms of the logical structure of the data, letting a query processor automatically translate them into optimal plans that access physical storage structures. Both relational and object-oriented systems, however, force users to frame their queries in terms of a logical schema that is directly tied to physical structures. We present an approach that eliminates this dependence. All storage structures are defined in a declarative language based on relational algebra as functions of a logical schema. We present an algorithm, integrated with a conventional query optimizer, that translates queries over this logical schema into plans that access the storage structures. We also show how to compile update requests into plans that update all relevant storage structures consistently and optimally. Finally, we report on experiments with a prototype implementation of our approach that demonstrate how it allows storage structures to be tuned to the expected or observed workload to achieve significantly better performance than is possible with conventional techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050019">Algebraic query optimisation for database programming languages</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050019.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alexandra+Poulovassilis%22">Alexandra Poulovassilis</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carol+Small%22">Carol Small</a></li></ol>
          <input type="checkbox" id="48189"/>
          <label for="48189">Abstract</label>
          <div>A major challenge still facing the designers and implementors of database programming languages (DBPLs) is that of query optimisation. We investigate algebraic query optimisation techniques for DBPLs in the context of a purely declarative functional language that supports sets as first-class objects. Since the language is computationally complete issues such as non-termination of expressions and construction of infinite data structures can be investigated, whilst its declarative nature allows the issue of side effects to be avoided and a richer set of equivalences to be developed. The language has a well-defined semantics which permits us to reason formally about the properties of expressions, such as their equivalence with other expressions and their termination. The support of a set bulk data type enables much prior work on the optimisation of relational languages to be utilised. In the paper we first give the syntax of our archetypal DBPL and briefly discuss its semantics. We then define a small but powerful algebra of operators over the set data type, provide some key equivalences for expressions in these operators, and list transformation principles for optimising expressions. Along the way, we identify some caveats to well-known equivalences for non-deductive database languages. We next extend our language with two higher level constructs commonly found in functional DBPLs: set comprehensions and functions with known inverses. Some key equivalences for these constructs are provided, as are transformation principles for expressions in them. Finally, we investigate extending our equivalences for the set operators to the analogous operators over bags. Although developed and formally proved in the context of a functional language, our findings are directly applicable to other DBPLs of similar expressiveness.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050020">Type-safe relaxing of schema consistency rules for flexible modelling in OODBMS</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050020.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Eric+Amiel%22">Eric Amiel</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marie-Jo+Bellosta%22">Marie-Jo Bellosta</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eric+Dujardin%22">Eric Dujardin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Eric+Simon%22">Eric Simon</a></li></ol>
          <input type="checkbox" id="17686"/>
          <label for="17686">Abstract</label>
          <div>Object-oriented databases enforce behavioral schema consistency rules to guarantee type safety, i.e., that no run-time type error can occur. When the schema must evolve, some schema updates may violate these rules. In order to maintain behavioral schema consistency, traditional solutions require significant changes to the types, the type hierarchy and the code of existing methods. Such operations are very expensive in a database context. To ease schema evolution, we propose to support exceptions to the behavioral consistency rules without sacrificing type safety. The basic idea is to detect unsafe statements in a method code at compile-time and check them at run-time. The run-time check is performed by a specific clause that is automatically inserted around unsafe statements. This check clause warns the programmer of the safety problem and lets him provide exception-handling code. Schema updates can therefore be performed with only minor changes to the code of methods.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050021">An experimental object-based sharing system for networked databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050021.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Doug+Fang%22">Doug Fang</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shahram+Ghandeharizadeh%22">Shahram Ghandeharizadeh</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dennis+McLeod%22">Dennis McLeod</a></li></ol>
          <input type="checkbox" id="41107"/>
          <label for="41107">Abstract</label>
          <div>An approach and mechanism for the transparent sharing of objects in an environment of interconnected (networked), autonomous database systems is presented. An experimental prototype system has been designed and implemented, and an analysis of its performance conducted. Previous approaches to sharing in this environment typically rely on the use of a global, integrated conceptual database schema; users and applications must pose queries at this new level of abstraction to access remote information. By contrast, our approach provides a mechanism that allows users to import remote objects directly into their local database transparently; access to remote objects is virtually the same as access to local objects. The experimental prototype system that has been designed and implemented is based on the Iris and Omega object-based database management systems; this system supports the sharing of data and meta-data objects (information units) as well as units of behavior. The results of experiments conducted to evaluate the performance of our mechanism demonstrate the feasibility of database transparent object sharing in a federated environment, and provide insight into the performance overhead and tradeoffs involved.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 1996)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050012">Parallelizing OODBMS traversals: a performance evaluation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050012.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22David+J.+De+Witt%22">David J. De Witt</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeffrey+F.+Naughton%22">Jeffrey F. Naughton</a></li><li><a href="http://link.springer.com/search?facet-author=%22John+C.+Shafer%22">John C. Shafer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shivakumar+Venkataraman%22">Shivakumar Venkataraman</a></li></ol>
          <input type="checkbox" id="33145"/>
          <label for="33145">Abstract</label>
          <div>In this paper we describe the design and implementation of ParSets, a means of exploiting parallelism in the SHORE OODBMS. We used ParSets to parallelize the graph traversal portion of the OO7 OODBMS benchmark, and present speedup and scaleup results from parallel SHORE running these traversals on a cluster of commodity workstations connected by a standard ethernet. For some OO7 traversals, SHORE achieved excellent speedup and scaleup; for other OO7 traversals, only marginal speedup and scaleup occurred. The characteristics of these traversals shed light on when the ParSet approach to parallelism can and cannot be applied to speed up an application.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050013">Priority assignment in real-time active databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050013.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Rajendran+M.+Sivasankaran%22">Rajendran M. Sivasankaran</a></li><li><a href="http://link.springer.com/search?facet-author=%22John+A.+Stankovic%22">John A. Stankovic</a></li><li><a href="http://link.springer.com/search?facet-author=%22Don+Towsley%22">Don Towsley</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bhaskar+Purimetla%22">Bhaskar Purimetla</a></li><li><a href="http://link.springer.com/search?facet-author=%22Krithi+Ramamritham%22">Krithi Ramamritham</a></li></ol>
          <input type="checkbox" id="55862"/>
          <label for="55862">Abstract</label>
          <div>Active databases and real-time databases have been important areas of research in the recent past. It has been recognized that many benefits can be gained by integrating real-time and active database technologies. However, not much work has been done in the area of transaction processing in real-time active databases. This paper deals with an important aspect of transaction processing in real-time active databases, namely the problem of assigning priorities to transactions. In these systems, time-constrained transactions trigger other transactions during their execution. We present three policies for assigning priorities to parent, immediate and deferred transactions executing on a multiprocessor system and then evaluate the policies through simulation. The policies use different amounts of semantic information about transactions to assign the priorities. The simulator has been validated against the results of earlier published studies. We conducted experiments in three settings: a task setting, a main memory database setting and a disk-resident database setting. Our results demonstrate that dynamically changing the priorities of transactions, depending on their behavior (triggering rules), yields a substantial improvement in the number of triggering transactions that meet their deadline in all three settings.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050014">A predicate-based caching scheme for client-server database architectures</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050014.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Arthur+M.+Keller%22">Arthur M. Keller</a></li><li><a href="http://link.springer.com/search?facet-author=%22Julie+Basu%22">Julie Basu</a></li></ol>
          <input type="checkbox" id="86215"/>
          <label for="86215">Abstract</label>
          <div>We propose a new client-side data-caching scheme for relational databases with a central server and multiple clients. Data are loaded into each client cache based on queries executed on the central database at the server. These queries are used to form predicates that describe the cache contents. A subsequent query at the client may be satisfied in its local cache if we can determine that the query result is entirely contained in the cache. This issue is called cache completeness. A separate issue, cache currency, deals with the effect on client caches of updates committed at the central database. We examine the various performance tradeoffs and optimization issues involved in addressing the questions of cache currency and completeness using predicate descriptions and suggest solutions that promote good dynamic behavior. Lower query-response times, reduced message traffic, higher server throughput, and better scalability are some of the expected benefits of our approach over commonly used relational server-side and object ID-based or page-based client-side caching.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050015">Mariposa: a wide-area distributed database system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050015.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Michael+Stonebraker%22">Michael Stonebraker</a></li><li><a href="http://link.springer.com/search?facet-author=%22Paul+M.+Aoki%22">Paul M. Aoki</a></li><li><a href="http://link.springer.com/search?facet-author=%22Witold+Litwin%22">Witold Litwin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Avi+Pfeffer%22">Avi Pfeffer</a></li><li><a href="http://link.springer.com/search?facet-author=%22Adam+Sah%22">Adam Sah</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeff+Sidell%22">Jeff Sidell</a></li><li><a href="http://link.springer.com/search?facet-author=%22Carl+Staelin%22">Carl Staelin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Andrew+Yu%22">Andrew Yu</a></li></ol>
          <input type="checkbox" id="74932"/>
          <label for="74932">Abstract</label>
          <div>The requirements of wide-area distributed database systems differ dramatically from those of local-area network systems. In a wide-area network (WAN) configuration, individual sites usually report to different system administrators, have different access and charging algorithms, install site-specific data type extensions, and have different constraints on servicing remote requests. Typical of the last point are production transaction environments, which are fully engaged during normal business hours, and cannot take on additional load. Finally, there may be many sites participating in a WAN distributed DBMS. In this world, a single program performing global query optimization using a cost-based optimizer will not work well. Cost-based optimization does not respond well to site-specific type extension, access constraints, charging algorithms, and time-of-day constraints. Furthermore, traditional cost-based distributed optimizers do not scale well to a large number of possible processing sites. Since traditional distributed DBMSs have all used cost-based optimizers, they are not appropriate in a WAN environment, and a new architecture is required. We have proposed and implemented an economic paradigm as the solution to these issues in a new distributed DBMS called Mariposa. In this paper, we present the architecture and implementation of Mariposa and discuss early feedback on its operating characteristics.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050016">Join algorithm costs revisited</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050016.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Evan+P.+Harris%22">Evan P. Harris</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kotagiri+Ramamohanarao%22">Kotagiri Ramamohanarao</a></li></ol>
          <input type="checkbox" id="43230"/>
          <label for="43230">Abstract</label>
          <div>A method of analysing join algorithms based upon the time required to access, transfer and perform the relevant CPU-based operations on a disk page is proposed. The costs of variations of several of the standard join algorithms, including nested block, sort-merge, GRACE hash and hybrid hash, are presented. For a given total buffer size, the cost of these join algorithms depends on the parts of the buffer allocated for each purpose. For example, when joining two relations using the nested block join algorithm, the amount of buffer space allocated for the outer and inner relations can significantly affect the cost of the join. Analysis of expected and experimental results of various join algorithms show that a combination of the optimal nested block and optimal GRACE hash join algorithms usually provide the greatest cost benefit, unless the relation size is a small multiple of the memory size. Algorithms to quickly determine a buffer allocation producing the minimal cost for each of these algorithms are presented. When the relation size is a small multiple of the amount of main memory available (typically up to three to six times), the hybrid hash join algorithm is preferable.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/s007780050017">A taxonomy of correctness criteria in database applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2Fs007780050017.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Krithi+Ramamritham%22">Krithi Ramamritham</a></li><li><a href="http://link.springer.com/search?facet-author=%22Panos+K.+Chrysanthis%22">Panos K. Chrysanthis</a></li></ol>
          <input type="checkbox" id="24580"/>
          <label for="24580">Abstract</label>
          <div>Whereas serializability captures database consistency requirements and transaction correctness properties via a single notion, recent research has attempted to come up with correctness criteria that view these two types of requirements independently. The search for more flexible correctness criteria is partily motivated by the introduction of new transaction models that extend the traditional atomic transaction model. These extensions came about because the atomic transaction model in conjunction with serializability is found to be very constraining when used in advanced applications (e.g., design databases) that function in distributed, cooperative, and heterogeneous environments. In this article we develop a taxonomy of various correctness criteria that focus on database consistency requirements and transaction correctness properties from the viewpoint of what the different dimensions of these two are. This taxonomy allows us to categorize correctness criteria that have been proposed in the literature. To help in this categorization, we have applied a uniform specification technique, based on ACTA, to express the various criteria. Such a categorization helps shed light on the similarities and differences between different criteria and places them in perspective.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 4 (January 1995 - October 1995)</h1>
          <ol><li>
          <h2>Issue 4 (October 1995)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01354875">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01354875.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Stanley+Y.+W.+Su%22">Stanley Y. W. Su</a></li></ol>
          <input type="checkbox" id="60463"/>
          <label for="60463">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01354876">Sleepers and workaholics: Caching strategies in mobile environments (Extended version)</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01354876.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniel+Barbar%C3%A1+Ph.D.%22">Daniel Barbará Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tomasz+Imieli%C5%84ski+Ph.D.%22">Tomasz Imieliński Ph.D.</a></li></ol>
          <input type="checkbox" id="69531"/>
          <label for="69531">Abstract</label>
          <div>In the mobile wireless computing environment of the future, a large number of users, equipped with low-powered palmtop machines, will query databases over wireless communication channels. Palmtop-based units will often be disconnected for prolonged periods of time, due to battery power saving measures; palmtops also will frequently relocate between different cells, and will connect to different data servers at different times. Caching of frequently accessed data items will be an important technique that will reduce contention on the narrow-bandwidth, wireless channel. However, cache individualization strategies will be severely affected by the disconnection and mobility of the clients. The server may no longer know which clients are currently residing under its cell, and which of them are currently on. We propose a taxonomy of different cache invalidation strategies, and study the impact of clients' disconnection times on their performance. We study ways to improve further the efficiency of the invalidation techniques described. We also describe how our techniques can be implemented over different network environments.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01354877">Alphasort: A cache-sensitive parallel external sort</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01354877.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chris+Nyberg+M.S.%22">Chris Nyberg M.S.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tom+Barclay+B.S.%22">Tom Barclay B.S.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zarka+Cvetanovic+Ph.D.%22">Zarka Cvetanovic Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jim+Gray+Ph.D.%22">Jim Gray Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dave+Lomet%22">Dave Lomet</a></li></ol>
          <input type="checkbox" id="4517"/>
          <label for="4517">Abstract</label>
          <div>A new sort algorithm, called AlphaSort, demonstrates that commodity processors and disks can handle commercial batch workloads. Using commodity processors, memory, and arrays of SCSI disks, AlphaSort runs the industrystandard sort benchmark in seven seconds. This beats the best published record on a 32-CPU 32-disk Hypercube by 8:1. On another benchmark, AlphaSort sorted more than a gigabyte in one minute. AlphaSort is a cache-sensitive, memoryintensive sort algorithm. We argue that modern architectures require algorithm designers to re-examine their use of the memory hierarchy. AlphaSort uses clustered data structures to get good cache locality, file striping to get high disk bandwidth, QuickSort to generate runs, and replacement-selection to merge the runs. It uses shared memory multiprocessors to break the sort into subsort chores. Because startup times are becoming a significant part of the total time, we propose two new benchmarks: (1) MinuteSort: how much can you sort in one minute, and (2) PennySort: how much can you sort for one penny.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01354878">QuickStore: A high performance mapped object store</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01354878.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Seth+J.+White+Ph.D.%22">Seth J. White Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+J.+DeWitt+Ph.D.%22">David J. DeWitt Ph.D.</a></li></ol>
          <input type="checkbox" id="79698"/>
          <label for="79698">Abstract</label>
          <div>QuickStore is a memory-mapped storage system for persistent C++, built on top of the EXODUS Storage Manager. QuickStore provides fast access to in-memory objects by allowing application programs to access objects via normal virtual memory pointers. This article presents the results of a detailed performance study using the OO7 benchmark. The study compares the performance of QuickStore with the latest implementation of the E programming language. The QuickStore and E systems exemplify the two basic approaches (hardware and soft-ware) that have been used to implement persistence in object-oriented database systems. In addition, both systems use the same underlying storage manager and compiler, allowing us to make a truly apples-to-apples comparison of the hardware and software techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01354879">Estimating page fetches for index scans with finite LRU buffers</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01354879.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Arun+Swami+Ph.D.%22">Arun Swami Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22K.+Bernhard+Schiefer+B.S.%22">K. Bernhard Schiefer B.S.</a></li></ol>
          <input type="checkbox" id="78411"/>
          <label for="78411">Abstract</label>
          <div>We describe an algorithm for estimating the number of page fetches for a partial or complete scan of a B-tree index. The algorithm obtains estimates for the number of page fetches for an index scan when given the number of tuples selected and the number of LRU buffers currently available. The algorithm has an initial phase that is performed exactly once before any estimates are calculated. This initial phase, involving LRU buffer modeling, requires a scan of all the index entries and calculates the number of page fetches for different buffer sizes. An approximate empirical model is obtained from this data. Subsequently, an inexpensive estimation procedure is called by the query optimizer whenever it needs an estimate of the page fetches for the index scan. This procedure utilizes the empirical model obtained in the initial phase.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01354880">Historical queries along multiple lines of time evolution</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01354880.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gad+M.+Landau+Ph.D.%22">Gad M. Landau Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jeanette+P.+Schmidt+Ph.D.%22">Jeanette P. Schmidt Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Vassilis+J.+Tsotras+Ph.D.%22">Vassilis J. Tsotras Ph.D.</a></li></ol>
          <input type="checkbox" id="32928"/>
          <label for="32928">Abstract</label>
          <div>Traditional approaches to addressing historical queries assume asingle line of time evolution; that is, a system (database, relation) evolves over time through a sequence of transactions. Each transaction always applies to the unique, current state of the system, resulting in a new current state. There are, however, complex applications where the system's state evolves intomultiple lines of evolution. In general, this creates a tree (hierarchy) of evolution lines, where each tree node represents the time evolution of a particular subsystem. Multiple lines create novel historical queries, such asvertical orhorizontal historical queries. The key characteristic of these problems is that portions of the history are shared; answering historical queries should not necessitate duplication of shared histories as this could increase the storage requirements dramatically. Both the vertical and horizontal historical queries have two parts: a “search” part, where the time of interest is located together with the appropriate subsystem, and a reconstruction part, where the subsystem's state is reconstructed for that time. This article focuses on the search part; several reconstruction methods, designed for single evolution lines can be applied once the appropriate time of interest is located. For both the vertical and the horizontal historical queries, we present algorithms that work without duplicating shared histories. Combinations of the vertical and horizontal queries are possible, and enable searching in both dimensions of the tree of evolutions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01354881">The power of languages for the manipulation of complex values</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01354881.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Prof.+Dr.+Serge+Abiteboul%22">Prof. Dr. Serge Abiteboul</a></li><li><a href="http://link.springer.com/search?facet-author=%22Prof.+Dr.+Catriel+Beeri%22">Prof. Dr. Catriel Beeri</a></li></ol>
          <input type="checkbox" id="54806"/>
          <label for="54806">Abstract</label>
          <div>Various models and languages for describing and manipulating hierarchically structured data have been proposed. Algebraic, calculus-based, and logic-programming oriented languages have all been considered. This article presents a general model for complex values (i.e., values with hierarchical structures), and languages for it based on the three paradigms. The algebraic language generalizes those presented in the literature; it is shown to be related to the functional, style of programming advocated by Backus (1978). The notion of domain independence (from relational databases) is defined, and syntactic restrictions (referred to as safety conditions) on calculus queries are formulated to guarantee domain independence. The main results are: The domain-independent calculus, the safe calculus, the algebra, and the logic-programming oriented language have equivalent expressive power. In particular, recursive queries, such as the transitive closure, can be expressed in each of the languages. For this result, the algebra needs the powerset operation. A more restricted version of safety is presented, such that the restricted safe calculus is equivalent to the algebra without the powerset. The results are extended to the case where arbitrary functions and predicates are used in the languages.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (July 1995)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231641">Preface to special issue on persistent object systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231641.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Malcolm+Atkinson%22">Malcolm Atkinson</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ronald+Morrison%22">Ronald Morrison</a></li></ol>
          <input type="checkbox" id="36558"/>
          <label for="36558">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231642">Orthogonally persistent object systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231642.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Malcolm+Atkinson+Ph.D.%22">Malcolm Atkinson Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ronald+Morrison+Ph.D.%22">Ronald Morrison Ph.D.</a></li></ol>
          <input type="checkbox" id="40270"/>
          <label for="40270">Abstract</label>
          <div>Persistent Application Systems (PASs) are of increasing social and economic importance. They have the potential to be long-lived, concurrently accessed, and consist of large bodies of data and programs. Typical examples of PASs are CAD/CAM systems, office automation, CASE tools, software engineering environments, and patient-care support systems in hospitals. Orthogonally persistent object systems are intended to provide improved support for the design, construction, maintenance, and operation of PASs. Persistence abstraction allows the creation and manipulation of data in a manner, that is independent of its lifetime, thereby integrating the database view of information with the programming language view. This yields a number of advantages in terms of orthogonal design and programmer productivity which are beneficial for PASs. Design principles have been proposed for persistent systems. By following these principles, languages that provide persistence as a basic abstraction have been developed. In this paper, the motivation for orthogonal persistence is reviewed along with the above mentioned design principles. The concepts for integrating programming languages and databases through the persistence abstraction, and their benefits, are given. The technology to support persistence, the achievements, and future directions of persistence research are then discussed.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231643">Fibonacci: A programming language for object databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231643.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Antonio+Albano+Dott.+Ing.%22">Antonio Albano Dott. Ing.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Giorgio+Ghelli+Ph.D.%22">Giorgio Ghelli Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Renzo+Orsini+Dott.%22">Renzo Orsini Dott.</a></li></ol>
          <input type="checkbox" id="63300"/>
          <label for="63300">Abstract</label>
          <div>Fibonacci is an object-oriented database programming language characterized by static and strong typing, and by new mechanisms for modeling data-bases in terms of objects with roles, classes, and associations. A brief introduction to the language is provided to present those features, which are particularly suited to modeling complex databases. Examples of the use of Fibonacci are given with reference to the prototype implementation of the language.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231644">TIGUKAT: A uniform behavioral objectbase management system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231644.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22M.+Tamer+%C3%96zsu+Ph.D.%22">M. Tamer Özsu Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Randal+Peters+Ph.D.%22">Randal Peters Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Duane+Szafron+Ph.D.%22">Duane Szafron Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Boman+Irani+M.Sc.%22">Boman Irani M.Sc.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anna+Lipka+M.Sc.%22">Anna Lipka M.Sc.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Adriana+Mu%C3%B1oz+M.Sc.%2C+Ph.D.%22">Adriana Muñoz M.Sc., Ph.D.</a></li></ol>
          <input type="checkbox" id="25871"/>
          <label for="25871">Abstract</label>
          <div>We describe the TIGUKAT objectbase management system, which is under development at the Laboratory for Database Systems Research at the University of Alberta. TIGUKAT has a novel object model, whose identifying characteristics include a purely behavioral semantics and a uniform approach to objects. Everything in the system, including types, classes, collections, behaviors, and functions, as well as meta-information, is a first-class object with well-defined behavior. In this way, the model abstracts everything, including traditional structural notions such as instance variables, method implementation, and schema definition, into a uniform semantics of behaviors on objects. Our emphasis in this article is on the object model, its implementation, the persistence model, and the query language. We also (briefly) present other database management functions that are under development such as the query optimizer, the version control system, and the transaction manager.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231645">Thémis: A database programming language handling integrity constraints</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231645.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22V%C3%A9ronique+Benzaken+Ph.D.%22">Véronique Benzaken Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Anne+Doucet+Ph.D.%22">Anne Doucet Ph.D.</a></li></ol>
          <input type="checkbox" id="57275"/>
          <label for="57275">Abstract</label>
          <div>This article presents a database programming language, Thémis, which supports subtyping and class hierarchies, and allows for the definition of integrity constraints in a global and declarative way. We first describe the salient features of the language: types, names, classes, integrity constraints (including methods), and transactions. The inclusion of methods into integrity constraints allows an increase of the declarative power of these constraints. Indeed, the information needed to define a constraint is not always stored in the database through attributes, but is sometimes computed or derived data. Then, we address the problem of efficiently checking constraints. More specifically, we consider two different problems: (1) statically reducing the number of constraints to be checked, and (2) generating an efficient run-time checker. Using simple strategies, one can significantly improve the efficiency of the verification. We show how to reduce the number of constraints to be checked by characterizing the portions of the database that are involved in both the constraints and in a transaction. We also show how to generate efficient algorithms for checking a large class of constraints. We show how all the techniques presented exploit the underlying type system, which provides significant help in solving (1) and (2). Last, the current status of the Thémis prototype is presented.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231646">Adaptable pointer swizzling strategies in object bases: design, realization, and quantitative analysis</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231646.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Alfons+Kemper+Ph.D.%22">Alfons Kemper Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dr.+Donald+Kossmann%22">Dr. Donald Kossmann</a></li></ol>
          <input type="checkbox" id="32330"/>
          <label for="32330">Abstract</label>
          <div>In this article, different techniques for “pointer swizzling” are classified and evaluated for optimizing the access to main-memory resident persistent objects. To speed up the access along inter-object references, the persistent pointers in the form of unique object identifiers (OIDs) are transformed (swizzled) into main-memory pointers (addresses). Pointer swizzling techniques can be divided into two classes: (1) those that allow replacement of swizzled objects from the buffer before the end of an application program, and (2) those that rule out the displacement of swizzled objects. The first class (i.e., techniques that take “precautions” for the replacement of swizzled objects) has not yet been thoroughly investigated. Four different pointer swizzling techniques allowing object replacement are investigated and compared with the performance of an object manager employing no pointer swizzling. The extensive qualitative and quantitative evaluation—only part of which could be presented in this article—demonstrate that there is noone superior pointer swizzling strategy forall application profiles. Therefore, an adaptable object base run-time system is devised that employs the full range of pointer swizzling strategies, depending on the application profile characteristics that are determined by, for example, monitoring in combination with sampling, user specifications, and/or program analysis.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 1995)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01237919">Data model for extensible support of explicit relationships in design databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01237919.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Joan+Peckham+Ph.D.%22">Joan Peckham Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Bonnie+MacKellar+Ph.D.%22">Bonnie MacKellar Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+Doherty+M.S.%2C+Ph.D.+candidate%22">Michael Doherty M.S., Ph.D. candidate</a></li></ol>
          <input type="checkbox" id="90578"/>
          <label for="90578">Abstract</label>
          <div>We describe the conceptual model of SORAC, a data modeling system developed at the University of Rhode Island. SORAC supports both semantic objects and relationships, and provides a tool for modeling databases needed for complex design domains. SORAC's set of built-in semantic relationships permits the schema designer to specify enforcement rules that maintain constraints on the object and relationship types. SORAC then automatically generates C++ code to maintain the specified enforcement rules, producing a schema that is compatible with Ontos. This facilitates the task of the schema designer, who no longer has to ensure that all methods on object classes correctly maintain necessary constraints. In addition, explicit specification of enforcement rules permits automated analysis of enforcement propagations. We compare the interpretations of relationships within the semantic and object-oriented models as an introduction to the mixed model that SORAC supports. Next, the set of built-in SORAC relationship types is presented in terms of the enforcement rules permitted on each relationship type. We then use the modeling requirements of an architectural design support system, called Arch Objects, to demonstrate the capabilities of SORAC. The implementation of the current SORAC prototype is also briefly discussed.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01237920">Updating knowledge bases while maintaining their consistency</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01237920.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ernest+Teniente+Ph.D.%22">Ernest Teniente Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Antoni+Oliv%C3%A9+Ph.D.%22">Antoni Olivé Ph.D.</a></li></ol>
          <input type="checkbox" id="1057"/>
          <label for="1057">Abstract</label>
          <div>When updating a knowledge base, several problems may arise. One of the most important problems is that of integrity constraints satisfaction. The classic approach to this problem has been to develop methods forchecking whether a given update violates an integrity constraint. An alternative approach consists of trying to repair integrity constraints violations by performing additional updates thatmaintain knowledge base consistency. Another major problem in knowledge base updating is that ofview updating, which determines how an update request should be translated into an update of the underlying base facts. We propose a new method for updating knowledge bases while maintaining their consistency. Our method can be used for both integrity constraints maintenance and view updating. It can also be combined with any integrity checking method for view updating and integrity checking. The kind of updates handled by our method are: updates of base facts, view updates, updates of deductive rules, and updates of integrity constraints. Our method is based on events and transition rules, which explicity define the insertions and deletions induced by a knowledge base update. Using these rules, an extension of the SLDNF procedure allows us to obtain all possible minimal ways of updating a knowledge base without violating any integrity constraint.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01237921">Realm-based spatial data types: The ROSE algebra</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01237921.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Prof.+Dr.+rer.+nat.+Ralf+Hartmut+G%C3%BCting%22">Prof. Dr. rer. nat. Ralf Hartmut Güting</a></li><li><a href="http://link.springer.com/search?facet-author=%22Markus+Schneider+Dipl.-Inform.%22">Markus Schneider Dipl.-Inform.</a></li></ol>
          <input type="checkbox" id="68741"/>
          <label for="68741">Abstract</label>
          <div>Spatial data types or algebras for database systems should (1) be fully general, that is, closed under set operations, (2) have formally defined semantics, (3) be defined in terms of finite representations available in computers, (4) offer facilities to enforce geometric consistency of related spatial objects, and (5) be independent of a particular DBMS data model, but cooperate with any. We present an algebra that usesrealms as geometric domains underlying spatial data types. A realm, as a general database concept, is a finite, dynamic, user-defined structure underlying one or more system data types. Problems of numerical robustness and topological correctness are solved within and below the realm layer so that spatial algebras defined above a realm have very nice algebraic properties. Realms also interact with a DMBS to enforce geometric consistency on object creation or update. The ROSE algebra is defined on top of realms and offers general types to represent point, line, and region features, together with a comprehensive set of operations. It is described within a polymorphic type system and interacts with a DMBS data model and query language through an abstractobject model interface. An example integration of ROSE into the object-oriented data model O2 and its query language is presented.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01237922">InterViso: Dealing with the complexity of federated database access</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01237922.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Marjorie+Templeton+B.A.%22">Marjorie Templeton B.A.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Herbert+Henley+B.S.%22">Herbert Henley B.S.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Edward+Maros+B.S.%22">Edward Maros B.S.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Darrel+J.+Van+Buer+Ph.D.%22">Darrel J. Van Buer Ph.D.</a></li></ol>
          <input type="checkbox" id="66232"/>
          <label for="66232">Abstract</label>
          <div>Connectivity products are finally available to provide the “highways” between computers containing data. IBM has provided strong validation of the concept with their “Information Warehouse.” DBMS vendors are providing gateways into their products, and SQL is being retrofitted on many older DBMSs to make it easier to access data from standard 4GL products and application development systems. The next step needed for data integration is to provide (1) a common data dictionary with a conceptual schema across the data to mask the many differences that occur when databases are developed independently and (2) a server that can access and integrate the databases using information from the data dictionary. In this article, we discuss InterViso, one of the first commercial federated database products. InterViso is based on Mermaid, which was developed at SDC and Unisys (Templeton et al., 1987b). It provides a value added layer above connectivity products to handle views across databases, schema translation, and transaction management.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 1995)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232471">The software information base: A server for reuse</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232471.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Panos+Constantopoulos+Sc.D.%22">Panos Constantopoulos Sc.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Matthias+Jarke+Dr.rer.pol.%22">Matthias Jarke Dr.rer.pol.</a></li><li><a href="http://link.springer.com/search?facet-author=%22John+Mylopoulos+Ph.D.%22">John Mylopoulos Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yannis+Vassiliou+Ph.D.%22">Yannis Vassiliou Ph.D.</a></li></ol>
          <input type="checkbox" id="75168"/>
          <label for="75168">Abstract</label>
          <div>We present an experimental software repository system that provides organization, storage, management, and access facilities for reusable software components. The system, intended as part of an applications development environment, supports the representation of information about requirements, designs and implementations of software, and offers facilities for visual presentation of the soft-ware objects. This article details the features and architecture of the repository system, the technical challenges and the choices made for the system development along with a usage scenario that illustrates its functionality. The system has been developed and evaluated within the context of the ITHACA project, a technology integration/software engineering project sponsored by the European Communities through the ESPRIT program, aimed at developing an integrated reuse-centered application development and support environment based on object-oriented techniques.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232472">HyperFile: A data and query model for documents</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232472.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Chris+Clifton+Ph.D.%22">Chris Clifton Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hector+Garcia-Molina+Ph.D.%22">Hector Garcia-Molina Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+Bloom+B.S.%22">David Bloom B.S.</a></li></ol>
          <input type="checkbox" id="34561"/>
          <label for="34561">Abstract</label>
          <div>Non-quantitative information such as documents and pictures pose interesting new problems in the database world. Traditional data models and query languages do not provide appropriate support for this information. Such data are typically stored in file systems, which do not provide the security, integrity, or query features of database management systems. The hypertext model has emerged as a good interface to this information; however,finding information using hypertext browsing does not scale well. We developed a query interface that serves as an extension of the browsing model of hypertext systems. These queries minimize the repeated user interactions required to locate data in a standard hypertext system. HyperFile is a prototype data server interface. In this article, we describe HyperFile, including a number of issues such as query generation, query processing, and indexing.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232473">Ordered shared locks for real-time databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232473.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Divyakant+Agrawal%22">Divyakant Agrawal</a></li><li><a href="http://link.springer.com/search?facet-author=%22Amr+El+Abbadi%22">Amr El Abbadi</a></li><li><a href="http://link.springer.com/search?facet-author=%22Richard+Jeffers+M.S.%22">Richard Jeffers M.S.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Lijing+Lin+M.S.%22">Lijing Lin M.S.</a></li></ol>
          <input type="checkbox" id="60912"/>
          <label for="60912">Abstract</label>
          <div>We propose locking protocols for real-time databases. Our approach has two main motivations: First, locking protocols are widely accepted and used in most database systems. Second, in real-time databases it has been shown that the blocking behavior of transactions in locking protocols results in performance degradation. We use a new relationship between locks called ordered sharing to eliminate blocking that arises in the traditional locking protocols. Ordered, sharing eliminates blocking of read and write operations but may result in delayed termination. Since timeliness and not response time is the crucial factor in real-time databases, our protocols exploit this delay to allow transactions to execute within the slacks of delayed transactions. We compare the performance of the proposed protocols with the two-phase locking protocol for real-time databases. Our experiments indicate that the proposed protocols for real-time databases. Our experiments indicate that the proposed protocols significantly reduce the percentages, of missed deadlines in the system for a variety of workloads.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232474">Characterization of database access pattern for analytic prediction of buffer hit probability</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232474.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Asit+Dan+Ph.D.%22">Asit Dan Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu+Ph.D.%22">Philip S. Yu Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Jen-Yao+Chung+Ph.D.%22">Jen-Yao Chung Ph.D.</a></li></ol>
          <input type="checkbox" id="46564"/>
          <label for="46564">Abstract</label>
          <div>The analytic prediction of buffer hit probability, based on the characterization of database accesses from real reference traces, is extremely useful for workload management and system capacity planning. The knowledge can be helpful for proper allocation of buffer space to various database relations, as well as for the management of buffer space for a mixed transaction and query environment. Access characterization can also be used to predict the buffer invalidation effect in a multi-node environment which, in turn, can influence transaction routing strategies. However, it is a challenge to characterize the database access pattern of a real workload reference trace in a simple manner that can easily be used to compute buffer hit probability. In this article, we use a characterization method that distinguishes three types of access patterns from a trace: (1) locality within a transaction, (2) random accesses by transactions, and (3) sequential accesses by long queries. We then propose a concise way to characterize the access skew across randomly accessed pages by logically grouping the large number of data pages into a small number of partitions such that the frequency of accessing each page within a partition can be treated as equal. Based on this approach, we present a recursive binary partitioning algorithm that can infer the access skew characterization from the buffer hit probabilities for a subset of the buffer sizes. We validate the buffer hit predictions for single and multiple node systems using production database traces. We further show that the proposed approach can predict the buffer hit probability of a composite workload from those of its component files.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232475">Announcement</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232475.pdf">Pdf</a>)
          </h3>
          <ol></ol>
          <input type="checkbox" id="26581"/>
          <label for="26581">Abstract</label>
          <div></div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 3 (January 1994 - October 1994)</h1>
          <ol><li>
          <h2>Issue 4 (October 1994)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231600">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231600.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hans-J.+Schek%22">Hans-J. Schek</a></li></ol>
          <input type="checkbox" id="88043"/>
          <label for="88043">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231601">Preface to the special issue on spatial database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231601.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ralf+Hartmut+G%C3%BCting%22">Ralf Hartmut Güting</a></li></ol>
          <input type="checkbox" id="85449"/>
          <label for="85449">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231602">An introduction to spatial database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231602.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Ralf+Hartmut+G%C3%BCting+Dr.rer.nat%22">Ralf Hartmut Güting Dr.rer.nat</a></li></ol>
          <input type="checkbox" id="83352"/>
          <label for="83352">Abstract</label>
          <div>We propose a definition of a spatial database system as a database system that offers spatial data types in its data model and query language, and supports spatial data types in its implementation, providing at least spatial indexing and spatial join methods. Spatial database systems offer the underlying database technology for geographic information systems and other applications. We survey data modeling, querying, data structures and algorithms, and system architecture for such systems. The emphasis is on describing known technology in a coherent manner, rather than listing open problems.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231603">Management of multidimensional discrete data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231603.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Peter+Baumann+Ph.D.%22">Peter Baumann Ph.D.</a></li></ol>
          <input type="checkbox" id="44101"/>
          <label for="44101">Abstract</label>
          <div>Spatial database management involves two main categories of data: vector and raster data. The former has received a lot of in-depth investigation; the latter still lacks a sound framework. Current DBMSs either regard raster data as pure byte sequences where the DBMS has no knowledge about the underlying semantics, or they do not complement array structures with storage mechanisms suitable for huge arrays, or they are designed as specialized systems with sophisticated imaging functionality, but no general database capabilities (e.g., a query language). Many types of array data will require database support in the future, notably 2-D images, audio data and general signal-time series (1-D), animations (3-D), static or time-variant voxel fields (3-D and 4-D), and the ISO/IEC PIKS (Programmer's Imaging Kernel System) BasicImage type (5-D). In this article, we propose a comprehensive support ofmultidimensional discrete data (MDD) in databases, including operations on arrays of arbitrary size over arbitrary data types. A set of requirements is developed, a small set of language constructs is proposed (based on a formal algebraic semantics), and a novel MDD architecture is outlined to provide the basis for efficient MDD query evaluation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231604">A semantic modeling approach for image retrieval by content</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231604.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Wesley+W.+Chu+Ph.D.%22">Wesley W. Chu Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ion+T.+leong+Ph.D.%22">Ion T. leong Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ricky+K.+Taira+Ph.D.%22">Ricky K. Taira Ph.D.</a></li></ol>
          <input type="checkbox" id="56154"/>
          <label for="56154">Abstract</label>
          <div>We introduce a semantic data model to capture the hierarchical, spatial, temporal, and evolutionary semantics of images in pictorial databases. This model mimics the user's conceptual view of the image content, providing the framework and guidelines for preprocessing to extract image features. Based on the model constructs, a spatial evolutionary query language (SEQL), which provides direct image object manipulation capabilities, is presented. With semantic information captured in the model, spatial evolutionary queries are answered efficiently. Using an object-oriented platform, a prototype medical-image management system was implemented at UCLA to demonstrate the feasibility of the proposed approach.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231605">Qualitative representation of spatial knowledge in two-dimensional space</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231605.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dimitris+Papadias+M.Sc.+Ph.D.+candidate%22">Dimitris Papadias M.Sc. Ph.D. candidate</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+Sellis+Ph.D.%22">Timos Sellis Ph.D.</a></li></ol>
          <input type="checkbox" id="90750"/>
          <label for="90750">Abstract</label>
          <div>Various relation-based systems, concerned with the qualitative representation and processing of spatial knowledge, have been developed in numerous application domains. In this article, we identify the common concepts underlying qualitative spatial knowledge representation, we compare the representational properties of the different systems, and we outline the computational tasks involved in relation-based spatial information processing. We also describesymbolic spatial indexes, relation-based structures that combine several ideas in spatial knowledge representation. A symbolic spatial index is an array that preserves only a set of spatial relations among distinct objects in an image, called the modeling space; the index array discards information, such as shape and size of objects, and irrelevant spatial relations. The construction of a symbolic spatial index from an input image can be thought of as a transformation that keeps only a set of representative points needed to define the relations of the modeling space. By keeping the relative arrangements of the representative points in symbolic spatial indexes and discarding all other points, we maintain enough information to answer queries regarding the spatial relations of the modeling space without the need to access the initial image or an object database. Symbolic spatial indexes can be used to solve problems involving route planning, composition of spatial relations, and update operations.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231606">The TV-tree: An index structure for high-dimensional data</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231606.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22King-Ip+Lin%22">King-Ip Lin</a></li><li><a href="http://link.springer.com/search?facet-author=%22H.+V.+Jagadish+Ph.D.%22">H. V. Jagadish Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christos+Faloutsos+Ph.D.%22">Christos Faloutsos Ph.D.</a></li></ol>
          <input type="checkbox" id="1666"/>
          <label for="1666">Abstract</label>
          <div>We propose a file structure to index high-dimensionality data, which are typically points in some feature space. The idea is to use only a few of the features, using additional features only when the additional discriminatory power is absolutely necessary. We present in detail the design of our tree structure and the associated algorithms that handle such “varying length” feature vectors. Finally, we report simulation results, comparing the proposed structure with theR *-tree, which is one of the most successful methods for low-dimensionality spaces.The results illustrate the superiority of our method, which saves up to 80% in disk accesses.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (July 1994)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232641">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232641.pdf">Pdf</a>)
          </h3>
          <ol></ol>
          <input type="checkbox" id="41591"/>
          <label for="41591">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232642">Efficiently instantiating view-objects from remote relational databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232642.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Byung+Suk+Lee+Ph.D.%22">Byung Suk Lee Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gio+Wiederhold+Ph.D.%22">Gio Wiederhold Ph.D.</a></li></ol>
          <input type="checkbox" id="46493"/>
          <label for="46493">Abstract</label>
          <div>View-objects are complex objects that are instantiated by delivering a query to a database and converting the query result into a nested structure. In relational databases, query results are conventionally retrieved as a single flat relation, which contains duplicate subtuples in its composite tuples. These duplicate subtuples increase the amount of data to be handled and thus degrade performance. In this article, we describe two new methods that retrieve a query result in structures other than a single flat relation. One method retrieves a set of relation fragments, and the other retrieves a single-nested relation. We first describe their algorithms and cost models, and then present the cost comparison results in a client-server architecture with a relational main memory database residing on a server.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232643">The demarcation protocol: A technique for maintaining constraints in distributed database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232643.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Daniel+Barbar%C3%A1-Mill%C3%A1+Ph.D%22">Daniel Barbará-Millá Ph.D</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hector+Garcia-Molina+Ph.D%22">Hector Garcia-Molina Ph.D</a></li></ol>
          <input type="checkbox" id="19945"/>
          <label for="19945">Abstract</label>
          <div>Traditional protocols for distributed database management have a high message overhead; restrain or lock access to resources during protocol execution; and may become impractical for some scenarios like real-time systems and very large distributed databases. In this article, we present the demarcation protocol; it overcomes these problems by using explicit consistency constraints as the correctness criteria. The method establishes safe limits as “lines drawn in the sand” for updates, and makes it possible to change these limits dynamically, enforcing the constraints at all times. We show how this technique can be applied to linear arithmetic, existential, key, and approximate copy constraints.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232644">Index configuration in object-oriented databases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232644.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Elisa+Bertino+Sc.Dr.%22">Elisa Bertino Sc.Dr.</a></li></ol>
          <input type="checkbox" id="86085"/>
          <label for="86085">Abstract</label>
          <div>In relational databases, an attribute of a relation can have only a single primitive value, making it cumbersome to model complex objects. The objectoriented paradigm removes this difficulty by introducing the notion of nested objects, which allows the value of an object atribute to be another object or a set of other objects. This means that a class consists of a set of attributes, and the values of the attributes are objects that belong to other classes; that is, the definition of a class forms a hierarchy of classes. All attributes of the nested classes are nested attributes of the root of the hierarchy. A branch of such hierarchy is called apath. In this article, we address the problem of index configuration for a given path. We first summarize some basic concepts, and introduce the concept of index configuration for a path. Then we present cost formulas to evaluate the costs of the various configurations. Finally, we present the algorithm that determines the optimal configuration, and show its correctness.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 1994)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228876">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228876.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hans-J.+Schek%22">Hans-J. Schek</a></li></ol>
          <input type="checkbox" id="69703"/>
          <label for="69703">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228877">Special issue editorial</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228877.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Professor+Kotagiri+Ramamohanarao%22">Professor Kotagiri Ramamohanarao</a></li></ol>
          <input type="checkbox" id="758"/>
          <label for="758">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228878">An introduction to deductive database languages and systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228878.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kotagiri+Ramamohanarao%22">Kotagiri Ramamohanarao</a></li><li><a href="http://link.springer.com/search?facet-author=%22James+Harland%22">James Harland</a></li></ol>
          <input type="checkbox" id="88871"/>
          <label for="88871">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228879">The Glue-Nail deductive database system: Design, implementation, and evaluation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228879.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Marcia+A.+Derr+Ph.D%22">Marcia A. Derr Ph.D</a></li><li><a href="http://link.springer.com/search?facet-author=%22Shinichi+Morishita+Ph.D%22">Shinichi Morishita Ph.D</a></li><li><a href="http://link.springer.com/search?facet-author=%22Geoffrey+Phipps+Ph.D%22">Geoffrey Phipps Ph.D</a></li></ol>
          <input type="checkbox" id="39609"/>
          <label for="39609">Abstract</label>
          <div>We describe the design and implementation of the Glue-Nail deductive database system. Nail is a purely declarative query language; Glue is a procedural language used for non-query activities. The two languages combined are sufficient to write a complete application. Nail and Glue code are both compiled into the target language IGlue. The Nail compiler uses variants of the magic sets algorithm and supports well-founded models. The Glue compiler's static optimizer uses peephole techniques and data flow analysis to improve code. The IGlue interpreter features a run-time adaptive optimizer that reoptimizes queries and automatically selects indexes. We also describe the Glue-Nail benchmark suite, a set of applications developed to evaluate the Glue-Nail language and to measure the performance of the system.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228880">The CORAL deductive system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228880.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Raghu+Ramakrishnan+Ph.D%22">Raghu Ramakrishnan Ph.D</a></li><li><a href="http://link.springer.com/search?facet-author=%22Divesh+Srivastava+Ph.D%22">Divesh Srivastava Ph.D</a></li><li><a href="http://link.springer.com/search?facet-author=%22S.+Sudarshan+Ph.D%22">S. Sudarshan Ph.D</a></li><li><a href="http://link.springer.com/search?facet-author=%22Praveen+Seshadri+M.S%22">Praveen Seshadri M.S</a></li></ol>
          <input type="checkbox" id="43240"/>
          <label for="43240">Abstract</label>
          <div>CORAL is a deductive system that supports a rich declarative language, and an interface to C++, which allows for a combination of declarative and imperative programming. A CORAL declarative program can be organized as a collection of interacting modules. CORAL supports a wide range of evaluation strategies, and automatically chooses an efficient strategy for each module in the program. Users can guide query optimization by selecting from a wide range of control choices. The CORAL system provides imperative constructs to update, insert, and delete facts. Users can program in a combination of declarative CORAL and C++ extended with CORAL primitives. A high degree of extensibility is provided by allowing C++ programmers to use the class structure of C++ to enhance the CORAL implementation. CORAL provides support for main-memory data and, using the EXODUS storage manager, disk-resident data. We present a comprehensive view of the system from broad design goals, the language, and the architecture, to language interfaces and implementation details.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228881">DECLARE and SDS: Early efforts to commercialize deductive database technology</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228881.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Werner+Kle%C3%9Fling+Ph.D.%22">Werner Kleßling Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Helmut+Schmidt%22">Helmut Schmidt</a></li><li><a href="http://link.springer.com/search?facet-author=%22Werner+Strau%C3%9F+M.S.%22">Werner Strauß M.S.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+D%C3%BCnzinger+M.S.%22">Gerhard Dünzinger M.S.</a></li></ol>
          <input type="checkbox" id="49076"/>
          <label for="49076">Abstract</label>
          <div>The Smart Data System (SDS) and its declarative query language, Declarative Reasoning, represent the first large-scale effort to commercialize deductive database technology. SDS offers the functionality of deductive reasoning in a distributed, heterogeneous database environment. In this article we discuss several interesting aspects of the query compilation and optimization process. The emphasis is on the query execution plan data structure and its transformations by the optimizing rule compiler. Through detailed case studies we demonstrate that efficient and very compact runtime code can be generated. We also discuss our experiences gained from a large pilot application (the MVV-expert) and report on several issues of practical interest in engineering such a complex system, including the migration from Lisp to C. We argue that heuristic knowledge and control should be made an integral part of deductive databases.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228882">The aditi deductive database system</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228882.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jayen+Vaghanl+BSc+%28hons%29%22">Jayen Vaghanl BSc (hons)</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kotagiri+Ramamohanarao+Ph.D.%22">Kotagiri Ramamohanarao Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22David+B.+Kemp+Ph.D.%22">David B. Kemp Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Zoltan+Somogyi+Ph.D.%22">Zoltan Somogyi Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+J.+Stuckey+Ph.D.%22">Peter J. Stuckey Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Tim+S.+Leask+BSc+%28hons%29%22">Tim S. Leask BSc (hons)</a></li><li><a href="http://link.springer.com/search?facet-author=%22James+Harland+Ph.D.%22">James Harland Ph.D.</a></li></ol>
          <input type="checkbox" id="42055"/>
          <label for="42055">Abstract</label>
          <div>Deductive databases generalize relational databases by providing support for recursive views and non-atomic data. Aditi is a deductive system based on the client-server model; it is inherently multi-user and capable of exploiting parallelism on shared-memory multiprocessors. The back-end uses relational technology for efficiency in the management of disk-based data and uses optimization algorithms especially developed for the bottom-up evaluation of logical queries involving recursion. The front-end interacts with the user in a logical language that has more expressive power than relational query languages. We present the structure of Aditi, discuss its components in some detail, and present performance figures.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 1994)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231355">Journal reorganization: Peter Apers, Jim Gray, Stanley Su, new editors-in-chief of theVLDB journal</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231355.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hans-J.+Schek%22">Hans-J. Schek</a></li></ol>
          <input type="checkbox" id="30016"/>
          <label for="30016">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231356">Chronological scheduling of transactions with temporal dependencies</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231356.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dimitrios+Georgakopoulos+Ph.D.%22">Dimitrios Georgakopoulos Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Marek+Rusinkiewicz+Ph.D.%22">Marek Rusinkiewicz Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Witold+Litwin+Ph.D.%22">Witold Litwin Ph.D.</a></li></ol>
          <input type="checkbox" id="50401"/>
          <label for="50401">Abstract</label>
          <div>Database applications often impose temporal dependencies between transactions that must be satisfied to preserve data consistency. The extant correctness criteria used to schedule the execution of concurrent transactions are either time independent or use strict, difficult to satisfy real-time constraints. On one end of the spectrum, serializability completely ignores time. On the other end, deadline scheduling approaches consider the outcome of each transaction execution correct only if the transaction meets its real-time deadline. In this article, we explore new correctness criteria and scheduling methods that capture temporal transaction dependencies and belong to, the broad area between these two extreme approaches. We introduce the concepts ofsuccession dependency andchronological dependency and define correctness criteria under which temporal dependencies between transactions are preserved even if the dependent transactions execute concurrently. We also propose achronological scheduler that can guarantee that transaction executions satisfy their chronological constraints. The advantages of chronological scheduling over traditional scheduling methods, as well as the main issues in the implementation and performance of the proposed scheduler, are discussed.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231357">Dynamic maintenance of data distribution for selectivity estimation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231357.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kyu-Young+Whang+Ph.D.%22">Kyu-Young Whang Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Sang-Wook+Kim%22">Sang-Wook Kim</a></li><li><a href="http://link.springer.com/search?facet-author=%22Gio+Wiederhold+Ph.D.%22">Gio Wiederhold Ph.D.</a></li></ol>
          <input type="checkbox" id="79499"/>
          <label for="79499">Abstract</label>
          <div>We propose a new dynamic method for multidimensional selectivity estimation for range queries that works accurately independent of data distribution. Good estimation of selectivity is important for query optimization and physical database design. Our method employs the multilevel grid file (MLGF) for accurate estimation of multidimensional data distribution. The MLGF is a dynamic, hierarchical, balanced, multidimensional file structure that gracefully adapts to nonuniform and correlated distributions. We show that the MLGF directory naturally represents a multidimensional data distribution. We then extend it for further refinement and present the selectivity estimation method based on the MLGF. Extensive experiments have been performed to test the accuracy of selectivity estimation. The results show that estimation errors are very small independent of distributions, even with correlated and/or highly skewed ones. Finally, we analyze the cause of errors in estimation and investigate the effects of various parameters on the accuracy of estimation.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231358">A pattern-based object calculus</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231358.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Nabil+Kamel+Ph.D.%22">Nabil Kamel Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ping+Wu+Ph.D.%22">Ping Wu Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Stanley+Y.+W.+Su+Ph.D.%22">Stanley Y. W. Su Ph.D.</a></li></ol>
          <input type="checkbox" id="23295"/>
          <label for="23295">Abstract</label>
          <div>Several object-oriented database management systems have been implemented without an accompanying theoretical foundation for constraint, query specification, and processing. The pattern-based object calculus presented in this article provides such a theoretical foundation for describing and processing objectoriented databases. We view an object-oriented database as a network of interrelated classes (i.e., the intension) and a collection of time-varying object association patterns (i.e., the extension). The object calculus is based on first-order logic. It provides the formalism for interpreting precisely and uniformly the semantics of queries and integrity constraints in object-oriented databases. The power of the object calculus is shown in four aspects. First, associations among objects are expressed explicitly in an object-oriented database. Second, the “nonassociation” operator is included in the object calculus. Third, set-oriented operations can be performed on both homogeneous and heterogeneous object association patterns. Fourth, our approach does not assume a specific form of database schema. A proposed formalism is also applied to the design of high-level object-oriented query and constraint languages.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231359">Versioning and configuration management in an object-oriented data model</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231359.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Edward+Sciore+Ph.D.%22">Edward Sciore Ph.D.</a></li></ol>
          <input type="checkbox" id="23527"/>
          <label for="23527">Abstract</label>
          <div>Many database applications require the storage and manipulation of different versions of data objects. To satisfy the diverse needs of these applications, current database systems support versioning at a very low level. This article demonstrates that application-independent versioning can be supported at a significantly higher level. In particular, we extend the EXTRA data model and EXCESS query language so that configurations can be specified conceptually and non-procedurally. We also show how version sets can be viewed multidimensionally, thereby allowing configurations to be expressed at a higher level of abstraction. The resulting model integrates and generalizes ideas, in CAD systems, CASE systems, and temporal databases.</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 2 (January 1993 - October 1993)</h1>
          <ol><li>
          <h2>Issue 4 (October 1993)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01263046">Performance of B+ tree concurrency control algorithms</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01263046.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22V.+Srinivasan+Ph.D.%22">V. Srinivasan Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Carey+Ph.D.%22">Michael J. Carey Ph.D.</a></li></ol>
          <input type="checkbox" id="19224"/>
          <label for="19224">Abstract</label>
          <div>A number of algorithms have been proposed to access B+-trees concurrently, but they are not well understood. In this article, we study the performance of various B+-tree concurrency control algorithms using a detailed simulation model of B+-tree operations in a centralized DBMS. Our study covers a wide range of data contention situations and resource conditions. In addition, based on the performance of the set of B+-tree concurrency control algorithms, which includes one new algorithm, we make projections regarding the performance of other algorithms in the literature. Our results indicate that algorithms with updaters that lock-couple using exclusive locks perform poorly as compared to those that permit more optimistic index descents. In particular, the B-link algorithms are seen to provide the most concurrency and the best overall performance. Finally, we demonstrate the need for a highly concurrent long-term lock holding strategy to obtain the full benefits of a highly concurrent algorithm for index operations.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01263047">Multi-level transaction management for complex objects: Implementation, performance, parallelism</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01263047.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Gerhard+Weikum+Dr.-Ing.%22">Gerhard Weikum Dr.-Ing.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christof+Hasse+Dipl.-Inform.%22">Christof Hasse Dipl.-Inform.</a></li></ol>
          <input type="checkbox" id="34733"/>
          <label for="34733">Abstract</label>
          <div>Multi-level transactions are a varlant of open-nested transactions in which the subtransactions correspond to operations at different levels of a layered system architecture. They allow the exploitation of semantics of high-level operations to increase concurrency. As a consequence, undoing a transaction requires compensation of completed subtransactions. In addition, multi-level recovery methods must take into consideration that high-level operations are not necessarily atomic if multiple pages are updated in a single subtransaction. This article presents algorithms for multi-level transaction management that are implemented in the database kernel system (DASDBS). In particular, we show that multi-level recovery can be implemented in an efficient way. We discuss performance measurements using a synthetic benchmark for processing complex objects in a multi-user environment. We show that multi-level transaction management can be extended easily to cope with parallel subtransactions within a single transaction. Performance results are presented with varying degrees of inter- and intratransaction parallelism.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01263048">Understanding semantic relationships</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01263048.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Vede+C.+Storey+Ph.D.%22">Vede C. Storey Ph.D.</a></li></ol>
          <input type="checkbox" id="41816"/>
          <label for="41816">Abstract</label>
          <div>To develop sophisticated database management systems, there is a need to incorporate more understanding of the real world in the information that is stored in a database. Semantic data models have been developed to try to capture some of the meaning, as well as the structure, of data using abstractions such as inclusion, aggregation, and association. Besides these well-known relationships, a number of additional semantic relationships have been identified by researchers in other disciplines such as linguistics, logic, and cognitive psychology. This article explores some of the lesser-recognized semantic relationships and discusses both how they could be captured, either manually or by using an automated tool, and their impact on database design. To demonstrate the feasibility of this research, a prototype system for analyzing semantic relationships, called the Semantic Relationship Analyzer, is presented.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01263049">Searching a minimal semantically-equivalent subset of a set of partial values</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01263049.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Frank+S.+C.+Tseng+Ph.D.%22">Frank S. C. Tseng Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Arbee+L.+P.+Chen+Ph.D.%22">Arbee L. P. Chen Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Wei-Pang+Yang+Ph.D.%22">Wei-Pang Yang Ph.D.</a></li></ol>
          <input type="checkbox" id="57364"/>
          <label for="57364">Abstract</label>
          <div>Imprecise data exist in databases due to their unavailability or to data/ schema incompatibilities in a multidatabase system. Partial values have been used to represent imprecise data. Manipulation of partial values is therefore necessary to process queries involving imprecise data. In this article, we study the problem of eliminating redundant partial values that result from a projection on an attribute with partial values. The redundancy of partial values is defined through the interpretation of a set of partial values. This problem is equivalent to searching a minimal semantically-equivalent subset of a set of partial values. A semantically-equivalent subset contains exactly the same information as the original set. We derive a set of useful properties and apply a graph matching technique to develop an efficient algorithm for searching such a minimal subset and therefore eliminating redundant partial values. By this process, we not only provide a concise answer to the user, but also reduce the communication cost when partial values are requested to be transmitted from one site to another site in a distributed environment. Moreover, further manipulation of the partial values can be simplified. This work is also extended to the case of multi-attribute projections.</div>
        </li></ul>
        </li><li>
          <h2>Issue 3 (July 1993)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228669">Preface by the editors-in-chief</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228669.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Hans-J.+Schek%22">Hans-J. Schek</a></li><li><a href="http://link.springer.com/search?facet-author=%22Fred+Maryanski%22">Fred Maryanski</a></li></ol>
          <input type="checkbox" id="8205"/>
          <label for="8205">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228670">Preface to special issue on PDIS</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228670.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Carey%22">Michael J. Carey</a></li><li><a href="http://link.springer.com/search?facet-author=%22Patrick+Valduriez%22">Patrick Valduriez</a></li></ol>
          <input type="checkbox" id="30055"/>
          <label for="30055">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228671">Query processing and inverted indices in shared-nothing text document information retrieval systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228671.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Anthony+Tomasic+M.A.%2C+Ph.D.+Candidate%22">Anthony Tomasic M.A., Ph.D. Candidate</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hector+Garcia-Molina+Ph.D.%22">Hector Garcia-Molina Ph.D.</a></li></ol>
          <input type="checkbox" id="48553"/>
          <label for="48553">Abstract</label>
          <div>The performance of distributed text document retrieval systems is strongly influenced by the organization of the inverted text. This article compares the performance impact on query processing of various physical organizations for inverted lists. We present a new probabilistic model of the database and queries. Simulation experiments determine those variables that most strongly influence response time and throughput. This leads to a set of design trade-offs over a wide range of hardware configurations and new parallel query processing strategies.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228672">Parallel query processing with zigzag trees</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228672.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Mikal+Ziane+Ph.D.%22">Mikal Ziane Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Mohamed+Za%C3%AFt+Ph.D.+student%2C+Projet+Rodin%22">Mohamed Zaït Ph.D. student, Projet Rodin</a></li><li><a href="http://link.springer.com/search?facet-author=%22Pascale+Borla-Salamet+Ph.D.%22">Pascale Borla-Salamet Ph.D.</a></li></ol>
          <input type="checkbox" id="59506"/>
          <label for="59506">Abstract</label>
          <div>In this article, we describe our approach to the compile-time optimization and parallelization of queries for execution in DBS3 or EDS. DBS3 is a shared-memory parallel database system, while the EDS system has a distributed-memory architecture. Because DBS3 implements a parallel dataflow execution model, this approach applies to both architectures. Using randomized search strategies enables the exploration of a search space large enough to include zigzag trees, which are intermediate between left-deep and right-deep trees. Zigzag trees are shown to provide better response time than right-deep trees in case of limited memory. Performance measurements obtained using the DBS3 prototype show the advantages of zigzag trees under various conditions.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228673">Considering data skew factor in multi-way join query optimization for parallel execution</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228673.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Kien+A.+Hua+Ph.D.%22">Kien A. Hua Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yo-Lung+Lo+Ph.D.+candidate%22">Yo-Lung Lo Ph.D. candidate</a></li><li><a href="http://link.springer.com/search?facet-author=%22Honesty+C.+Young+Ph.D.%22">Honesty C. Young Ph.D.</a></li></ol>
          <input type="checkbox" id="9661"/>
          <label for="9661">Abstract</label>
          <div>A consensus on parallel architecture for very large database management has emerged. This architecture is based on a shared-nothing hardware organization. The computation model is very sensitive to skew in tuple distribution, however. Recently, several parallel join algorithms with dynamic load balancing capabilities have been proposed to address this issue, but none of them consider multi-way join problems. In this article we propose a dynamic load balancing technique for multi-way joins, and investigate the effect of load balancing on query optimization. In particular, we present a join-ordering strategy that takes load-balancing issues into consideration. Our performance study indicates that the proposed query optimization technique can provide very impressive performance improvement over conventional approaches.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228674">A theory of global concurrency control in multidatabase systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228674.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Aidong+Zhang+Ph.+D.+candidate%22">Aidong Zhang Ph. D. candidate</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ahmed+K.+Elmagarmid+Ph.D.%22">Ahmed K. Elmagarmid Ph.D.</a></li></ol>
          <input type="checkbox" id="42074"/>
          <label for="42074">Abstract</label>
          <div>This article presents a theoretical basis for global concurrency control to maintain global serializability in multidatabase systems. Three correctness criteria are formulated that utilize the intrinsic characteristics of global transactions to determine the serialization order of global subtransactions at each local site. In particular, two new types of serializability, chain-conflicting serializability and sharing serializability, are proposed and hybrid serializability, which combines these two basic criteria, is discussed. These criteria offer the advantage of imposing no restrictions on local sites other than local serializability while retaining global serializability. The graph testing techniques of the three criteria are provided as guidance for global transaction scheduling. In addition, an optimal property of global transactions for determinating the serialization order of global subtransactions at local sites is formulated. This property defines the upper limit on global serializability in multidatabase systems.</div>
        </li></ul>
        </li><li>
          <h2>Issue 2 (April 1993)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232184">Value-based scheduling in real-time database systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232184.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Jayant+R.+Haritsa+Ph.D.%22">Jayant R. Haritsa Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Michael+J.+Canrey+Ph.D.%22">Michael J. Canrey Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Miron+Livny+Ph.D.%22">Miron Livny Ph.D.</a></li></ol>
          <input type="checkbox" id="56929"/>
          <label for="56929">Abstract</label>
          <div>In a real-time database system, an application may assign avalue to a transaction to reflect the return it expects to receive if the transaction commits before its deadline. Most research on real-time database systems has focused on systems where all transactions are assigned the same value, the performance goal being to minimize the number of missed deadlines. When transactions are assigned different values, the goal of the system shifts to maximizing the sum of the values of those transactions that commit by their deadlines. Minimizing the number of missed deadlines becomes a secondary concern. In this article, we address the problem of establishing a priority ordering among transactions characterized by both values and deadlines that results in maximizing the realized value. Of particular interest is the tradeoff established between these values and deadlines in constructing the priority ordering. Using a detailed simulation model, we evaluate the performance of several priority mappings that make this tradeoff in different, but fixed, ways. In addition, a “bucket” priority mechanism that allows the relative importannce of values and deadlines to be controlled is introduced and studied. The notion of associating a penalty with transactions whose deadlines are not met is also briefly considered.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232185">Query languages for relational multidatabases</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232185.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22John+Grant+Ph.D.%22">John Grant Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Witold+Litwin+Ph.D.%22">Witold Litwin Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Roussopoulos+Ph.D.%22">Nick Roussopoulos Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+Sellis+Ph.D.%22">Timos Sellis Ph.D.</a></li></ol>
          <input type="checkbox" id="33367"/>
          <label for="33367">Abstract</label>
          <div>With the existence of many autonomous databases widely accessible through computer networks, users will require the capability to jointly manipulate data in different databases. A multidatabase system provides such a capability through a multidatabase manipulation language, such as MSQL. We propose a theoretical foundation for such languages by presenting a multirelational algebra and calculus based on the relational algebra and calculus. The proposal is illustrated by various queries on an example multidatabase. It is shown that properties of the multirelational algebra may be used for optimization and that every multirelational algebra query can be expressed as a multirelational calculus query. The connection between the multirelational languages and MSQL, the multidatabase version of SQL, is also investigated.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232186">Generating consistent test data: Restricting the search space by a generator formula</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232186.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Andrea+Neufeld+Dipl.+Inform.%22">Andrea Neufeld Dipl. Inform.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Guido+Moerkotte+Dr.rer.nat.%22">Guido Moerkotte Dr.rer.nat.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Peter+C.+Loekemann+Dr.ing.%22">Peter C. Loekemann Dr.ing.</a></li></ol>
          <input type="checkbox" id="86535"/>
          <label for="86535">Abstract</label>
          <div>To address the problem of generating test data for a set of general consistency constraints, we propose a new two-step approach: First the interdepen-dencies between consistency constraints are explored and a generator formula is derived on their basis. During its creation, the user may exert control. In essence, the generator formula contains information to restrict the search for consistent test databases. In the second step, the test database is generated. Here, two different approaches are proposed. The first adapts an already published approach to generating finite models by enhancing it with requirements imposed by test data generation. The second, a new approach, operationalizes the generator formula by translating it into a sequence of operators, and then executes it to construct the test database. For this purpose, we introduce two powerful operators: the generation operator and the test-and-repair operator. This approach also allows for enhancing the generation operators with heuristics for generating facts in a goal-directed fashion. It avoids the generation of test data that may contradict the consistency constraints, and limits the search space for the test data. This article concludes with a careful evaluation and comparison of the performance of the two approaches and their variants by describing a number of benchmarks and their results.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01232187">Supporting consistent updates in replicated multidatabase systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01232187.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Weimin+Du+Ph.D.%22">Weimin Du Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Ahmed+K.+Elmagarmid+Ph.D.%22">Ahmed K. Elmagarmid Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Won+Kim+Ph.D.%22">Won Kim Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Omran+Bukhres+Ph.D.%22">Omran Bukhres Ph.D.</a></li></ol>
          <input type="checkbox" id="79669"/>
          <label for="79669">Abstract</label>
          <div>Replication is useful in multidatabase systems (MDBSs) because, as in traditional distributed database systems, it increases data availability in the presence of failures and decreases data retrieval costs by reading local or close copies of data. Concurrency control, however, is more difficult in replicated MDBSs than in ordinary distributed database systems. This is the case not only because local concurrency controllers may schedule global transactions inconsistently, but also because local transactions (at different sites) may access the same replicated data. In this article, we propose a decentralized concurrency control protocol for a replicated MDBS. The proposed strategy supports prompt and consistent updates of replicated data by both local and global applications without a central coordinator.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (January 1993)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231796">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231796.pdf">Pdf</a>)
          </h3>
          <ol></ol>
          <input type="checkbox" id="26398"/>
          <label for="26398">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231797">Buffer management based on return on consumption in a multi-query environment</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231797.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Philip+S.+Yu+Ph.D.%22">Philip S. Yu Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Douglas+W.+Cornell+Ph.D.%22">Douglas W. Cornell Ph.D.</a></li></ol>
          <input type="checkbox" id="7982"/>
          <label for="7982">Abstract</label>
          <div>In a multi-query environment, the marginal utilities of allocating additional buffer to the various queries can be vastly different. The conventional approach examines each query in isolation to determine the optimal access plan and the corresponding locality set. This can lead to performance that is far from optimal. As each query can have different access plans with dissimilar locality sets and sensitivities to memory requirement, we employ the concepts of memory consumption and return on consumption (ROC) as the basis for memory allocations. Memory consumption of a query is its space-time product, while ROC is a measure of the effectiveness of response-time reduction through additional memory consumption. A global optimization strategy using simulated annealing is developed, which minimizes the average response over all queries under the constraint that the total memory consumption rate has to be less than the buffer size. It selects the optimal join method and memory allocation for all query types simultaneously. By analyzing the way the optimal strategy makes memory allocations, a heuristic threshold strategy is then proposed. The threshold strategy is based on the concept of ROC. As the memory consumption rate by all queries is limited by the buffer size, the strategy tries to allocate the memory so as to make sure that a certain level of ROC is achieved. A simulation model is developed to demonstrate that the heuristic strategy yields performance that is very close to the optimal strategy and is far superior to the conventional allocation strategy.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231798">Concurrency control issues in nested transactions</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231798.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Theo+H%C3%A4rder+Ph.D.%22">Theo Härder Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Kurt+Rothermel+Ph.D.%22">Kurt Rothermel Ph.D.</a></li></ol>
          <input type="checkbox" id="9354"/>
          <label for="9354">Abstract</label>
          <div>The concept of nested transactions offers more decomposable execution units and finer-grained control over concurrency and recovery than “flat” transactions. Furthermore, it supports the decomposition of a “unit of work” into subtasks and their appropriate distribution in a computer system as a prerequisite of intratransaction parallelism. However, to exploit its full potential, suitable granules of concurrency control as well as access modes for shared data are necessary. In this article, we investigate various issues of concurrency control for nested transactions. First, the mechanisms for cooperation and communication within nested transactions should not impede parallel execution of transactions among parent and children or among siblings. Therefore, a model for nested transactions is proposed allowing for effective exploitation of intra-transaction parallelism. Starting with a set of basic locking rules, we introduce the concept of “downward inheritance of locks” to make data manipulated by a parent available to its children. To support supervised and restricted access, this concept is refined to “controlled downward inheritance.” The initial concurrency control scheme was based on S-X locks for “flat,” non-overlapping data objects. In order to adjust this scheme for practical applications, a set of concurrency control rules is derived for generalized lock modes described by a compatibility matrix. Also, these rules are combined with a hierarchical locking scheme to improve selective access to data granules of varying sizes. After having tied together both types of hierarchies (transaction and object), it can be shown how “controlled downward inheritance” for hierarchical objects is achieved in nested transactions. Finally, problems of deadlock detection and resolution in nested transactions are considered.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231799">Using differential technlques to efficiently support transaction time</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231799.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Christian+S.+Jensen+Ph.D.%22">Christian S. Jensen Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Leo+Mark+Ph.D.%22">Leo Mark Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Nick+Roussopoulos+Ph.D.%22">Nick Roussopoulos Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Timos+Sells+Ph.D.%22">Timos Sells Ph.D.</a></li></ol>
          <input type="checkbox" id="26092"/>
          <label for="26092">Abstract</label>
          <div>We present an architecture for query processing in the relational model extended with transaction time. The architecture integrates standard query optimization and computation techniques with new differential computation techniques. Differential computation computes a query incrementally or decrementally from the cahced and indexed results of previous computations. The use of differential computation techniques is essential in order to provide efficient processing of queries that access very large temporal relations. Alternative query plans are integrated into a state transition network, where the state space includes backlogs of base relations, cached results from previous computations, a cache index, and intermediate results; the transitions include standard relational algebra operators, operators for constructing differential files, operators for differential computation, and combined operators. A rule set is presented to prune away parts of state transition networks that are not promising, and dynamic programming techniques are used to identify the optimal plans from the remaining state transition networks. An extended logical access path serves as a “structuring” index on the cached results and contains, in addition, vital statistics for the query optimization process (including statistics about base relations, backlogs, and queries-previously computed and cached, previously computed, or just previously estimated).</div>
        </li></ul>
        </li></ol>
        </div><div>
          <h1>Volume 1 (July 1992 - October 1992)</h1>
          <ol><li>
          <h2>Issue 2 (October 1992)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231699">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231699.pdf">Pdf</a>)
          </h3>
          <ol></ol>
          <input type="checkbox" id="96890"/>
          <label for="96890">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231700">Overview of multidatabase transaction management</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231700.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Yuri+Breitbart+Ph.D.%22">Yuri Breitbart Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Hector+Garcia-Molina+Ph.D.%22">Hector Garcia-Molina Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Avi+Silberschatz+Ph.D.%22">Avi Silberschatz Ph.D.</a></li></ol>
          <input type="checkbox" id="13893"/>
          <label for="13893">Abstract</label>
          <div>A multidatabase system (MDBS) is a facility that allows users access to data located in multiple autonomous database management systems (DBMSs). In such a system,global transactions are executed under the control of the MDBS. Independently,local transactions are executed under the control of the local DBMSs. Each local DBMS integrated by the MDBS may employ a different transaction management scheme. In addition, each local DBMS has complete control over all transactions (global and local) executing at its site, including the ability to abort at any point any of the transactions executing at its site. Typically, no design or internal DBMS structure changes are allowed in order to accommodate the MDBS. Furthermore, the local DBMSs may not be aware of each other and, as a consequence, cannot coordinate their actions. Thus, traditional techniques for ensuring transaction atomicity and consistency in homogeneous distributed database systems may not be appropriate for an MDBS environment. The objective of this article is to provide a brief review of the most current work in the area of multidatabase transaction management. We first define the problem and argue that the multidatabase research will become increasingly important in the coming years. We then outline basic research issues in multidatabase transaction management and review recent results in the area. We conclude with a discussion of open problems and practical implications of this research.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231701">A toolkit for the incremental implementation of heterogeneous database management systems</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231701.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dr.+Pamela+Drew+Ph.D.%22">Dr. Pamela Drew Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Roger+King+Ph.D.%22">Roger King Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dennis+Heimbigner+Ph.D.%22">Dennis Heimbigner Ph.D.</a></li></ol>
          <input type="checkbox" id="60717"/>
          <label for="60717">Abstract</label>
          <div>The integration of heterogeneous database environments is a difficult and complex task. The A la carte Framework addresses this complexity by providing a reusable and extensible architecture in which a set of heterogeneous database management systems can be integrated. The goal is to support incremental integration of existing database facilities into heterogeneous, interoperative, distributed systems. The Framework addresses the three main issues in heterogeneous systems in tegration. First, it identifies the problems in integrating heterogeneous systems. Second, it identifies the key interfaces and parameters required for autonomous systems to interoperate correctly. Third, it demonstrates an approach to integrating these interfaces in an extensible and incremental way. The A la carte Framework provides a set of reusable, integrating components which integrate the major functional domains, such as transaction management, that could or should be integrated in heterogeneous systems. It also provides a mechanism for capturing key characteristics of the components and constraints which describe how the components can be mixed and interchanged, thereby helping to reduce the complexity of the integration process. Using this framework, we have implemented an experimental, heterogeneous configuration as part of the object management work in the software engineering research consortium, Arcadia.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01231702">Federated databases and systems: Part II — A tutorial on their resource consolidation</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01231702.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Prof.+David+K.+Hsiao+Ph.D.%22">Prof. David K. Hsiao Ph.D.</a></li></ol>
          <input type="checkbox" id="89975"/>
          <label for="89975">Abstract</label>
          <div>The issues and solutions for the interoperability of a class of heterogeneous databases and their database, systems are expounded in two parts. Part I presented the data-sharing issues in federated databases and systems (Hsiao, 1992). The present article explores resource-consolidation issues.Interoperability in this context refers to data sharing among heterogeneous databases, and to resource consolidation of computer hardware, system software, and support personnel.Resource consolidation requires the presence of a database system architecture which supports the heterogeneous system software, thereby eliminating the need for various computer hardware and support personnel. The class of heterogeneous databases and database systems expounded herein is termedfederated, meaning that they are joined in order to meet certain organizational requirements and because they require their respective application specificities, integrity constraints, and security requirements to be upheld. Federated databases and systems are new. While there are no technological solutions, there has been considerable research towards their development. This tutorial is aimed at exposing the need for such solutions. A taxonomy is introduced in our, review of existing research undertakings and exploratory developments. With this taxonomy, we contrast and compare various approaches to federating databases and systems.</div>
        </li></ul>
        </li><li>
          <h2>Issue 1 (July 1992)</h2>
          <ul><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228705">Foreword</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228705.pdf">Pdf</a>)
          </h3>
          <ol></ol>
          <input type="checkbox" id="83461"/>
          <label for="83461">Abstract</label>
          <div></div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228706">Transaction management issues in a failure-prone multidatabase system environment</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228706.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Dr.+Yuri+Breitbart+Ph.D.%22">Dr. Yuri Breitbart Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Avi+Silberschatz+Ph.D.%22">Avi Silberschatz Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Glenn+R.+Thompson+Ph.D.%22">Glenn R. Thompson Ph.D.</a></li></ol>
          <input type="checkbox" id="86517"/>
          <label for="86517">Abstract</label>
          <div>This paper is concerned with the problem of integrating a number of existing off-the-shelf local database systems into a multidatabase system that maintains consistency in the face of concurrency and failures.The major difficulties in designing such systems stem from the requirements that local transactions be allowed to execute outside the multidatabase system control, and that the various local database systems cannot participate in the execution of a global commit protocol. A scheme based on the assumption that the component local database systems use the strict two-phase locking protocol is developed. Two major problems are addressed: How to ensure global transaction atomicity without the provision of a commit protocol, and how to ensure freedom from global deadlocks.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228707">Cooperative transaction hierarchies: Transaction support for design applications</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228707.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Marian+H.+Nodine+Ph.D.%22">Marian H. Nodine Ph.D.</a></li><li><a href="http://link.springer.com/search?facet-author=%22Dr.+Stanley+B.+Zdonik+Ph.D.%22">Dr. Stanley B. Zdonik Ph.D.</a></li></ol>
          <input type="checkbox" id="53177"/>
          <label for="53177">Abstract</label>
          <div>Traditional atomic and nested transactions are not always well-suited to cooperative applications, such as design applications. Cooperative applications place requirements on the database that may conflict with the serializability requirement. They require transactions to be long, possibly nested, and able to interact with each other in a structured way. We define a transaction framework, called acooperative transaction hierarchy, that allows us to relax the requirement for atomic, serializable transactions to better support cooperative applications. In cooperative transaction hierarchies, we allow the correctness specification for groups of designers to be tailored to the needs of the application. We usepatterns andconflicts to specify the constraints imposed on a group's history for it to be correct. We also provide some primitives to smooth the operation of the members. We characterize deadlocks in a cooperative transaction hierarchy, and provide mechanisms for deadlock detection and resolution. We examine issues associated with failure and recovery.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228708">Model independent assertions for integration of heterogeneous schemas</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228708.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Prof.+Stefano+Spaccapietra%22">Prof. Stefano Spaccapietra</a></li><li><a href="http://link.springer.com/search?facet-author=%22Christine+Parent%22">Christine Parent</a></li><li><a href="http://link.springer.com/search?facet-author=%22Yann+Dupont%22">Yann Dupont</a></li></ol>
          <input type="checkbox" id="25225"/>
          <label for="25225">Abstract</label>
          <div>Due to the proliferation of database applications, the integration of existing databases into a distributed or federated system is one of the major challenges in responding to enterprises' information requirements. Some proposed integration techniques aim at providing database administrators (DBAs) with a view definition language they can use to build the desired integrated schema. These techniques leave to the DBA the responsibility of appropriately restructuring schema elements from existing local schemas and of solving inter-schema conflicts. This paper investigates theassertion-based approach, in which the DBA's action is limited to pointing out corresponding elements in the schemas and to defining the nature of the correspondence in between. This methodology is capable of: ensuring better integration by taking into account additional semantic information (assertions about links); automatically solving structural conflicts; building the integrated schema without requiring conforming of initial schemas; applying integration rules to a variety of data models; and performing view as well as database integration. This paper presents the basic ideas underlying our approach and focuses on resolution of structural conflicts.</div>
        </li><li>
          <h3>
            <a href="http://link.springer.com/article/10.1007/BF01228709">Federated databases and systems: Part I—A tutorial on their data sharing</a>
            (<a href="http://link.springer.com/content/pdf/10.1007%2FBF01228709.pdf">Pdf</a>)
          </h3>
          <ol><li><a href="http://link.springer.com/search?facet-author=%22Prof.+David+K.+Hsiao+Ph.D.%22">Prof. David K. Hsiao Ph.D.</a></li></ol>
          <input type="checkbox" id="96206"/>
          <label for="96206">Abstract</label>
          <div>The issues and solutions for the interoperability of a class of heterogeneous databases and their database systems are expounded in two parts. Part I presents the data-sharing issues in federated databases and systems. Part II, which will appear in a future issue, explores resource-consolidation issues.Interoperability in this context refers to data sharing among heterogeneous databases, and to resource consolidation of computer hardware, system software, and support personnel.Resource consolidation requires the presence of a database system architecture which supports the heterogeneous system software, thereby eliminating the need for various computer hardware and support personnel. The class of heterogeneous databases and database systems expounded herein is termedfederated, meaning that they are joined in order to meet certain organizational requirements and because they require their respective application specificities, integrity constraints, and security requirements to be upheld. Federated databases and systems are new. While there are no technological solutions, there has been considerable research towards their development. This tutorial is aimed at exposing the need for such solutions. A taxonomy is introduced in our review of existing research undertakings and exploratory developments. With this taxonomy, we contrast and compare various approaches to federating databases and systems.</div>
        </li></ul>
        </li></ol>
        </div>
            </form>
          </body>
        </html>